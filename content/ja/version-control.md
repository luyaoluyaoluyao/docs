---
title: "バージョン管理"
#description: "Set a description with a maximum of 140 characters; this should describe what the goal of the document is, and it can be different from the document introduction; this is optional, and it can be removed"
tags:
  - "バージョン管理"
  - "アプリケーションのライフサイクル管理"
  - "コミット"
  - "共同作業"
---

## 1つの紹介

バージョン管理では、次の2つの方法でアプリ開発を管理できます。

* まず、モデルの現在のリビジョンとすべてのリソースを格納することができます([**](#commit)) 。 そのリビジョンを再度取得し、他のチームメンバーと共有できるように、識別子を与えます。
* 第二に、 複数の [*開発ライン*](#development-line)で作業を行うことができ、一度に複数の異なる機能を操作できるようになります。 これらの開発ラインは [**](#merge) で結合され、 *メインライン* に個別に作業されたすべての完了した機能が含まれるようになります。

Mendix のバージョン管理は [Apache Subversion](https://subversion.apache.org/) 上に構築されており、その概念は Subversion ユーザにとってよく知られています。 Mendixはモデラーと開発者ポータルに組み込むことでSubversionコマンドを簡素化します。

{{% alert type="warning" %}}

ここで説明するWebモデラーを含むプロセスは、Mendixバージョン7.23.3以降の共同作業に適用されます。

Mendix バージョン 7.23.2 以下のプロジェクトでは、Web Modelerとの同期はできません。 Webモデラーでプロジェクトを開くことができます。 しかし、Webモデラーは自動的に7.23の最新パッチバージョンにアップグレードします。
{{% /alert %}}

## 2つのコンセプト {#concepts}

### 2.1 チームサーバー

Team Serverは、Mendixアプリのコミットされたすべてのバージョンが保存される場所です。 アプリのリビジョンをコミットすると、チームサーバーに保存されます。

Team Serverにコミットするには、アプリケーションを編集できるプロジェクトのロールが必要です。

### 2.2 リポジトリ

*Team Server* 内には、各アプリがリポジトリに格納されます。 このリポジトリには、アプリの *ブランチ* の *コミットされたリビジョン* がすべて含まれています。

### 2.3 リビジョン

リビジョンは、 *Team Server* に保存された一瞬のアプリケーションのバージョンです。

アプリの各リビジョンには、それを識別し、将来的にそれを見つけることができるようにする固有の番号が与えられます。 次の2つの状況で *Desktop Modeler* から新しいリビジョンが作成されます:

* アプリはリポジトリにコミットされています
* デスクトップモデラーの作業コピーは、Webモデラーの作業コピーから更新されます。

### 2.4 作業コピー

作業コピーとは、現在モデラーで作業中のアプリのバージョンです。 Desktop Modelerの場合、アプリの開発ラインごとに1つの作業コピーがあります。 このモデルは、開発作業が行われている各コンピュータでローカルに保持されています。

Web Modelerでは、追加の作業コピーが *クラウドに保存されています。* これを編集できるのは一度に1つの開発者だけです。

### 2.5 マージ{#merge}

マージとは、あるアプリの *リビジョン* を取って、別のリビジョンで行われた差分を適用するアクションです。 詳細は 4.3 節 [ブランチの結合](#merging-branches) をご覧ください。

相違点のいずれかを適用できない場合は、 *競合*があります。

### 2.6 競合

競合は、2つのバージョンのアプリを自動的に組み合わせることができない場合に発生します。 これは、Desktop Modelerの作業コピーで同じドキュメントが変更され、コミットされた *リビジョン* でこれらの変更は調整できない場合に発生します。 例としては以下のようなものがある。

* ウィジェットのプロパティはリビジョンと作業コピーで変更されますが、異なる設定に変更されます。
* ドキュメントはリビジョン内で移動または削除されますが、作業コピー内で別の方法で変更されています。

競合が発生したとき 開発者は、新しいリビジョンとして Team Server にコミットする前にどのように解決すべきかを決定するために介入する必要があります。

### 2.7 アップデート

Desktop Modelerで呼び出されたアクションは、更新が実行されることです。 これは、Team Serverリポジトリから現在の *開発行の最新のリビジョン* を取得し、現在の作業コピーに差分をマージします。

この開発ラインでWebモデラーが有効になっている場合 最初のプロセスは、Web Modelerの作業コピーが新しいリビジョンとして保存されることを保証します。

### 2.8 コミット{#commit}

コミットは、Desktop Modelerで呼び出されたアクションです。 をクリックします。 *リポジトリ* にすべての変更を送信し、新しい *リビジョン* を作成します。

この開発ラインでWebモデラーが有効になっている場合 最初のプロセスは、Web Modelerの作業コピーが新しいリビジョンとして保存され、Desktop Modelerの作業コピーにマージされることを保証します。 競合がない場合は、変更がリポジトリに送信され、新しいリビジョンが作成されます。

### 2.9 開発ライン{#development-line}

アプリの開発は、関連する一連の変更が行われる開発ラインで行われます。 開発ラインには、 *メインライン* と *ブランチラインの2種類があります。*

#### 2.9.1 本線

Main Lineは、アプリの初期開発ラインであり、通常は本番環境にデプロイされるバージョンとして保持されます。 シンプルなアプリや、高度なコラボレーションを必要としないアプリは、メインラインしかない可能性があります。

#### 2.9.2 支線 {#branch-line}

支線とは、本線から離れて検証可能な変更の単独セットを作成する方法です。

分岐線の使用方法については、セクション 4, [分岐](#branches)を参照してください。

### 2.10 Web Modelerは有効です

開発ラインのいずれかでWebモデラーを有効にできます。 これは、開発者がWebモデラーを通じてアプリに変更を加え、チームと変更を共有できることを意味します。 すべての変更は選択したブランチにリンクされ、そのブランチのリビジョンとして反映されます。 他の開発ラインに加えられた変更は、Web Modelerでは利用できません。

Web Modelerは、開発ラインで有効になっていない場合、アプリの開発に使用できません。

開発者ポータル経由で作成されたアプリテンプレートの場合、新しいアプリのメインラインはWebモデラーが有効になります。

### 2.11 タグ

タグは *リビジョン* に加えてコミットを識別する方法です。 開発者によって指定され、以下の4つの部分があります。

* メジャー：重要な新機能、新しいユーザーインターフェイス、その他の重要な変更を識別するために使用されます
* マイナー：アプリのメイン機能を拡張する新しい機能を識別するために使用されます
* パッチ: 以前リリースされたアプリでエラーに *修正* を識別するために使用されます
* リビジョン: これは自動的に追加され、コミットのリビジョン番号です

## 3 単一ブランチのバージョン管理プロセス

以下の図は、2人の開発者がアプリケーションの *Web Modelerを有効にした* 開発ラインでどのように動作するかを示しています。 ある開発者はWebモデラーで、もう1人はDesktopモデラーで働いています。 両方とも、同じ開発ライン (メインライン など) で動作します。

![](attachments/version-control/image1.png)

### 3.1 Web Modelerのみでの作業

開発者は、Web Modelerのアプリ上で動作します。 彼らは状態1のアプリから始まり、これは新しいアプリまたはアプリのリビジョンにすることができます。 クラウドに保存されているWebモデラーの作業コピーに継続的に変更が加えられます。

![](attachments/version-control/image2.png)

### 3.2 デスクトップ モデラーのみでの作業

別の(または同じ)開発者は、Desktop Modelerで初めてアプリを開きます。 Web Modelerの作業コピーの現在の状態から、Team Serverに新しいリビジョン (状態 2) が作成されます。 これは、Desktop Modelerの作業コピーとしてローカルマシンにダウンロードされます。 Web Modelerは、コピー中にWebModeler作業コピーが安定しているように、一時的にロックされています。

開発者は、アプリのローカル作業コピーの Desktop Modelerで動作します。 このシナリオでは、Web Modelerで行われた作業はありません。

開発者はいつでもこれをTeam Serverリポジトリにコミットして、新しいリビジョンを作成することができます (状態3)。 このリビジョンは、Web Modelerの作業コピーにコピーされ、Web Modelerを使用している開発者は自動的に変更を受け取ります。

![](attachments/version-control/image3.png)

### 3.3 両方のモデラーでの作業

2人の開発者が、同じアプリの同じ *開発ライン* に同時に取り組んでいます。 1つはデスクトップモデラーを使用し、もう1つはWebモデラーを使用します。 両方のモデラーからの変更は、それぞれの作業コピーに保存されます: Desktop Modelerのローカルマシンと、Web Modelerのクラウドに保存されます。

![](attachments/version-control/image4.png)

### 3.4 デスクトップモデラー作業コピーの更新

Desktop Modelerを使用する開発者は、Web Modelerを使用して開発者によって行われた変更を含めたいと考えています。 作業コピーを更新することを選択します。

Web Modelerの作業コピーからのすべての変更は、Team Serverの新しいリビジョンに追加されます(状態4)。 このリビジョンは、Desktop Modelerの作業コピーにマージされます。 Desktop Modelerの作業コピーが更新されている間、 Web Modelerは一時的にロックされているため、コピー中にWebModelerの作業コピーが安定しています。

{{% alert type="info" %}}
このブランチに変更をコミットしている場合は、Desktop Modelerを使用している他の開発者からも変更が反映されます。
{{% /alert %}}

競合がある場合は Desktop Modelerを使用する開発者は、変更をTeam Serverリポジトリに反映する前にそれらを解決する必要があります。

![](attachments/version-control/image5.png)

### 3.5 チームサーバーリポジトリへのコミットの変更

Desktop Modelerを使用する開発者は、Team Serverに新しいリビジョンをコミットしたいと考えています。 これにより、Web Modelerを使用する開発者、またはDesktop Modelerを使用する別の開発者が有効になります。 開発者が行った変更を確認し、作業することができます。 また、リビジョンをクラウドにデプロイできることも意味します。

開発者がコミットを選択し、次のことが起こります。

* Webモデラーは一時的にロックされています
* Web Modelerの作業コピーはリビジョンとしてコミットされます (復元ポイント – 状態5)
* 作成されたばかりのリビジョン（状態5）は、Desktop Modelerの作業コピーとマージされます。

マージがない場合 *コンフリクト*, 更新されたDesktop Modelerの作業コピーは新しいリビジョン(状態6)としてコミットされ、Webモデラーは新しいリビジョンに更新され、ロックが解除されます。

競合がある場合は、Desktop Modelerを使用している開発者がこれらを解決する必要があります。 Web Modelerは、これを行っている間、Desktop Modelerからの変更を受け取ることなく、ロック解除されます。 Desktop Modelerを使用している開発者は再度コミットする必要があります。 そして、プロセスは最初から始まります (Web Modelerは、Web Modeler作業コピーからコミットする新しいリビジョンの準備ができてロックされています)。

![](attachments/version-control/image6.png)

## 4つのブランチ{#branches}

より複雑なアプリでは、コードをより洗練された方法で管理することができます。 例えば、 現在デプロイされているバージョンのアプリとは別に新機能を開発して、すべての新機能をリリースせずにバグを修正できるようにすることもできます。

これは *分岐線* を使用して行われます。

### 4.1 本線

すべてのアプリはメインライン( *トランク*とも呼ばれます)に沿って開発されています。 ここでは、以前のリビジョンに基づいて構築されたすべての変更とともに、すべての開発が単一の行に沿って行われています。

![](attachments/version-control/image7.png)

これは、単一ブランチのバージョン管理プロセス セクション3で説明されているバージョン管理プロセスの場合です。

当初、Web Modelerを使用している開発者は、Web Modelerが有効になっている開発ラインにのみアクセスできます。 ただし、Desktop Modelerを使用する開発者によって、別の開発ラインに切り替えることができます。

### 4.2 支線

ブランチラインを追加すると、既存の *リビジョン* のコピーを取り、そのコピーで別々に作業します。 一方のブランチに加えられた変更は他のブランチには影響しません。

Mendixでは、 *リポジトリ* 内の各リビジョンに固有のバージョン番号が与えられます。 これは、選択されたブランチ行に沿ってリビジョンに与えられたバージョン番号を連続的に使用することはできないことを意味します。

![](attachments/version-control/image8.png)

### 4.3 ブランチの統合{#merging-branches}

独立して継続され、他の開発ラインと組み合わせる必要はありませんブランチラインを持つことができます。 たとえば、アプリケーションの特定のリリース用にブランチを作成し、そのリリースのバグを修正するためにのみそれを使用することができます。

一方、あるブランチからの機能を別の開発ラインに追加したい場合があります。 これを行うための2つの例は次のとおりです。

* ブランチラインで新機能を開発し、メインの開発ラインに含めたいと思っています
* 別のブランチで作られたバグ修正を利用したいのです

ブランチ行の特定のリビジョンを現在の *作業コピー*にマージできます。 たとえば、リビジョン 6 に更新されたメイン行で作業している場合。 別のブランチラインから作業コピーに *マージ* リビジョン5を行えます。 その後、結果をコミットしてリビジョン 7 を作成できます。 ブランチからの複数の異なるコミット変更をマージする場合。 すべての変更を含むリビジョンの範囲を選択する必要があります。

![](attachments/version-control/image9.png)

セクション3の例と同様に、単一ブランチのバージョン管理プロセスでは、マージ中に競合が発生する可能性があります。 これらはアプリに変更を加える前に解決する必要があります。

*エラー* は、マージ中に競合が特定されない場合でも、 *マージ* プロセスによって発生することができることに注意してください。 エラーはモデラーにフラグが立てられており、アプリがデプロイされるのを防ぎます。 これらはリビジョンをデプロイできない可能性があるため、マージを行った後にエラーをチェックすることが重要です。

## このカテゴリ内の5つのメインドキュメント

* [デスクトップモデラーでバージョン管理を使用する](using-version-control-in-the-dm)
* [チームサーバー](team-server)
