---
title: "パフォーマンスのベスト・プラクティス(英語)"
description: "アプリのパフォーマンスを最適化する際のMendixのベストプラクティスについて説明します。"
parent: "mx-assist-performance-bot"
tags:
  - "studio pro"
  - "パフォーマンス"
  - "パフォーマンスボット"
  - "MXのアシスタント"
  - "メンディックスのアシスタント"
---

## 1つの紹介

このドキュメントでは、パフォーマンスの問題と、アプリのパフォーマンスを最適化するためのMendixのベストプラクティスを概説しています。

## 2つの計算された属性のベスト プラクティス。 {#mxp001}

<a name="mxp002"></a>オブジェクトが属性を計算したとき、このオブジェクトが変更またはストレージから取得されるたびに。 計算された属性はマイクロフローを呼び出すことで計算されます 計算された属性の背後にあるロジックが他のオブジェクトを取得したり、統合アクティビティを実行したりする場合。 ロジックの結果が使用されていない間に余分な負荷(および遅延)が発生します。 計算された属性を作成することは、パフォーマンスに影響を与えるため、使用する必要があるかどうかを評価する必要があります。 属性の詳細については、 [属性](attributes) を参照してください。

ほとんどの場合、計算された属性の背後にあるロジックは、オブジェクトが使用されるときに常に実行されます。 これは、取得アクティビティの取得スキーマが存在しない場合(データグリッドの場合)に実行されます。 計算された属性の背後にあるロジックは、次の要素で実行されます:

- マイクロフローのオブジェクト活動の取得と変更
- UI ウィジェット（データビュー、カスタムウィジェットなど）
- UIからオブジェクトをパラメータとしてマイクロフローに渡す場合 (例えば、ボタンでマイクロフローをトリガーするなど)。

計算されたアトリビュートには、簡単に修正できる2つの異なるパフォーマンスの問題があります。

1. [ページで計算された属性を使用する場合](#calculated-attribute-on-page)
2. [未使用の計算属性がある場合](#unused-calculated-attributes)

### 2.1 ページで計算された属性を使用しないようにする {#calculated-attribute-on-page}

アクティビティを取得すると、計算された属性のロジックがトリガーされます。 これは、データベースアクションとマイクロフロー呼び出しが実行される可能性があります (計算された属性を介してオブジェクトが互いに取得します)。

ページ上のデータウィジェット (リストビュー、データビュー、データグリッド) が計算された属性を使用している場合、 これはページの読み込みや表示に影響を与える可能性があります。

#### 2.1.1 修正する手順

問題を解決するには、次の手順を実行します。

1. ドメインモデルでは、計算の代わりに保存する属性を変更します。
2. 属性がデータベースにコミットされようとしているところでは、関連するマイクロフローを使用して値を計算します。

{{% alert type="info" %}}

属性が保存されるように変更された場合には、既存のデータを移行する必要があります。 データベースには、そのデータ型のデフォルト値のみが含まれます。

{{% /alert %}}

### 2.2 未使用の計算属性を削除 {#unused-calculated-attributes}

取得活動として計算された属性のロジックをトリガーします。 データベースアクションとマイクロフロー呼び出しの実行連鎖につながる可能性があります (計算された属性を介してオブジェクトが互いに取得します)。

計算された属性を使用しない場合、冗長なマイクロフロー呼び出しを避けるために安全に削除できます。

#### 2.2.1 修正する手順

問題を解決するには、未使用の計算済み属性を削除します。

## 3 並べ替えバーの属性にインデックスを追加 {#mxp003}

[ソートバー](sort-bar) はデータウィジェットの項目をソートするために使用されます。 並べ替えバーは 3 種類のデータウィジェットで使用できます。

- データグリッド
- テンプレートグリッド
- リファレンスセットセレクター

ソートバー内の各ソートアイテムは、ウィジェット内のデータの順序に順番に使用されます。 ソート項目で使用される属性に [インデックス](indexes) を追加すると、ソート処理が速くなり、その後ページのパフォーマンスが向上します。

作成、更新、削除、選択という4つの操作がエンティティ上で実行されます。 作成、更新の数を指定するエンティティ そして、削除操作は、選択操作の数を *書き込み集中* と呼ぶことができるよりもはるかに大きいです。なぜなら、ほとんどの操作はデータベース内のデータを変更するためであり、選択操作から選択するのではありません。

選択操作の数が作成、更新の数よりもはるかに大きい図形です。 そして、削除操作は、ほとんどの操作がデータベースからデータを選択するため、 *読み取り集約* と呼ぶことができます。 この最適化は、主に *読み取り集約型* であるエンティティに属する属性のみで行うことが重要です。

読み取り集中型および書き込み集中型のエンティティには、まったく異なるベストプラクティスが適用されます。 エンティティに対して実行される操作の種類によって実体を区別することは価値があります。

### 3.1 修正する手順

この問題を解決するには、ページのソートバー内のソート項目として使用される属性のインデックスを追加します。

## 4 オブジェクトの作成、オブジェクトの変更、アクティビティのコミットを行うループ内のオブジェクトを回避する {#mxp004}

<a name="mxp005"></a>In a microflow, Mendix objects can be persisted to the database with three activities: the **Create object** activity, **Change object** activity, and **Commit** activity. ループ内で作成または変更されたオブジェクトの場合、ループ内で即座にコミットするのはベストプラクティスではありません。 これには不必要なパフォーマンスが伴います 代わりに、 データベースを減らすために、ループの外で **コミット** 活動を使用して、いくつかの生成/変更されたオブジェクトのバッチコミットを実行することをお勧めします。 アプリケーションとネットワークのオーバーヘッドです For more information on **Create object**, **Change object**, and **Commit** activities, see [Create Object](create-object), [Change Object](change-object), and [Commit Object(s)](committing-objects).

オブジェクトのリストをコミットするには、個々のコミットと比較して以下の利点があります。

- データベース内でレコードを作成または変更する準備されたステートメントは、JDBC ドライバによって明示的に再利用され、以下の利点があります。
    - 実行計画はキャッシュされています
    - ドライバーはネットワークオーバーヘッドの最小値を管理します
- データを変更する各データベースアクションに対して、以下のアクションが実行され、オーバーヘッドが追加されます。
    - アクションの前にセーブポイントが作成され、その後にリリースされます
    - 自動コミットされたオブジェクトはデータベースから取得されます
    - 自動コミットされたオブジェクトはデータベースに保存されます (関連する場合)

### 4.1 オブジェクトのアクティビティを作成または変更するための修正手順

**Create** または **オブジェクトの** アクティビティをループ内で変更するには、次の操作を行います。

1. **** の **Create**/**Change** object activity from *No* and make sure created/changed objects are available in a list.
2. イテレーションが終了したとき、またはリスト内のオブジェクトの数が1000に達したとき、メモリ使用量が過大なことを避けるために、ループの後にリストをコミットします。

### 4.2 コミットアクティビティの修正手順

**コミット** 活動の問題を修正する イテレーションが終了したとき、またはリスト内のオブジェクトの数が1000に達したときに、メモリ使用量が過大なことを避けるために、ループの後にリストをコミットします。

## 5 適格マイクロフローをNanoflowに変換 {#mxp006}

Nanoflows は、エンドユーザーのデバイスまたはブラウザ上で直接実行されます。 これにより、オフラインでの使用に最適です。 対照的に、ランタイムサーバーで実行されるマイクロフローは、ネットワークトラフィックの使用を含みます。 適格なマイクロフローをナノレベルに変換することで、ネットワークを介した通信を回避し、アプリのパフォーマンスを大幅に向上させることができます。 いつ、いつ、それらを使うべきかについての詳細は、 [Nanoflows](nanoflows) を参照してください。

コンバーチブルマイクロフローは、以下の基準で識別できます。

- 次のカテゴリのうち1つ以上のマイクロフローがあります:
    - マイクロフローはオフラインアプリケーション用のロジックを備えています。
    - Microflow にはオンラインアプリケーションのロジックがありますが、コミット **オブジェクトの作成**などのデータベース関連のアクションは含まれません。 ** コミット** 、 ****、 ****、および **ロールバック** のアクティビティを取得します。
    - Microflow には、データベースに関連するアクションが 1 つあります。 （ベストプラクティスではない）
- ナノ互換性のある活動を含むマイクロフロー。 ナノフローでサポートされている活動の情報については、 [アクティビティ](activities) を参照してください。
- Microflow expressions do not contain the following variables: `$latestSoapFault`, `$latestHttpResponse`, `$currentSession`, `$currentUser`, `$currentDeviceType`. これらの変数はnanoflowsではサポートされていません。
- nanoflowは、現在のユーザのコンテキストで実行されるため、現在のユーザが許可されている操作のみがマイクロフローであることを確認します。 そうでなければ、変換されたnanoflowは失敗します。

### 5.1 修正する手順

問題を解決するには、次の手順を実行します。

1. モジュールを右クリックし、 **Add nanoflow**を選択して、新しいnanoflowを作成します。
2. マイクロフローから同じロジックを複製します。 新しいナノフローは、マイクロフローとほぼ同じように見えなければなりません。
3. マイクロフローの使用状況を確認するには、マイクロフローを右クリックし、 **使用状況を検索** を選択します。 新しく作成されたnanoflowですべての使用法を置き換えます。
4. 未使用のマイクロフローを削除します。 これを行うには、マイクロフローを選択して <kbd>削除</kbd> を押すか、右クリックして **削除** を選択します。

## 6 XPath 式で使用される属性にインデックスを追加 {#mxp007}

[XPath 式](xpath) は、基盤となるエンティティに含まれるレコードの数に応じて実行に時間がかかることがあります。 読み取り集約型エンティティの場合、XPath 式で使用される属性にインデックスを追加することは理にかなっています。 これにより、データベースからのオブジェクト検索のパフォーマンスが大幅に向上します。 XPath 式は、最初のクラスが可能な限り多くのアイテムを除外するように並べ替えることで最適化することもできます。 これは、式の前にインデックス付けされた属性を使用することで実現できます。 これにより、残りのデータセットはできるだけ小さくなり、データベースの負荷を軽減します。

XPath 式は3つの異なる場所で使用することができます:

- ルールとエンティティにアクセス
- ページ上のリストとグリッドのソース/フィルタ
- マイクロフローとJavaの両方のアクションを取得します

### 修正するための6.1 ステップ

問題を解決するには、次の手順を実行します。

1. インデックスを追加する前に、基になるエンティティにかなりの量のレコードが含まれているかどうかを確認します(少なくとも10000レコード)。
2. XPath 条件式で使用される各属性ごとにインデックスを追加し、元のエンティティに対してリード集約演算が主に実行されるシナリオに対してのみ実行されます。

{{% alert type="info" %}}

この最適化は、これらの型の可能な値の数が限られているため、ブール型や列挙型のようなデータ型にはあまり有益ではないかもしれません。 このようなタイプのインデックスを追加することは推奨されません。

{{% /alert %}}

## 7 持続可能でないエンティティのキャッシュを避ける {#mxp008}

非永続オブジェクトは一時的とみなされ、メモリ内にのみ存在するオブジェクトです。 これは永続性のないエンティティのインスタンスです。 持続可能で持続不可能なエンティティについての詳細は、 [持続可能性](persistability) を参照してください。 これらのオブジェクトはメモリ内にのみ存在するため、キャッシュは役に立ちません。 一方で、システム.セッションまたはシステム.ユーザの持続可能エンティティとの非持続可能エンティティの関連を作成することは冗長です。 その一方で、あまり変化しないが、ロジックで頻繁に使われるオブジェクトをキャッシュすることが重要です。 これは、データベース通信のオーバーヘッドを回避するのに役立ちます。 持続可能エンティティはシステムに接続することができます。ユーザのセッションは結果のキャッシュとして使用されます。 オブジェクトとキャッシュの詳細については、 [オブジェクト & キャッシュ](objects-and-caching) を参照してください。

以下のガイドラインを使用して、キャッシュが必要かどうかを決定できます。

- データはあまり頻繁に変化しません
- データは非常に頻繁に読み込まれます
- データの容量は制限されています(通常は10,000件未満)
- 古いデータの使用による影響は受け付けています

### 修正するための7.1 ステップ

問題を解決するには、次の手順を実行します。

1. あまり頻繁に変更されないエンティティの場合、そのオブジェクトがあなたのロジックで頻繁に使用されている場合に永続的にします。
2. 上記の条件が満たされていない場合, System.UserまたはSystem.Sessionと非持続エンティティの関連付けを削除.

