---
title: "タスクキュー"
parent: "リソース"
menu_order: 85
description: "タスクキューの概念と使用"
tags:
  - "タスクキュー"
  - "プロセスキュー"
  - "並列化"
  - "スケジュール中"
  - "マイクロフロー"
---

## 1つの紹介

**タスクキュー** を使用すると、タスクキューに割り当てることで同時に実行されるタスクの数を制御しながら、マイクロフローまたは Java アクションを非同期で実行できます。 すべてのマイクロフローとJavaアクションが最終的に実行されることを確保しながら、ピーク使用時にこれらのタスクによってアプリケーションに置かれる最大負荷を制御するようにタスクキューを構成できます。

### 1.1 プロセスキューモジュールの交換

バックグラウンドでタスクを実行するこの方法は、以前の [プロセスキュー](/appstore/modules/process-queue) マーケットプレイスモジュールよりも優先されます。

2つのメカニズムの違いについては、後述の [プロセスキュー](#process-queue)のセクションを参照してください。

## 2 の構成

マイクロフローまたは Java アクションは、Studio Pro で **「Microflow** 」または **「Java Action** を呼び出す」アクションを使用して開始されたときにバックグラウンドで実行するようにスケジュールできます。 またはJava APIを使用します。

### 2.1 タスクキューで実行中のタスク

#### 2.1.1 タスクをタスクキューに追加する際のプロセスフロー

実行される microflow または Java アクションをスケジュールすると、すぐに返されます。 タスクは、それが完了と呼ばれたトランザクションの後、できるだけ早くクラスタ内のどこかで実行されます。

タスクはバックグラウンドで実行されるため、戻り値はありません。 タスクが正常に実行された場合にのみ見つけることができます。 それを行う方法については、以下の [キュー](#interfacing-queue)を参照してください。

#### 2.1.2 タスクはどこで実行されますか?

単一ノードのシナリオでは、タスクキュー内のタスクは単一ノード上で実行されます。

クラスタ化された設定では、Mendixランタイムはクラスタ全体にこれらのタスクを透過的に配布します。 タスク実行中にクラスタノードがシャットダウンまたは失敗した場合。 残りのクラスタノードは(最終的には、ノードがダウンしていることが検出されたとき)、それを再実行します。 これは自動的に発生し、管理する必要はありません。

タスクキューを作成する際に、各ノードで並列に実行できるタスクの数を制御できます。 詳細については、 [タスクキュー](#create-queue)の作成を参照してください。

#### 2.1.3 タスク キューのコンテキスト

タスクキューで実行されている microflow および Java アクションの場合、タスクの実行コンテキストは以下の方法でわずかに変更されます。

 * They are always executed in a *sudo* context, even if a scheduling microflow has **Apply entity access** set to *true* (see [Microflow Properties](microflow) for more information).
 * コミットされた持続可能エンティティのみが、タスクのパラメータとして渡すことができます。 持続可能な *New* または *Changed* エンティティを渡すとランタイムエラーが発生します。 基本的には、エンティティが以前にコミットされているか、またはタスクが作成された同じトランザクションでコミットされていることを意味します。
 - タスクはすぐには実行されません。 タスクは、スケジュールされたトランザクションが正常に終了すると、タスクキューにのみ追加されます。 その時点で、任意のクラスタノードがそれを拾う可能性があります。
 - 例外が発生して実行に失敗した場合、失敗は `System.ProcessedQueueTask` テーブルに記録されます。

 {{% alert type="info" %}}
バックグラウンドタスクが実行されるコンテキストはまだ議論中であり、将来的に変更される可能性があります。
{{% /alert %}}

### 2.2 タスクキューの作成{#create-queue}

バックグラウンド実行は、いわゆる **タスクキュー** で行われます。 これらは Studio Pro で以下のように作成できます。

1. モジュールまたはフォルダを右クリックします。

2. **Add other** を選択します。

3. **タスクキュー** をクリックします。

4. クラスターノードごとに **スレッド** の値を入力します(最大40)。

    タスクキューには数のスレッドがあります。 これらの各スレッドは、一度に一つのタスクを処理できます。 つまり、キューはスレッドを持つ数だけ並行タスクをピックアップします。 タスクが完了するたびに、次のタスクがピックアップされます。

    一般的には、1つまたは2つのスレッドで十分でなければなりません 多数のタスクやタスクがない限り、時間がかかり、並列実行する必要があります。 多くのスレッドを使用すると、データベースに追加のロードが追加され、必要がない場合は行うべきではありません。

    ワーカースレッドの総数は 40 (クラスターノードあたり) に制限されます。 クラスタノードにはハードリミットはありません。

### 2.3 マイクロフローの実行をスケジュールする

#### 2.3.1 In Studio Pro

Studio Pro では、 [「Microflow](microflow-call) 」アクティビティを呼び出すと、タスクキューでマイクロフローを開始できます。

1. **コールマイクロフロー** アクティビティを編集します。
2. **タスクキュー** でこのマイクロフローを実行します。
3. **タスクキュー** をマイクロフローを実行するタスクキューに設定します。

#### 2.3.2 API

`com.mendix.core` の `コア` クラスには、 `microflowCall` メソッドが含まれています。 以下の例のように、バックグラウンド実行のためのマイクロフローをスケジュールするために使用できます。

```java
Core.microflowCall("AModule.SomeMicroflow")
  .withParam("Param1", "Value1")
  .withParam("Param2", "Value2")
  .executeInBackground(context, "AModule.SomeQueueName");
```

メソッド `executeInBackground` は、コンテキストとキュー名の 2 つのパラメータを取ります。 コンテキストはタスクを作成するためにのみ使用されます。タスクの実行はシステムコンテキストで行われます。 詳細は [API ドキュメント](https://apidocs.rnd.mendix.com/9/runtime/com/mendix/core/Core.html#microflowCall(java.lang.String)) を参照してください。

### 2.4 Java アクションの実行をスケジュールする

#### 2.4.1 Studio Pro で

Studio Pro では、 [[Java アクション](microflow-call) ] アクティビティを呼び出すと、タスクキューで Java アクションを開始できます。

1. **Java Action** を編集します。
2. **タスクキュー** でこのJavaアクションを実行します。
3. **Javaアクションを実行するタスクキューにタスクキュー** を選択します。

#### 2.4.2 API

`com.mendix.core` の `Core` クラスには、 `userActionCall` メソッドが含まれています。 以下の例のように、バックグラウンド実行のための Java アクションをスケジュールするために使用できます。

```java
Core.userActionCall("AModule.SomeJavaAction")
  .withParams(context, "Value1", "Value2")
  .executeInBackground(context, "AModule.SomeQueueName");
```

メソッド `executeInBackground` は、コンテキストとキュー名の 2 つのパラメータを取ります。 コンテキストはタスクを作成するためにのみ使用されます。タスクの実行はシステムコンテキストで行われます。 詳細は [API ドキュメント](https://apidocs.rnd.mendix.com/9/runtime/com/mendix/core/Core.html#userActionCall(java.lang.String)) を参照してください。

### 2.5 設定オプション{#configuration}

キューの優雅なシャットダウン期間は、Studio Pro で [カスタム ランタイム](custom-settings) 設定として設定できます。

| 設定オプション                         | 値の例   | 説明                                |
| ------------------------------- | ----- | --------------------------------- |
| `TaskQueue.ShutdownGracePeriod` | 10000 | シャットダウン時にタスクが完了するまでの時間をミリ秒で指定します。 |

{{% alert type="info" %}}
この猶予期間は [shutdown](#shutdown) (下記) の間に 2 回適用されるため、実行時にタスクが終了するまで待つ最大時間はこの値の 2 倍になります。
{{% /alert %}}

### 2.6 キュー{#interfacing-queue} のインターフェイス

タスクのスケジュールと実行のほかに。 Mendixプラットフォームは、バックグラウンドで実行されたタスクを追跡します。例えば、完了したタスクや失敗したタスクなどです。

内部的には、スケジュールされたタスクまたは実行中のタスクは Mendix エンティティ `System.QueuedTask` によって表されます。 高性能な設定では、基盤となるデータベーステーブルが頻繁に使用されるため、このエンティティは *ではなく* をユーザーコードによって直接使用する必要があります。 For example counting how many `System.QueuedTask` objects exist at the moment will lock the table and might cause a serious slowdown in task processing. `System.QueuedTask` に直接書き込むべきではありません。 代わりに、 ****  または **Java Action** を呼び出す、または Java API を使用してバックグラウンド実行のためのタスクをマークします。

処理が完了または失敗したタスクは、エンティティタイプ `System.ProcessedQueueTask` のオブジェクトとして保存されます。 これらのオブジェクトはユーザーが自由に使用できます。 たとえば、以下のように使用される可能性があります。

1. 必要に応じて失敗したタスクをスケジュール変更します(これは新しいタスクを作成することによって行われる必要があります)。
2. タスクが正常に実行されたことを確認するか、
3. エラーが発生した場合はアプリケーションをデバッグします。

`System.ProcessedQueueTasks` オブジェクトは削除されません。 ユーザーは自由にそれらを削除することができます。

### 2.7 タスクの状態

**System.QueuedTask** と `System.ProcessedQueueTask` の `ステータス` は、バックグラウンドタスクが存在する状態を反映しています。 値は次のとおりです。

* `Idle`: タスクが作成され、実行されるのを待っている。
* ``の実行 : タスクが実行中です。
* `Completed`: 正常に実行されたタスク。  これを反映するために `System.ProcessedQueueTask` が追加されました。
* `失敗した`: 例外が発生したため、タスクが実行されなくなりました。 失敗を反映するために例外を含む `System.ProcessedQueueTask` が追加されました。 タスクは再試行されません。
* `中止された`: 実行中のクラスタノードがダウンしたため、タスクは実行されなくなりました。 これを反映するために `System.ProcessedQueueTask` が追加されました。 タスクは別のクラスタノードで再試行されます。
* `互換性のない`: 実行できないような方法でモデルが変更されたため、タスクは実行されなかった。 これは、マイクロフローが削除/リネームされた、引数が変更された、またはタスクキューが削除されたためである可能性があります。

### 2.8 モデルの変更

Mendix ランタイムの起動時に、データベース内のスケジュールされたタスクが現在のモデルに適合することを保証するチェックがあります。 以下の条件がチェックされます:

* マイクロフローが存在することを
* パラメータが一致しますが
* 待ち行列が存在し

これらの条件のいずれかがチェックに失敗した場合、タスクは `システム.ProcessedQueueTasks` に **ステータス** `互換性のない` で移動されます。 ランタイムは、すべてのスケジュールされたタスクがチェックされた後にのみ開始されます。 これは、数千のタスクがある場合でも、一般的には非常に長い時間がかかる必要があります。

### 2.9 シャットダウン{#shutdown}

シャットダウン時に、 `TaskQueueExecutors` は新しいタスクの受け入れを停止します。 実行中のタスクは [猶予期間](#configuration) で終了します。 この期間以降は ランタイムは、まだ実行中のすべてのタスクスレッドに割り込みを送信し、再びそれらの猶予期間が終了することを許可します。 第2の猶予期間の後、ランタイムはちょうどシャットダウンを続け、最終的にタスクの実行を中止します。 中断されたタスクはリセットされ、後からまたは別のクラスタノードで再実行されます。 開発モードでは、最初の猶予期間が1秒に短縮されます。

{{% alert type="info" %}}
タスクスレッドを中断すると失敗する可能性があります。 これらのタスクは `中断された` としてマークされ、後で再試行されます。
{{% /alert %}}

## 3つのモニタリング

### 3.1 ログ

タスクキューに関連するすべてのアクションのために、 [](logging#mendix-nodes) `キュー` という名前のformat@@4 ログノード format@@5 が特別に存在します。

## その他 4

実行 **タスクキューで使用法** を検索すると、そのキューがマイクロフローで発生した場合のみが見つかります。

{{% alert type="info" %}}
Javaアクションからの呼び出しが見つかりません。
{{% /alert %}}

### 4.1 タスクキューヘルパー

Mendix Marketplaceの [タスクキューヘルパー](https://marketplace.mendix.com/link/component/117272) モジュールを使用して、タスクキューを実装するのに役立ちます。 次のようなものがある。

* タスクキューを監視するために使用できるページ
* 基本的なメンテナンス作業を行うことができるマイクロフロー

### 4.2 制限

タスクキューには以下の制限があります。

* バックグラウンドで実行されるマイクロフローまたは Java アクションは、作成された順序でできるだけ早く実行されますが、おそらく並列に実行されます。 これらはFIFO順に消費されますが、複数のスレッドの場合は並列に実行されます。 任意の時点で 1 つの microflow や Java アクションのみを実行する方法はありません。 スレッド数が 1 に設定されていて、単一のランタイムノードしかない場合は、タスクが順次実行されることを確認してください)。
* バックグラウンドで実行されるマイクロフローまたは Java アクションは *のみ* で、以下のタイプのパラメータを使用します: ブーリアン。 整数/長, 小数, 文字列, 日付と時刻, 列挙, 永続エンティティをコミット.
* バックグラウンドで実行されるマイクロフローまたは Java アクションは、すべての権限を持つ sudo/system コンテキストを使用します。 限定された権限を持つユーザーコンテキストを使用することはできません。
* バックグラウンドマイクロフローまたは Java アクションは、作成されたトランザクションが完了するとすぐに実行を開始します。 これにより、バックグラウンドマイクロフローまたは Java アクションによって必要とされるデータも確実に反映されます。 トランザクションの途中でバックグラウンドマイクロフローやJavaアクションをすぐに開始することはできません。 トランザクションがロールバックされた場合、タスクはまったく実行されないことに注意してください。
* ノードあたりの並列性の総量は40に制限されます。 つまり、並列性1を持つ最大40のキューを定義することができます。 または並列性40を持つ単一のキュー、またはその間のどこかで合計が40を超えない限り。
* 失敗したキューに入れられたアクションは、現在すぐに使えるボックスにスケジュールを変更することはできません。 スケジュールされたマイクロフローを設定して、失敗したタスクを再試行できます。 `System.ProcessedQueueTask` テーブルから問い合わせることができます。

### 4.3 高レベル実装の概要

タスクは `System.QueuedTask` テーブルのデータベースに格納されます。 For each background task a new object is inserted with a `Sequence` number, `Status = Idle`,  `QueueName`, `QueueId`, `MicroflowName` or `UserActionName`, and `Arguments` of the task. これは、microflow または Java アクションを呼び出してタスクキューに配置するトランザクションの一部として発生します。 つまり、トランザクションが正常に完了するまで、タスクはデータベースに表示されません。

次に、タスクは `更新SKIPロック` SQL文を実行する実行者によって消費されます。 次の自由任務を主張しようとします `SKIP LOCKS` 節は、他の実行者が更新するためにすでにロックされているタスクをスキップします。 対応する `UPDATE` は `ステータス` を `実行` に変更し、 `XASId` と `スレッドId` 属性のタスクのオーナーを設定します。

タスクが実行された後、それは `システムのオブジェクトに移動されます。 <code> 状態` の rocessedQueueTask `エンティティ` `完了` または `失敗した`。 タスクが例外で失敗した場合、これは `ErrorMessage` 属性に含まれます。

引数は `引数` に JSON 値として格納されます。 Arguments can be any primitive type ([variable](variable-activities))or a committed persistent object, which is included in the `Arguments` field by its Mendix identifier. タスクの実行時に、対応するオブジェクトは Mendix 識別子を使用してデータベースから取得されます。 このため、永続オブジェクトはタスクの実行前にコミットされなければなりません。実行時例外が発生するためです。

ノードがクラッシュすると、これは最終的に別のクラスタノードによって検出されます。これはハートビートタイムスタンプが更新されなくなったためです。 この時点で、他のノードはクラッシュしたノードで実行されていたすべてのタスクをリセットします。 リセットは次のアクションを実行します。

* `Status = Aborted` を持つ `System.ProcessedQueueTask` オブジェクトとしてタスクのコピーを作成します
* `ステータス` を `アイドル`に戻します
* `再試行された` フィールドをインクリメント
* `XASId` と `スレッドId` の項目をクリアする

タスクは、クラスタ内の残りのノードの 1 つによって再び自動的に消費されます。 これは、タスクが少なくとも一度は実行されることが保証されることを意味します。

{{% alert type="warning" %}}
通常の状況では、タスクは一度だけ実行されますが、ノード障害に直面した場合、タスクは(部分的に)複数回実行される可能性があります。 これは分散システムが提供できる最善の保証です。
{{% /alert %}}

### 4.4 プロセスキューの置き換え{#process-queue}

**タスクキュー** は以前の [プロセスキュー](/appstore/modules/process-queue) マーケットプレイスモジュールに取って代わられており、Mendix 9 のリリースで廃止予定となっています。 Process Queueモジュールと **Task Queue**にはいくつかの違いがあります:

* **タスクキュー** はマルチノードクラスタのセットアップをサポートしているため、水平方向のスケーリング環境で使用できます。
* **タスクキュー** は追加のエンティティを作成する必要はありません マイクロフローまたは Java アクションはバックグラウンドで実行するようにマークすることができるので。
* **タスクキュー** は、失敗したタスクの自動再試行をまだサポートしていません。
