---
title: "ユニークな制約の移行"
parent: "データストレージ"
menu_order: 30
tags:
  - "studio pro"
---

## 1つの紹介

通常、一意性検証制約はデータベースで処理されます。 これにより、ステートレスなクラスタリング、並行ユーザ数、上記の負荷アプリケーションを効率的に処理することができます。

次のルールはデータベースで検証できます:

* エンティティ属性のユニークルール
* 1対多の団体の *多面* 、および1対1の団体の *両側*。

ただし、実行時にデータ検証を行い、データベースに後で一意性検証を追加することも可能です。 既にデータが含まれている場合です 後日より厳格なルールを適用する場合、データベース内のデータは新しいバリデーションルールに準拠する必要があります。

このドキュメントについて説明します。

* データベースの一意性制約を加えることで
* ドメインモデルの検証を変更したときに既存のデータを移行する方法を教えてください
* 現在の検証ルールと矛盾する可能性のある既存のデータを確保する方法です 既存のプロジェクトモデルに準拠しているため、Mendixでデータベースの制約を使用してデプロイできます。

移行ツールキットは、データベース内のデータとモデルで定義されているバリデーションルールの間の矛盾を修正するのに役立ちます。

*一意性検証*の設定について詳しくは、 [プロジェクト設定](project-settings) を参照してください。

## 2つのユニーク属性

### 2.1 ランタイム一意性検証の効果

Mendix アプリがランタイム検証を使用している場合 現在のデータに影響を与えることなく、エンティティを変更して、属性に固有の検証ルールを追加できます。 例えば、 ドメインモデルでは保険番号がデータベースの人に固有のものであることを示すことができます それを使って誰かを特定したかったからです

![](attachments/datastorage/attr-uniq-validation-rule.PNG)

バリデーションルールを適用することは、新しいバージョンのアプリをより厳格なデータモデルでデプロイする前に、データベースに既に保存されていたユーザーには影響しません。 保険番号は、既存の人々と比較して、新しい人々のためにのみ一意性のためにチェックされます。

これの利点は、厳格なモデルが現在のデータに影響を与えないことです。 デメリットは、データベース内のデータの一意性について誤った仮定をすることが容易であるということです。 たとえば、マイクロフローのロジックは、固有の保険番号に依存する可能性があります。 保険番号が重複している古いデータの存在は容易に見落とされる可能性がある

### 2.2 ユニーク性確認のための現在の状況

一意性のためのランタイム検証の使用は推奨されていません。 ただし、削除されるまで、Runtimeの設定を行っています。 **Database**に設定すると、データベースレベルで一意の検証ルールを強制します。

![](attachments/datastorage/uniqueness-validation-setting.PNG)

このラジオボタンを **Database** に設定することを強くお勧めします。 これにより、Mendixの将来のバージョンに向けてアプリが準備されます。 ラジオボタンが **Runtime**に設定されたままの場合、非推奨の警告が表示されます。

![](attachments/datastorage/deprecation-warning.PNG)

### 2.3 データベース一意性検証の効果

**データベース** を選択する効果は、属性(既存のルールまたは新しいルール)に固有の検証ルールを持つモデルをデプロイする場合です。 影響を受けるエンティティの既存のすべてのオブジェクトは、属性の一意性がチェックされます。 同じ保険番号を持つ複数の人がある場合:

* Studio Pro からアプリをデプロイすると、デプロイ時にエラーが表示されます。
* デプロイメントパッケージからアプリをデプロイする場合 (Mendix cloudなど) アプリが起動せず、エラーがログに書き込まれます

![](attachments/datastorage/startup-error.png)

### 2.4 データベース一意性検証の使用に関する制限事項

別の(一般化)エンティティの専門化であるエンティティを使用している場合、データベースの一意性検証の使用には制限があります。

データベースの一意性検証オプションが有効になっています このエンティティの一般化から来る属性の特殊化エンティティに一意の検証ルールを定義することはできません。 これを行うと、この画像のように一貫性エラーが報告されます。

![](attachments/datastorage/unique-validation-rule-unresolved.png)

ただし、特別なエンティティに追加される属性の一意の検証ルールを定義することができます。

---

たとえば、2つのエンティティがあります。

* 一般エンティティ **Employee** 属性を持つ **EmployeeNumber**
* **EmailAddress**属性を持つ *Employee* に基づく、特殊なエンティティ **SalesEmployee**。

各 *SalesEmployee* は *EmployeeNumber* を *Employee* エンティティに含みます。 ただし、 *SalesEmployee* エンティティで *EmployeeNumber* を一意にする検証ルールを設定することはできません。

ただし、 *SalesEmployee* エンティティにのみ表示されるため、 *EmailAddress* をユニークにするバリデーションルールを設定できます。

---

これらの属性の一意の検証ルールを属性が定義された一般化エンティティに移動することで、この問題を簡単に解決できます。

![](attachments/datastorage/unique-validation-rule-resolved.png)

## 3つのユニークな関連

提携に匹敵する状況が発生します。 次の例を考えてみましょう:

![](attachments/datastorage/one-to-many-assoc.PNG)

ドメインモデルは最初に、 **アドレス** と **人** の間の1対多の関連付けを含んでいます。 つまり、Person は複数のアドレスを持つことができます。 しばらくすると、1人あたり1つのアドレスしか使用できないロジックがアプリに追加されたため、データ構造が変更されました。 適切なデータモデリングでは、関連付けを1対1の関連付けに変更することが規定されています。 新しいデータは更新された関連付けを正しく反映します。

![](attachments/datastorage/one-to-one-assoc.PNG)

データベース内の既存の関連データも更新された1対1の関連付けに準拠している必要があります。 これはデプロイ時にチェックされます。 個人が複数のアドレスを持っている場合、モデルはデプロイされません。 そして、Studio Pro または (Mendix) クラウドのデプロイログにエラーが表示されます。

![](attachments/datastorage/startup-error-assoc.png)

私たちは、1人あたり1つのアドレス(実際にはデータベースに複数のアドレスが存在する場合)のみを返すような見過ごされやすい間違いを避けるために、この新しい厳格な関連付けを既存のデータに適用します。 Mendix Platformは、実行ごとに一貫して同じアドレスを返しますが、他のアドレスはデータベース内の休止状態のエントリになります。

## 4 移行のヘルプ

古いデータの移行を支援するために、Mendixは移行ツールキットを開発しました。 詳細については、 [Mendix Support](http://support.mendix.com) までお問い合わせください。
