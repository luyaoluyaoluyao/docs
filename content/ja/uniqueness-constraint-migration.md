---
title: "ユニークな制約の移行"
parent: "データストレージ"
menu_order: 30
---

## 1つの紹介

アプリケーションの開発とデプロイメントの改善を容易にするために、Mendix 7の前のMendix Runtimeでデータ検証を処理しました。 これは、新しいバージョンのドメインモデルでより厳密な検証ルールが追加されても、古いデータが変更されないままデータベースに残る可能性があることを意味しました。

Mendix 7は、ステートレスなクラスタリング、並行ユーザの数が多いこと、および上記のロードアプリケーションに焦点を当てています。 効率的な理由から、いくつかのデータ検証はアプリケーションデータベースによって処理されます。 つまり、データベース内のデータは常にバリデーションルールに従う必要があります。 データの作成後に検証をより厳密にしてもです

このドキュメントでは、これらの変更がプロジェクトに与える影響を概説します。 また、ドメインモデルの検証に変更をデプロイする際に、既存のデータを移行する方法についても説明します。 最後に、アプリケーションに変更を加えていない場合でも、既に現在の検証ルールと互換性がない可能性があります。 このドキュメントでは、既存のデータが既存のプロジェクトモデルに準拠していることを確認し、Mendix 7でデータベース制約を使用してデプロイできるようにする方法について説明します。

次のルールは、Mendix 7のデータベースでも検証されます。

* エンティティ属性のユニークルール
* 一対一の団体の「多い」側、一対一の団体の双方。

移行ツールキットは、データベース内のデータとモデルで定義されているバリデーションルールの間の矛盾を修正するのに役立ちます。

## 2つのユニーク属性

Mendixの以前のバージョンでは、エンティティを変更し、現在のデータに影響を与えることなく属性に固有の検証ルールを追加できます。 例えば、 ドメインモデルでは保険番号がデータベースの人に固有のものであることを示すことができます それを使って誰かを特定したかったからです

![](attachments/datastorage/attr-uniq-validation-rule.PNG)

バリデーションルールを適用することは、より厳格なデータモデルでアプリの新しいバージョンをデプロイする前に、データベースにすでに保存されている人には影響しませんでした。 保険番号は、他の人と比較して、新しい人のための唯一の一意性のためにチェックされます。

これの利点は、より厳しいモデルが現在のデータに影響を与えないことでした。 でも欠点はデータベース内の一意のデータを 間違えるのは 簡単だということです たとえば、マイクロフローのロジックは、固有の保険番号に依存する可能性があります。 保険番号が重複している古いデータの存在は容易に見落とされる可能性がある

Mendix 7の将来のバージョンでは、このような状況はもう許されません。 トランジションとして、 **Database**に設定されている場合、ランタイム設定を提供します。 データベースレベルで一意の検証ルールを強制します

![](attachments/datastorage/uniqueness-validation-setting.PNG)

このラジオボタンを **Database** に設定することを強くお勧めします。 これにより、Mendixの将来のバージョンに向けてアプリが準備されます。 ラジオボタンが **Runtime**に設定されたままの場合、非推奨の警告が表示されます。

![](attachments/datastorage/deprecation-warning.PNG)

**データベース** を選択する効果は、属性(既存のルールまたは新しいルール)に固有の検証ルールを持つモデルをデプロイする場合です。 影響を受けるエンティティの既存のすべてのオブジェクトは、属性の一意性がチェックされます。 同じ保険番号を持つ複数の人がある場合は、Modelerからデプロイする場合にエラーが表示されます。 Mendix クラウドにアプリをデプロイすると、アプリは起動せず、ログにエラーが書き込まれます。

![](attachments/datastorage/modeler-startup-error.PNG)

ただし、データベースの一意性検証オプションが有効になっている場合、特殊な属性に対する一意の検証ルールの定義は許可されません。

特殊化で定義された固有の検証ルールを持つ特別な属性については、この画像のように、適切な整合性エラーが報告されます。

![](attachments/datastorage/unique-validation-rule-unresolved.png)

これらの一意の検証関連の不承認エラーは、特殊な属性の一意の検証ルールを一般化エンティティに移動することによって単純に解決することができます。

![](attachments/datastorage/unique-validation-rule-resolved.png)

## 3つのユニークな関連

提携に匹敵する状況が発生します。 次の例を考えてみましょう:

![](attachments/datastorage/one-to-many-assoc.PNG)

ドメインモデルは最初に、 **アドレス** と **人** の間の1対多の関連付けを含んでいます。 つまり、Person は複数のアドレスを持つことができます。 しばらくすると、1人あたり1つのアドレスしか使用できないロジックがアプリに追加されたため、データ構造が変更されました。 適切なデータモデリングでは、関連付けを1対1の関連付けに変更することが規定されています。 新しいデータは更新された関連付けを正しく反映します。

![](attachments/datastorage/one-to-one-assoc.PNG)

Mendix 7.3から、データベース内の既存の関連データも更新された1対1の関連付けに準拠することを強制します。 これはデプロイ時にもチェックされます。 個人が複数のアドレスを持っている場合、モデルはデプロイされません。 そして、Modelerまたは(Mendix)クラウドでのデプロイのログにエラーが表示されます。

![](attachments/datastorage/modeler-startup-error-assoc.PNG)

私たちは、1人あたり1つのアドレス(実際にはデータベースに複数のアドレスが存在する場合)のみを返すような見過ごされやすい間違いを避けるために、この新しい厳格な関連付けを既存のデータに適用します。 Mendix Platformは、実行ごとに一貫して同じアドレスを返しますが、他のアドレスはデータベース内の休止状態のエントリになります。

## 4 移行のヘルプ

古いデータの移行を支援するために、Mendix 6とMendix 7の移行ツールキットを開発しました。

{{% alert type="warning" %}}
MigrationToolkit は PostgreSQL データベースのみを使用するアプリケーション向けに設計されています。
{{% /alert %}}

詳細については、 [Mendix Support](http://support.mendix.com) までお問い合わせください。
