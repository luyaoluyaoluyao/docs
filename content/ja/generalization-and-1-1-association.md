---
title: "一般化 & 1対1の関連付け"
parent: "エンティティ"
menu_order: 5
---

Mendixの開発者は、継承を使用するかどうかを日常的に選択する必要があります。 それはあなたが新しいプロジェクトを開始した瞬間で始まります。どのようにユーザーをセットアップしますか? 管理モジュールで既に利用可能なアカウントエンティティを使用し続けますか？ または、ユーザーアカウントとの1対1の関連を持つ別々のエンティティで作業しますか? または、 **System.User** から継承された(複数)エンティティを追加しますか？

密接に関連する構造を定義する場合、最良のアーキテクチャを決定することは困難です。 エンティティは私の構造から継承すべきか、それとも私はむしろ一対一の関連付けを望むのか。 両方のオプションを検討する必要があります。 どちらのオプションもアプリケーションのパフォーマンスや開発速度に大きな影響を与える可能性があります。

## Mendixの一般化、専門化、継承。

Mendixドメインモデルは [UML](http://en.wikipedia.org/wiki/Unified_Modeling_Language) [クラス図](http://en.wikipedia.org/wiki/Class_diagram)に基づいています。 オブジェクト/エンティティ、属性、関連付けを指定することができます。 UMLの一般化の概念はMendixとまったく同じですが、MendixドメインモデルではGeneralizationを表示するために異なる表記を使用しています。 UMLクラス図は、スーパークラスを指す中空の三角形(矢印)との関連付けを使用します。 Mendix では、エンティティの上に青いラベルを付けてエンティティ名を指定します。

UML では、 [Aggregation](http://en.wikipedia.org/wiki/Aggregation_(object-oriented_programming)) や [Composition](http://en.wikipedia.org/wiki/Object_composition) などの関連タイプを指定することもできます。 これらの関連付けの定義は、オブジェクトが互いに存在しないことができるかどうかを指定します。 UMLとは異なり、私たちは関係船がどれほど強いかを指定することはできません。 2つのオブジェクト間の依存関係は、 [イベント microflow](/refguide7/event-handlers) または [delete behavior/prevention](/refguide7/associations) を使用して指定する必要があります。

### パフォーマンス

アプリケーションの影響と動作を理解するために [トランザクション](http://en.wikipedia.org/wiki/Database_transaction) と [(データベース) 単離レベル](http://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed) の基本的な概念を理解する必要があります。 Mendix PlatformはTransactionsを使用します。つまり、すべてのmicroflow、commit、deleteは(データベース)トランザクションで発生します。 このトランザクションは、microflow がデータベースへの最初の書き込みを実行するとすぐに初期化されます。 アクティビティの取得はトランザクションを開始することはありません。

Mendix Platformはトランザクションレベル [Read Committed](http://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed)を使用します。 名前が示すように、コミットされたオブジェクトだけがトランザクションの外に表示されます。 同時に変更されているオブジェクトにアクセスしようとする他のマイクロフローは、トランザクションが完了するまで待たなければなりません。 これは、継承または関連するオブジェクト間の選択に大きな影響を与えるため、知っておくことが重要です。

### オブジェクトの作成と変更

オブジェクトを変更する場合、Mendix Platformはコミットアクティビティを実行するとすぐにデータベースにこれらの変更を書き込みます。 更新または挿入クエリは、変更した値に基づいて実行されます。 この動作はデータベースごとに異なります。 しかし、ほとんどの場合、これはレコードをロックし、トランザクションが完了するまで他のユーザーがそれを読み取るのを防ぎます(完了またはロールバック)。

#### 継承

継承でオブジェクトを変更すると、プラットフォームはすべてのエンティティの階層からのすべての取得を妨げる可能性があります。 すべての回収に必要なスーパークラスを見ますので。

#### 一対一の協会

オブジェクトを変更する場合、関連するオブジェクトは変更されません。 このルールには2つの例外があります: もちろん、object イベントで関連付けられているオブジェクトを変更した場合。 または関連するオブジェクトは 'auto-committed' になっているため、 [Object Events](/howto7/data-models/working-with-object-events) を参照してください。

アプリケーションに多数の書き込みトランザクションがある場合はいつでも、1対1の関連付けを選択する方がはるかに優れています。 これはトランザクション中に変更/ロックされているテーブルの数を制限するためです。 ただし、更新よりも多くの挿入を行う場合は、再び継承を使用する価値があります。 継承はリレーションを保存するために1つ少ないテーブルを使用し、関連テーブルを持っていません。 したがって、任意の挿入には、更新が少ないインデックス付きテーブルが必要です。

### オブジェクトの取得

Mendixは、実行中のアクションに必要なデータのみを取得するように最適化されています。 つまり、例えば、関連付けられた属性や継承された属性を表示しない場合、それらのオブジェクトは取得クエリに含まれません。

#### 継承

スーパークラスから専門分野を取得した場合、プラットフォームには常にクエリーの階層全体が含まれます。 一貫性のあるデータ構造を保証するために 例えば、 **Adminstration.Account**の概要がある場合、プラットフォームにはシステムが含まれます。 System.User属性を表示するかどうかに関わらず、データが一貫して完全であることを確認するためのテーブルです。 両方のテーブルは、オブジェクト ID にクラスタ化されたインデックスを持っているため、データベースへの情報の結合は非常に効率的です。

#### 一対一の協会

関連付けられたオブジェクトは、ページに表示されているときにのみ取得されます。 関連付けテーブルを使用して情報を取得するため、継承よりも効率的ではありません。 情報がどのように整理されフィルタリングされるかに基づいて 継承で使用されるクラスタ化されたインデックスよりも、アソシエーションテーブルを結合する方がはるかに効率的ではありません。

継承された/関連付けられた情報の検索、並べ替え、表示がたくさん必要な場合は、継承を使用することが有意に効率的になります。 関連する情報が数ページのみで必要な場合。 継承の代わりに関連情報を取得する追加の遅延は、アプリケーション内の他の場所でより速い取得時間と比較して受け入れられるかもしれません。

## 柔軟性

継承と関連付けの間で決定を下すことは、アプリケーションに多くのデータをロードする前に行うべきことです。 関連付けを追加する場合、オブジェクト間のリレーションシップを指定するために追加のデータが必要になる場合があります。 一般化を削除すると、2つのオブジェクト間の関係は失われます。 しかし、以前の関係を解決するために使用できるトリックがあります。 アプリケーションに多くのデータがあると、これは非常に困難で時間がかかることがあります。

### 継承

継承を使用すると、マイクロフローをメンテナンスしやすくなります。機能を再利用できますが、柔軟性を失うこともできます。 一度エンティティに継承を適用すると、継承を削除し、すべてのデータを関連付けて保持することは困難です。 あるいは、レコードがサブクラスのタイプを変更できる場合(例えば従業員オブジェクトの変更など)、プロジェクトマネージャーオブジェクトになります。 ほとんどのシナリオでは完璧な解決策はありませんし、選択するときに意味を認識するだけで作る譲歩が常にあります。

単に継承を追加するのは簡単であるため、またはそれが遅いので削除しないでください。 特にシナリオでは異なるオブジェクトのタイプは、それだけで機能を再利用し、アプリケーションの一貫性と安定性を高めることができるので、継承を適用する価値がある同様のプロセスを通過する必要があります。 間違いなく継承を使用したくない場所の1つは、高いトランザクション量のシステムにあります。 テーブルでのレコードの書き込みや更新は、単一のテーブルを更新するよりも遅くなります。 多くの新しいオブジェクトや変更されたオブジェクトがロードされている場合、Excel、Webサービス、またはその他の統合の継承はプロセスを大幅に遅くする可能性があります。

### 一対一の協会

統合によりデータを読み込む場合、機能を再利用できるため、継承により開発速度が向上します。 これは、すべての将来の変更を1つの場所に適用する必要があるため、大きな利点です。 ただし、すべての変更を別のエンティティに格納できる場合、継承性はパフォーマンスが低下する可能性があります。 別のエンティティ内のすべてのデータを分離することが可能であれば、 この情報は限られた場所でのみ使用されます 1対1のエンティティを維持する方がかなり速くなります

## 結論

この説明は、継承をいつ使うべきかという質問に対する明確な答えを与えていない可能性があります。 それは正解も間違った答えもないからです 継承と一対一の協会の両方に長所と短所があります。 状況に基づいて、あなたは特定のエンティティのために何が良いかを決定する必要があります。 以下は、各状況のすべての長所と短所の概要です。 これらの基準に基づいて、どのソリューションに価値があるかを決定する必要があります。

明確な答えが与えられる場合がいくつかあります:

_エンティティに継承を使用しないでください:_

*   _異なるサブエンティティ上の多数のトランザクション（ハイとして、複数の変更または1秒あたりの作成を検討します）_
*   _一握りの共通属性のみ。 情報に関連付けられたオブジェクトを作成する価値がないと感じる場合は、それを継承する価値はありません。_

_エンティティに一対一の関連付けを使用しないでください:_

*   _それは常に関連付けられたオブジェクトからの情報を必要とし、ユーザは関連付けられた属性を集中的に検索してソートします。_
