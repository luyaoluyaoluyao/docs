---
title: "オフライン-最初"
category: "モバイル"
menu_order: 30
tags:
  - "オフライン"
  - "ネイティブ"
  - "モバイル"
  - "studio pro"
---

## 1つの紹介

オフラインファーストのアプリケーションは接続に関係なく動作し、継続的な体験を提供します。 ページとロジックは、デバイス自体のオフラインデータベースと相互作用し、データはサーバーと同期されます。 これにより、Snappier UI、信頼性の向上、およびデバイスのバッテリ寿命の向上がもたらされます。

{{% alert type="info" %}}
オフライン-ファーストは、デバイスのネットワーク状態に基づくアプローチではなく、アーキテクチャの概念であることを理解することが重要です。 オフラインファーストのアプリは接続に依存しませんが、接続を使用することができます (例えば、 マイクロフローを呼び出したり、Google Mapsウィジェットを使用したり、プッシュ通知を使用したりできます)。
{{% /alert %}}

Mendixは、 [ネイティブモバイル](native-mobile) および [ハイブリッドモバイル](hybrid-mobile) アプリ向けのオフラインファーストアプリケーションの構築をサポートしています。 ネイティブアプリとハイブリッドアプリの両方が同じコアを共有しており、これによりオフラインファーストの機能が同じになります。 ネイティブ モバイル アプリは常にオフライン第一ですが、ハイブリッド モバイル アプリでは、構成されているナビゲーション プロファイルによって異なります。 データはローカルデータベースでデバイスに保存され、ファイルはデバイスのファイルストレージに保存されます。

Mendix Studio Proは検証を実行し、オフラインファーストのアプローチに従い、接続がない場合でも機能します。

開発中 [Make It Native mobile app](https://play.google.com/store/apps/details?id=com.mendix.developerapp) (ネイティブ モバイル アプリ用) または [Mendix mobile app](https://play.google.com/store/apps/details?id=com.mendix.SprintrMobile) (ハイブリッド モバイル アプリ用) は、デバイスで Mendix アプリをプレビューしてテストするために使用できます。 Mendixアプリが初めて読み込まれた時 サーバー上でセッションを作成し、必要なデータとリソースをダウンロードするには、インターネット接続が必要です。 この最初の同期後も、インターネットに接続されていなくても、アプリ内でデータが利用可能になります。 後続の同期は、アプリケーションロジックまたはモデルの変更後、ユーザーが要求した場合に実行されます。

## 2 つの同期{#synchronization}

Mendixはアプリケーションのデータモデルを自動的に分析し、オフラインナビゲーションプロファイル内で使用されるページとナノフローに基づいて同期するエンティティを決定します。 さらに、プラットフォームは、ユーザーがアクセスできるデータのみが同期されるように、エンティティのアクセスを考慮します。

以下のシナリオで自動的に同期がトリガーされます:

* モバイルアプリの最初の起動
* 以下の条件が一致したときにMendixアプリを再デプロイした後のモバイルアプリの最初の起動:
 * ネットワーク接続があります
 * 新しいMendixバージョンを使用しているか、オフラインファーストアプリで使用されているドメインモデルが変更されました。
* アプリのユーザーがログインまたは終了した後

同期はMendixアプリの異なる場所を介して設定することもできます。

* ボタン上のアクション
* ナノレベルでのアクション
* リストビューのプルダウン操作（ネイティブモバイルのみ）

同期はデータベース レベルで実行されます。 これは、オブジェクトに対して何らかの変更を反映していないときに同期する場合を意味します。 ローカルデータベースの属性値は同期され、反映されていない変更は無視されます。 未コミットの変更は、同期後も使用できます。

### 2.1 同期タイプ

2 つのレベルで同期を実行できます:

* [完全な同期](#full-sync)
* [選択的同期](#selective-sync)

#### 2.1.1 完全同期 {#full-sync}

このモードでは、オフラインファーストアプリで使用されているすべてのエンティティのアップロードとダウンロードの両方を実行します。 [カスタマイズ可能な同期](#customizable-synchronization) を使用して、各エンティティの動作をカスタマイズできます。

#### 2.1.2 選択的同期 {#selective-sync}

選択的同期は、ナノフロー内の **** アクションを同期することによってのみ行うことができます。 このモードでは、特定のオブジェクトのセットが同期されます。 These objects can be either all unsynchronized objects when the [synchronize unsynchronized objects](synchronize#synchronize-unsynchronized-objects) mode is selected, or a manually selected set of objects when the [synchronize selected object(s)](synchronize#synchronize-selected-object-s) mode is selected.

UI 要素を使用して実行される同期 (ボタンやオン変更アクションなど) は、完全な同期を実行します。

### 2.2 同期フェーズ

同期プロセスは2つのフェーズで構成されています。 [アップロードフェーズ](#upload)では、アプリはコミットされた新しいオブジェクトまたは変更されたオブジェクトを使用してサーバーデータベースを更新します。 [ダウンロード フェーズ](#download)では、アプリはサーバーデータベースからのデータを使用してローカルデータベースを更新します。

#### 2.2.1 アップロード段階 {#upload}

アップロードフェーズは、サーバーにコミットする必要がある新規または変更されたオブジェクトの参照整合性の検証から始まります。 この検証は、それぞれのto-be-commitedオブジェクトの他のオブジェクトへの参照をチェックします。 この検証に失敗すると、同期は中止され、エラーメッセージが表示されます (エラーがキャッチされていない場合)。

[完全な同期](#full-sync) の間、この検証により、参照されるすべてのオブジェクトがローカルデータベースに反映されるようになります。 参照オブジェクトがデバイス上に作成され、まだローカルデータベースに反映されていない場合 サーバーデータベース上の無効な参照値を防ぐため、同期が中止されます。 同期はデータベース レベルでのみ機能することに注意してください。

For example, when a committed `City` object refers to an uncommitted `Country` object, synchronizing the `City` object will yield an invalid `Country` object reference, which will break the app's data integrity. データ整合性が壊れているときに同期が実行された場合 次のエラーメッセージが表示されます (修正するモデルのエラーを示します): **モデリングエラーのため同期に失敗しました。 あなたのデータベースには、コミットされていないオブジェクトを参照するオブジェクトが含まれています: タイプ `シティ` (参照 `City_Country`)**。 これを修正するには、このようなオブジェクトを同期する前に反映する必要があります(この例では、 `国` を同期する前に反映する必要があります)。

[選択的同期中](#selective-sync), 参照整合性の検証が実行され、参照されているすべてのオブジェクトが少なくとも一度サーバーデータベースに同期されるか、または選択に含まれているかを確認します。

例えば、 オフライン `国` オブジェクトを参照するコミットされた `都市` オブジェクトのみを同期させる（デバイス上で作成され、ローカルデータベースにコミットされていないが、まだ同期されていない）ことは、サーバーデータベース上の `都市` オブジェクトの整合性を壊すことになります。なぜなら `国` オブジェクトはサーバーデータベースには保存されないからです。 この場合、モデリングエラーであることを示す同様のエラーメッセージが表示されます。 これを修正するには、同期のためにそのようなオブジェクトを選択する必要があります。 この例では、 `Country` を `City` オブジェクトを同期する前に同期または同期で選択する必要があります。

アップロードフェーズは、検証後に次の操作を実行します。

1. ローカルデータベースは、オブジェクトをコミットすることによってのみ変更できます。 このようなオブジェクトは(オフラインであれば)新たに作成されたオブジェクトでも、サーバーから以前に同期された既存のオブジェクトでもかまいません。 アップロードフェーズは、最後の同期以降にローカルデータベースにコミットされているオブジェクトを検出します。 この検出は同期タイプごとに異なります。 **すべての**を同期するには、ローカルデータベース内のすべてのコミットされたオブジェクトが選択されます。 **オブジェクト**を同期するには、選択したオブジェクトのリストから、すべてのコミットされたオブジェクトが選択されます。
2. <a name="steptwo"></a>変更または新規のファイルオブジェクトがある場合、その内容はサーバにアップロードされ、一時的に保存されます。 各ファイルは個別のネットワーク要求にアップロードされます。
3. <a name="stepthree"></a>変更されたオブジェクトと新しいオブジェクトはすべてサーバーにコミットされ、ファイルの内容はオブジェクトにリンクされます。 この手順は、単一のネットワーク要求で実行されます。 これらのオブジェクトの before-commit または after-commit イベントハンドラは、いつものようにサーバ上で実行されます。 データがアップロードされダウンロードされる前に

#### 2.2.2 ダウンロード段階 {#download}

アップロードに成功した場合、ダウンロードフェーズは、ローカルデータベースがサーバーデータベースから最新のデータで更新されます。 ダウンロードフェーズの動作は、同期タイプごとに異なります。

**完全同期** — サーバーデータベースから最新のデータを取得するために、エンティティごとにサーバーにネットワーク要求が行われる。 アプリの同期動作をカスタマイズすることで、どのエンティティがローカルデータベースに同期されるかを管理できます。 この手順の詳細については、以下の [カスタマイズ可能な同期](#customizable-synchronization) セクションを参照してください。 ダウンロードプロセスは、ファイルエンティティの内容もダウンロードし、それをデバイスストレージに保存します。 このプロセスは漸進的です。 アプリは、ファイルが以前にダウンロードされていない場合にのみ、ファイルオブジェクトのコンテンツをダウンロードします。 ファイルが前回ダウンロードされてから変更されている場合。 ファイルオブジェクトの内容が変更されたかどうかを判断するために、ファイルエンティティの date 属性が使用されます。

**選択的同期** — 同期のために選択されたオブジェクトのみがローカルデータベースに同期される。 これらのオブジェクトを取得するための追加のネットワーク要求はありません。 オブジェクトは、アップロードフェーズで行われたネットワーク要求に応答して返されます。 ファイルエンティティが同期のために選択されている場合、そのコンテンツはデバイスストレージ上で増分更新されます。 ロジックは完全同期でも同じです。

### 同期後の2.3

同期が完了すると、アプリの現在のページのウィジェットが更新され、最新のデータが反映されます。 同期が nanoflow からトリガーされると、すべての nanoflow オブジェクト/リスト変数が更新されます(コミットされていない変更は保持されます)。

同期中にオブジェクトがデバイスから削除された場合、ナノフローオブジェクト変数の値が `空` になる可能性があることに注意してください。 これは以下の場合に発生する可能性があります。

* オブジェクトはサーバー上で削除されます
* 現在のユーザーは、オブジェクトへの十分なアクセス権がありません（セキュリティ・アクセス・ルールによって定義されています）
* エンティティは [カスタマイズ可能な同期](#customizable-synchronization) 画面上の XPath 制約により構成され、オブジェクトは指定された XPath 制約と一致しなくなります。
* The entity is configured with **Nothing (clear data)** option on the customizable syncing screen
* オブジェクトのアップロードフェーズは失敗します。例えば before commit イベントハンドラが false を返した場合などです。 一意の検証に違反したためコミットできません

### 2.4 カスタマイズ可能な同期 {#customizable-synchronization}

{{% alert type="warning" %}}
これらの設定は、 [選択的同期](#selective-sync) には適用されません。
{{% /alert %}}

デフォルトでは、Mendixは自動的に [同期](#synchronization)に記載されているように同期する必要があるオブジェクトを決定します。

ユースケースによっては、より詳細な同期制御が必要になる場合があります。 したがって、エンティティのダウンロード動作を変更することができます。 次のオプションから選択できます:

* **All Objects** — 定期的なセキュリティ制約を適用するすべてのオブジェクトをダウンロードする。
* **By XPath** — 通常のセキュリティ制約に加えて、 [XPath 制約](xpath-constraints) に一致するオブジェクトのみをダウンロードします。 これにより、XPath 制約に一致しない以前に同期されたすべてのオブジェクトが削除されます。
* **Nothing (clear data)** — Do not download any objects automatically, but do clear the data stored in the database for this entity when performing a synchronization (this can be useful in cases where the objects should only be uploaded, for example a `Feedback` entity).
* **なし (保存データ)** — 自動的にオブジェクトをダウンロードしない。 そして、同期を実行する際に、このエンティティのデータベースに格納されているデータをクリアしないでください（これは、同期を完全に制御したい場合や、** ** デバイスに同期 [または](synchronize-to-device) [](synchronize) アクティビティを選択した特定のオブジェクトと同期させる場合に便利です）。

Studio Proでオフラインファーストプロファイルで検出できないエンティティを使用するカスタム ウィジェットまたはJavaScriptアクションがある場合 (コードでのみ使用されているため) カスタマイズ可能な同期を使ってそのようなエンティティを含めることができます

{{% image_container width="450" %}}![custom synchronization](attachments/offline-first/custom-sync.png){{% /image_container %}}

### 2.5 制限

型(**full** または **selective**)に関係なく、同時に複数の同期プロセスを実行することはサポートされていません。 詳細については、 [リファレンスガイド](synchronize#limitations) の *制限事項* セクションを参照してください。

### 2.6 エラー処理 {#error-handling}

同期中にエラーが発生する可能性があります。 このセクションでは、Mendixがこれらのエラーをどのように処理し、どのようにそれらを防ぐことができるかについて説明します。

#### 2.6.1 ネットワーク関連エラー {#network-errors}

同期にはサーバーへの接続が必要なので、同期中にエラーが発生したり、ネットワーク接続が不十分な場合があります。 ネットワークエラーには、接続が切断されたりタイムアウトが含まれている場合があります。 既定では、ハイブリッドモバイルアプリのネットワーク要求ごとに同期のタイムアウトは30秒です。 ネイティブアプリの場合、デフォルトのタイムアウトはなく、タイムアウトはプラットフォームとOSのバージョンによって決定されます。

同期は原子で、すべてまたは何も同期されていないことを意味します。 例外は、以下の [Model- またはデータ関連エラー](#othererrors) セクションで説明されています。

If a network error happens during the file upload (via [step 2 in the upload phase](#steptwo)), Mendix retries to upload the failed files. 2回目のエラーが発生した場合、同期は中止されます。 その時点での変更はローカルデバイスに保存されるため、後で再試行することができます。

If a network error occurs while uploading the data (via [step 3 in the upload phase](#stepthree)), the data is kept on the local device and no changes are made on the server. [ステップ 2](#steptwo) にアップロードされたすべてのファイルは、次の同期中に再びアップロードされます。

If a network error (such as a timeout) occurs after uploading the data (at [step 3 in the upload phase](#stepthree)), the data is kept on the local device. しかし、サーバーはすでにリクエストに対して作業を開始しているため、リクエストを完了し、サーバーデータベースに変更をコミットします。 デバイスは、サーバーがリクエストを処理したかどうかを区別できないため、次の同期の試みには、すでに適用されている変更が含まれます。 この場合、サーバは Mendix のバージョンによって異なる動作をします。 Mendix Studio Pro v8で。 8 以下では、サーバーは再び同じ変更をコミットし、2 つの同期間で他のユーザーによって行われた潜在的な変更を上書きする可能性があります。 Studio Pro v8.18 以降では、このプロセスは最適化されており、サーバーは以前に適用されているため、同じ変更を反映しません。

ダウンロードフェーズ中にネットワークエラーが発生した場合、デバイス上でデータは更新されません。 したがって、ユーザーは作業を維持または再試行することができます。 アップロードフェーズの影響は、サーバーにロールバックされません。

同期がnanoflowから呼び出された場合は、nanoflowエラー処理を使用してエラーを処理することができます。 その他の場合(例えば、ボタンや起動時に同期が呼び出された場合) データを同期できなかったことをユーザーにメッセージが表示されます。

#### 2.6.2 モデルまたはデータ関連のエラー {#othererrors}

同期中に、変更されたオブジェクトと新しいオブジェクトがコミットされます。 以下の理由により、オブジェクトの同期に問題が発生する可能性があります。

* オブジェクトはサーバー上で使用できなくなりました (アクセスルールにより削除またはアクセスできなくなります)
* アクセスルールによりオブジェクトのメンバにアクセスできなくなりました
* before-commitイベントマイクロフローまたはafter-commitイベントマイクロフローの実行中にエラーが発生します
* このオブジェクトはドメインレベルの検証ルールに従って有効ではありません

{{% alert type="warning" %}}上記の理由により同期エラーが発生した場合。 オブジェクトのコミットはスキップされ、その変更は無視され、他のオブジェクトからの参照は無効になります。 このようなスキップされたオブジェクト(エラーをトリガーしていない)を参照しているオブジェクトは正常に同期されます。 このような状況は、モデリングエラーになり、サーバーにログインする可能性があります。 データの損失を防ぐために、そのようなオブジェクトの属性値は `System.SynchronizationError` エンティティ (Mendix 8.12 以降) に格納されます。  {{% /alert %}}

### 2.6.3 同期の問題の防止 {#prevent-sync-issues}

上記の問題を回避するために、以下のベストプラクティスに従うことをお勧めします。

* 削除、名前を変更しない または、最初のリリース後にオフラインアプリのエンティティまたはその属性の種類を変更する — これはオフラインユーザーがオブジェクトまたは値にアクセスできなくなる可能性があります(必要に応じて)。 下位互換性のある"in-between"リリースを行い、すべてのアプリが同期された後に次のリリースで変更を加えることができます)
* オフラインユーザーに同期できるオブジェクトを削除しないでください（同期しようとした場合、これらのオブジェクトの変更が失われます）
* オフラインエンティティにドメインレベルの検証を使用しないようにする – 代わりにナノフローや入力検証を使用する (マイクロフローを使用してサーバー上で再度検証することも良い習慣です)
* 他のオブジェクトから参照されているオブジェクトをコミットする場合は、他のオブジェクトも反映されていることを確認してください

ナノフローの同期アクションを使用して同期がトリガーされ、エラーが発生した場合。 nanoflowエラーハンドリングを使って優雅にエラーを処理することができます。

### 2.6.4 競合解決 {#conflict-res}

複数のユーザーがデバイス上で同じオブジェクトの状態を同期することがあります。 変更してから、このオブジェクトをサーバーに戻します。 この場合、最後の同期は、サーバー上のオブジェクトの内容全体を上書きします。 これは「ラストウィン」アプローチとも呼ばれます。

別のアプローチが必要な場合は、before-commit microflow 内で競合を検出することができます (エンティティのリビジョン ID 属性を使用するなど)。 これに基づいて、カスタムの競合解決を実行することができます。

## ベストプラクティス3選 {#best-practices}

Mendixアプリケーションの最高のユーザーエクスペリエンスを確保するには、次のベストプラクティスに従ってください。

* 同期設定またはセキュリティ アクセス ルールをカスタマイズして同期するデータの量を制限します
* ネットワーク接続が遅く、信頼性が低く、モバイルデバイスにはストレージが限られていることが多いためです。 大きなファイルや画像の同期を避ける（例えば、写真のサイズを制限するなど）
* UI 要素の代わりに nanoflow を介して同期を試みると、同期に失敗した場合に処理できる同期アクティビティにエラー処理を追加できます (接続エラー)。 モデルとデータ関連のエラーなど)
* 選択した同期を使用して大容量のファイルや画像を同期
* サーバー上で競合を正しく処理できるように、 `isDeleted` ブール属性を削除機能に使用します
* 前または後のプロセスデータにコミットする前と後のマイクロフローを使用する
* ナノフローで [マイクロフロー呼び出し](microflow-call) を使用して、RESTサービスからデータを取得するなどの追加のサーバーサイドロジックを実行します。 またはJavaアクションなどの複雑なロジックにアクセスして使用する
* ユーザーがデータを同期させるのを忘れないようにし、できるだけ早く処理されます。接続を確認し、オブジェクトをコミットする nanoflow 内で自動的に同期することができます。 または、通知を使用している間、またはサインアウトする前に、データが失われないようにユーザーに同期するように通知します

## 4 アプリがオフラインであることを確認する {#limitations}

Mendixは、開発者がリッチオフラインファーストのアプリを構築するのに役立ちます。 しかし、いくつかの制限があります。 詳細は以下のサブセクションを参照してください。

### 4.1 マイクロフロー {#microflows}

マイクロフローは、サーバ上でロジックを実行するために、ナノフローで [マイクロフローコール](microflow-call) を使用してオフラインアプリケーションから呼び出すことができます。 ただし、オンラインプロファイルで使用する場合とは少し異なりますが、これらの違いについては以下で説明します。

#### 4.1.1 マイクロフロー引数タイプ

* オブジェクトまたは持続可能エンティティのリストを渡すことはサポートされていません
* オブジェクトまたは持続可能エンティティとの関連を持つ非持続可能エンティティのリストを渡すことはサポートされていません(関連付けは間接的な関連にすることができます)
* 別のマイクロフローで作成された永続性のないエンティティを渡すことはサポートされていません

#### 4.1.2 UI アクション

UI関連のアクションは無視され、効果はありません。 このようなUI副作用を呼び出しのnanoflowでモデル化することをお勧めします。

これらのアクションは以下のとおりです:

* [メッセージを表示](show-message)
* [検証メッセージを表示](validation-feedback)
* [ホームページを表示](show-home-page)
* [ページを表示](show-page)
* [ページを閉じる](close-page)
* [ファイルをダウンロード](download-file)

#### 4.1.3 オブジェクトサイドエフェクト

同期しない限り、マイクロフローで作成された持続可能オブジェクトへの変更はクライアントに反映されません。 変更を反映するためには、永続性のないオブジェクトを返さなければなりません。

#### 4.1.4 マイクロフローの戻り値

* オブジェクトまたは持続可能エンティティのリストを返すことはサポートされていません
* オブジェクトまたは持続可能エンティティとの関連を持つ非持続可能エンティティのリストを返すことはサポートされていません (この関連は間接的な関連になることができます)

#### 4.1.5 言語切り替え

Mendix アプリの言語を切り替えられるようにするには、デバイスがオンラインであり、Mendix ランタイムにアクセスできる必要があります。 ランタイムの詳細については、 [ランタイムリファレンスガイド](runtime) を参照してください。

### 4.2 オフラインマイクロフローのベストプラクティス {#offline-mf-best-practices}

マイクロフローの呼び出しをオフラインファーストアプリから動作させるために、Mendixはいくつかのマイクロフロー情報をオフラインアプリに格納します。 その情報はアプリから呼び出されます。 つまり、オフラインアプリから使用されるマイクロフローへの変更は後方互換性がある必要があります。 まだ空気のアップデートを受けていない古いアプリがあるからです このようなデバイスからのすべてのマイクロフロー呼び出しには、古いマイクロフロー呼び出し構成がnanoflowsで含まれます。つまり、要求が失敗する可能性があります。 アップデートの詳細については、 [アプリセンターの CodePush でアップデートをリリースする方法](/howto/mobile/how-to-ota) を参照してください。

最初のリリース後のオフラインマイクロフロー呼び出しで後方互換性エラーを避けるために、以下のベストプラクティスをお勧めします。

* マイクロフローの名前を変更したり、別のモジュールに移動しないでください
* オフラインアプリから呼び出されるマイクロフローを含むモジュールの名前を変更しない
* マイクロフローパラメータの追加、削除、名前の変更、変更を行わない
* 戻り値の型を変更しない
* すべてのデバイスが更新を受け取ったことを確認する前に、マイクロフローを削除しないでください

上記の実践から逸脱したい場合は、新しいマイクロフローを導入します。 マイクロフローの内容を変更できます。 ただし、古いアプリがアップデートされるまで、新しいバージョンのマイクロフローを呼び出す可能性があることに注意してください。

### 4.3 Autonumbers & 計算された属性 {#autonumbers}

autonumbers と計算された属性の両方がサーバからの入力を必要とします。したがって、それらは許可されません。 これらの属性タイプを持つオブジェクトはオフラインで表示および作成できますが、属性自体は表示できません。

### 4.4 デフォルトの属性値 {#default-attributive}

ドメインモデルのエンティティのデフォルトの属性値は、オフラインで作成されたオブジェクトに影響を与えません。 ブール属性は常に `false`、数値属性は `0`、その他の属性は `空` にデフォルトになります。

### 4.5 多数の関連付け {#many-to-many}

多くの関連付けはサポートされていません。 一般的な代替手段は、他のエンティティと1対多の関連を持つ第三のエンティティを導入することです。

### 4.6 継承 {#inheritance}

一般化や専門化の関係から複数のエンティティを使用することはできません。 For example if you have an `Animal` entity and a `Dog` specialization, you can use either use `Animal` or `Dog`, but not both from your offline profile. 代替パターンはコンポジションを使用することです (例えば、オブジェクトの関連付け)。

### 4.7 システムメンバー {#system-members}

システムメンバー (`createdDate`, `changedDate`, `owner`, `changedBy`) はサポートされていません。

### 4.8 ExcelとCSVエクスポート {#excel-cv}

ExcelおよびCSVエクスポートはオフラインアプリケーションでは使用できません。
