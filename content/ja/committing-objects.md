---
title: "コミットオブジェクト"
parent: "object-activity"
menu_order: 30
tags:
  - "studio pro"
---

{{% alert type="warning" %}}
このアクティビティは、 **Microflow** と **Nanoflows** の両方で使用できます。
{{% /alert %}}

## 1つの紹介

**コミット** アクティビティは 1 つ以上のオブジェクトで動作します。 持続可能エンティティの場合、コミットするオブジェクトはデータベースに格納されます。 持続可能でないエンティティをコミットすると、現在の属性値と関連付け値がメモリに格納されます。これにより、ロールバックがそれらの値に戻ることができます。 [永続性](persistability) も参照してください。

{{% alert type="info" %}}
Mendix コミットは、常にデータベースコミットのように動作するとは限りません。 詳細については、 [コミットの仕組み](#how-commits-work)を参照してください。
{{% /alert %}}

## 2つのプロパティ

以下の画像では、コミット オブジェクトのプロパティの例を示します。

![コミットオブジェクトのプロパティ](attachments/object-activities/commit-properties.png)

このアクティビティには2つのプロパティがあります。 左側のダイアログボックスと右側のプロパティ ペインに表示されています

コミット オブジェクトのプロパティ ペインは次のセクションで構成されています:

* [アクション](#action)
* [一般的な](#common)

## 3つのアクションセクション{#action}

プロパティ ペインの format@@0 セクションには、このアクティビティに関連付けられたアクションが表示されます。

アクションの横にある省略記号 (**…**) をクリックすることで、このアクションを構成するためのダイアログボックスを開くことができます。

また、マイクロフロー内のアクティビティをダブルクリックするか、アクティビティを右クリックして **プロパティ** を選択することで、ダイアログボックスを開くこともできます。

### 3.1 オブジェクトまたはリスト

コミットするオブジェクトまたはオブジェクトのリスト。

### 3.2 イベントあり

{{% alert type="info" %}}
このプロパティはマイクロフローのみです。
{{% /alert %}}

オブジェクトのコミットイベントハンドラーを実行するかどうかを示します。

デフォルト: *はい*

#### 3.2.1 Nanoflowでのイベント

Nanoflows にはこの特性はありません。

commit object(s) アクションがオンラインアプリで使用されている場合、Mendix Runtimeにcommit requestを送信し、常にイベントを実行します。

コミットオブジェクトアクションがオフラインアプリで使用されている場合、変更はオフラインデータベースに反映されます。 イベントハンドラは、オフラインのアプリが同期したときに実行されます。

### 3.3 クライアントで{#refresh-in-client} を更新

この設定では、エンドユーザーに表示されるページに変更が反映される方法を定義します。

デフォルト: *いいえ*

{{% alert type="info" %}}
Mendix アプリのページを効率的にするために、多くのウィジェットはページにキャッシュされたオブジェクトの属性から値を表示します。 Attributes in widgets which use cached data are *always* reflected in the client when they are updated or deleted irrespective of the value of **Refresh in client**.

If a widget is only updated when a [data source](data-sources) is loaded, then changes will only be seen when **Refresh in client** is set to *Yes*.

アプリをテストする際は、選択したウィジェットで希望するデータが表示されていることを確認してください。
{{% /alert %}}

{{% alert type="warning" %}}
多数のオブジェクトをコミットする場合、「クライアントでリフレッシュ」を有効にしないことをお勧めします。
{{% /alert %}}

#### 3.3.1 マイクロフローは、オンラインアプリでクライアントから呼び出されます

クライアント **の更新** が *いいえ*に設定されている場合、変更はクライアントに反映されません。

*はい*に設定すると、関連する [データ ソース](data-sources) の再ロードを含む、オブジェクトはクライアント全体でリフレッシュされます。

#### 3.3.2 マイクロフローはオフライン、ネイティブ、またはハイブリッドアプリで呼び出されます

オフライン、ネイティブ、またはハイブリッドアプリから呼び出されるマイクロフロー内の場合 **クライアントの** オプションは無視され、 **いいえ** に設定されているかのように機能します。

詳細については、 [オフライン-First Reference Guide](offline-first#microflows) の *Microflow* セクションを参照してください。

#### 3.3.3 アクションは Nanoflow にあります

When inside a [nanoflow](nanoflows), the object is refreshed across the client as if **Refresh in client** was set to *Yes*.

## 4つの共通セクション{#common}

{{% snippet file="refguide/microflow-common-section-link.md" %}}

## 5 コミットの仕組み{#how-commits-work}

### 5.1 オブジェクトをコミットする

オブジェクトをコミットすると、現在の値が保存されます。 つまり、マイクロフローの **ロールバック** アクションを使用して、オブジェクトの以前の値にロールバックすることはできません。

ただし、Mendix **コミット** はデータベースの **コミット** と同じではありません。 永続的なエンティティのオブジェクト 保存された値は、マイクロフローと呼ばれるマイクロフローが完了するまでデータベースに反映されません。 これは、マイクロフロー *内のエラーが* ロールバックを開始する可能性があることを意味します。 If a microflow action errors and has **Error handling** set to *Rollback* or *Custom with rollback*, the value of the object *will* be rolled back to the value it had at the start of the microflow. 詳細は [Error Event](error-event#errors-in-microflows) を参照してください。

Mendix は *非持続可能な* エンティティのこの動作を模倣します。 Committing a non persistable entity means you cannot use a **Rollback** action to go back to the previous values, although rollback error handling in a microflow *will* roll back to the original values.

### 5.2 自動コミットと関連オブジェクト

オブジェクトがデフォルトのformat@@0ボタン、コミットアクティビティ、またはWebサービスを介してコミットされると、常にコミットイベントがトリガーされます。 プラットフォームは、関連するすべてのオブジェクトも評価します。 データの一貫性を保証するために、プラットフォームは関連するオブジェクトを自動コミットすることもできます。

autocommit は、ドメインモデルを同期させるために行われるプラットフォームからの自動コミットです。 アプリケーションが自動コミットされたオブジェクトを持つことになった場合、モデリングエラーが発生します。 関連付けはオブジェクトのメンバーでもあるため、関連付けはデータベースにも保存されます。 これは、注文内に注文行を作成し、注文行が関連付けの親である場合に意味します。 注文行をコミットすると、注文は自動コミットされます。

{{% alert type="warning" %}}
自動コミットは明示的なコミットと同じではありません！

何らかの理由でロールバックがトリガーされた場合 (例えば、ユーザーセッションがブラウザを閉じることによって終了した場合) 自動コミットされたオブジェクトはデータベースから削除されます。 Mendixが永続的なオブジェクトをどのように扱うかについては、 [永続性](/refguide/persistability) を参照してください。
{{% /alert %}}

自動コミットされたオブジェクトになった場合、モデリングエラーが原因で常に発生します。 ある時点で、関連付けられたオブジェクトが新しいオブジェクトに設定され、関連付けられたオブジェクトがコミットされました。 すべての関連団体はすべてのデータを一貫性を保つことを約束しています

コミット中に以下のことが起こります:

* イベント: *が明示的にコミットされた* オブジェクトの場合、イベントが実行される前後にすべてのオブジェクトが実行されます。 そして、before-rollback イベントが false を返した場合、例外を投げることができます。
    * イベント中に例外が発生した場合、デフォルトのエラー処理動作で適用されたすべての変更が元に戻されます。
    * コミットの前に行われた変更は保持されます
        {{% alert type="warning" %}}イベントの前後は自動コミットされたオブジェクトに対して実行されません。{{% /alert %}}
* データベース: 明示的にコミットされたオブジェクトと自動コミットされたオブジェクトの両方に対して挿入または更新クエリが実行されます
    * オブジェクトの状態によって異なります。 プラットフォームは状態 **インスタンス化** を持つオブジェクトの挿入を行い、他のすべての状態の更新を行います
* 結果: 状態を持つオブジェクト インスタンスがデータベースに挿入され、他の状態を持つオブジェクトが更新されます。

![](attachments/object-activities/18582172.png)
