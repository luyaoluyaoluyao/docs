---
title: "一般化 vs 一対一の関連"
parent: "ドメインモデル"
menu_order: 50
tags:
  - "ドメインモデル"
  - "関連"
  - "継承する"
  - "一対一で"
  - "一般化"
---

## 1つの紹介

場合によっては、別のモジュールで使用されるエンティティに情報を追加したい場合があります。 おそらくMendixマーケットプレイスからインポートされたモジュールです。 エンティティをカスタマイズしたくない場合、モジュールの更新バージョンを取得できなくなります。 別の場合には、エンティティのオブジェクトに追加情報を追加する場合がありますが、他のオブジェクトには追加情報を追加しない場合があります。 これらの場合、2つの方法があります: **一般化** (または、 *継承* と呼ばれることが多い) と **関連エンティティ**。

Mendixの開発者は、継承または関連付けを使用するかどうかを日常的に選択する必要があります。 ほとんどのアプリで発生する1つの例は、ユーザーをどのように設定するかを決めることです。 管理モジュールで既に利用可能なアカウントエンティティを使用し続けますか？ または、ユーザーアカウントとの1対1の関連を持つ別々のエンティティで作業しますか? または、 **System.User** から継承された(複数)エンティティを追加しますか？ この場合、システムに直接追加情報を追加するのは悪い方法です。 実際には、メンディックスはあなたがそうすることを防いでいます。

密接に関連する構造を定義する場合、最良のアーキテクチャを決定することは困難です。 エンティティは基底構造から継承する必要がありますか、それともむしろ1対1の関連を使用する必要がありますか? アプリケーションのパフォーマンスや開発速度に大きな影響を与える可能性があるため、両方のオプションを検討する必要があります。

## 2 Generalization, Specialization & inherited from

Mendix ドメインモデルは [UML](http://en.wikipedia.org/wiki/Class_diagram) の [クラス図](http://en.wikipedia.org/wiki/Unified_Modeling_Language)に基づいています これにより、オブジェクト/エンティティとそれらの属性と関連付けの指定が可能になります。 Mendixの一般化の概念は、UMLとまったく同じです。 ただし、Mendix ドメインモデルでは、一般化を表示するために異なる表記法を使用します。 UMLクラス図は、スーパークラス(意味、一般化)を指す中空の三角形(矢印)との関連付けを使用します。 Mendix では、一般化エンティティ名を指定し、専門エンティティの上に青いラベルで表示されます。

![一般化表記の例](attachments/domain-model/generalization-indication.png)

UML では、 [Aggregation](http://en.wikipedia.org/wiki/Aggregation_(object-oriented_programming)) や [Composition](http://en.wikipedia.org/wiki/Object_composition) などの関連タイプを指定することもできます。 これらの関連付けの定義は、オブジェクトが互いに存在しないことができるかどうかを指定します。 UMLとは異なり、私たちは関係がどれほど強いかを指定することはできません。 2つのオブジェクト間の依存関係は、 [イベント microflow](/refguide/event-handlers) または [delete behavior/prevention](/refguide/association-properties#delete-behavior) を使用して指定する必要があります。

### 2.1 パフォーマンス

アプリケーションの影響と動作を理解するには [トランザクション](http://en.wikipedia.org/wiki/Database_transaction) と [(データベース) 単離レベル](http://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed) の基本的な概念を理解する必要があります。

Mendix Platformはトランザクションを使用します。つまり、すべてのマイクロフロー、コミット、削除は(データベース)トランザクションで行われます。  このトランザクションは、microflow が最初のデータベース処理を実行するとすぐに初期化され、マイクロフローが完了すると終了します。 データベースへの書き込みアクションは、変更されたオブジェクトに対して書き込みロックを取り、これらはトランザクションの終了まで保持されます。 これが、すべてのタイプのエンティティや関連付けの書き込みアクティビティができるだけマイクロフローの終わりに向かって移動されることをお勧めする理由です。 ロックは、一方で、取得アクションの終了まで最後まで、アクティビティを取得するために取得します。

Mendixプラットフォームは、分離レベル [Read Committed](http://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed)を使用します。これは、コミットされたオブジェクトのみがトランザクション外で読み取れることを意味します。 別のマイクロフローが変更中のオブジェクトを読み込もうとしている場合。 取引が完了するまで待たなければなりません。 この分離レベルの実装方法の詳細は、データベース管理システム(PostgreSQLなど)によって異なります。 これは、継承または関連するオブジェクト間の選択に大きな影響を与えるため、知っておくことが重要です。

### 2.2 作成 & オブジェクトの変更

オブジェクトを変更する場合 Mendix Platformは、コミットアクティビティを実行するか、変更オブジェクトの **コミット** アクションを **はい**に設定すると、データベースにこれらの変更を書き込みます。 更新または挿入クエリは、変更した値に基づいて実行されます。 しかし、これはトランザクションを終了しません。 正確な動作は、使用するデータベース管理システムによって異なります。 しかし、ほとんどの場合、これはレコードをロックし、トランザクションが完了するまで他のユーザーがそれを読み取るのを防ぎます(完了またはロールバック)。

#### 2.2.1 継承

継承でオブジェクトを変更すると、プラットフォームはすべてのエンティティの階層からのすべての取得を妨げる可能性があります。 全ての回収に必要な一般化を見ることになります

#### 2.2.2 一対一の協会

オブジェクトを変更する場合、関連するオブジェクトは変更されません。 このルールには2つの例外があります。オブジェクトイベントで関連するオブジェクトを変更する場合。 または関連するオブジェクトが 'autocommitted' の場合は、 [Object Activities](object-activities) を参照してください。

アプリケーションに多数の書き込みトランザクションがある場合はいつでも、1対1の関連付けを選択することをお勧めします。 これはトランザクション中に変更/ロックされているテーブルの数を制限するためです。 ただし、更新よりも多くの挿入を行う場合は、再び継承を使用する価値があります。 継承はリレーションシップを格納するために1つ少ないテーブルを使用します。関連テーブルはありません。 したがって、任意の挿入には、更新が少ないインデックス付きテーブルが必要です。

### 2.3 オブジェクトの取得

ページ上のデータウィジェットを使用する場合、Mendixは実行中のアクションに必要なデータのみを取得するように最適化されています。 つまり、たとえば、関連付けられた属性や継承された属性を表示しない場合、それらのオブジェクトは取得クエリに含まれません。 ドメインモデル内のエンティティが XPath 制約を使用してアクセスルールを含んでいる場合、追加のデータが取得される可能性があります。 たとえば、現在のユーザに基づく制約は、ユーザに関する情報を取得する必要があります。

ただし、マイクロフローを使用してデータを取得する場合、すべてのデータが取得されます (下記の [Microflow](#microflows)を参照)。

#### 2.3.1 継承

専門分野を取得した場合、プラットフォームはこのデータが必要な場合にのみ、汎用オブジェクトから属性を取得します。

これに対する一つの例外は System.User エンティティです。 **Administration.Account**の概要がある場合は、プラットフォームにシステムが含まれます。 セキュリティが本番環境に設定されている場合は、System.User属性を表示するかどうかにかかわらず、serテーブルを使用します。 両方のテーブルは、オブジェクト ID にクラスタ化されたインデックスを持っているため、データベースへの情報の結合は非常に効率的です。

一般化をクエリする場合、専門化の属性が必要な場合、メインクエリの後に追加のクエリが実行されます。

#### 2.3.2 ワンツーワン協会

一対一の団体の場合 関連するオブジェクトはページに表示されるときに取得され、メインクエリの後に追加のクエリが発生します。 これは、関連付けテーブルを使用して情報を取得するため、継承よりも効率的ではありません。 情報の順序とフィルタ方法によって異なります。 一般的には、継承で使用されるクラスタ化されたインデックスよりも、アソシエーションテーブルを結合する方が効率が低くなります。

継承された/関連付けられた情報の検索、ソート、および表示を多く必要とする場合、継承を使用する方が効率的になります。 一方、関連する情報が数ページでのみ必要な場合。 継承の代わりに関連情報を取得する追加の遅延は、アプリケーションの他の部分でより速い取得時間と比較すると許容される可能性があります。

## 3つの柔軟性

継承と関連付けの間で決定を下すことは、アプリケーションに多くのデータをロードする前に行うべきことです。 関連付けを追加する場合、オブジェクト間のリレーションシップを指定するために追加のデータが必要になる場合があります。 一般化を削除すると、2つのオブジェクト間の関係は失われます。 しかし、以前の関係を解決するために使用できるトリックがあります。 アプリケーションに多くのデータが保存されると、これは困難で時間がかかります。

### 3.1 継承

継承を使用すると、マイクロフローをメンテナンスしやすくなり、機能を再利用できます。 しかし、柔軟性を失います。 一度エンティティに継承を適用すると、継承を削除し、関係を使用してすべてのデータを保持することは困難です。 レコードがサブクラスのタイプを変更できるかどうか、例えば従業員の専門化オブジェクトの変更などを考慮して、プロジェクトマネージャーオブジェクトになります。 ほとんどのシナリオでは完璧な解決策はありませんし、選択するときに意味を認識するだけで作る譲歩が常にあります。

単に継承を追加するのは簡単であるため、またはそれが遅いので削除しないでください。 特に、異なるオブジェクト タイプが同様のプロセスを経なければならないシナリオでは。 機能を再利用してアプリケーションの一貫性と安定性を高めるためだけに継承を適用する価値があります

しかし、一対一の団体が継承することが望ましい場所は、取引量が多い制度である。  テーブルでのレコードの書き込みや更新は、単一のテーブルを更新するよりも遅くなります。 Excel、Webサービス、またはその他の統合を介してロードされた多くの新しいオブジェクトや変更されたオブジェクトがある場合、継承はプロセスを大幅に遅くすることができます。

### 3.2 ワンツーワン協会

統合時にデータを読み込むと、機能を再利用できるため、継承によって開発速度が向上します。 これは、すべての将来の変更を1つの場所に適用する必要があるため、大きな利点です。 ただし、すべての変更が別のエンティティに格納されると、継承によってパフォーマンスが低下する可能性があります。 別のエンティティ内のすべてのデータを分離することが可能であれば、 この情報は限られた場所でのみ使用されます 1対1のエンティティを維持する方が速くなります

## 4 マイクロフロー {#microflows}

ページのデータ検索は、エンティティとのみ結合し、データビューで使用される属性を取得するように最適化されています。 マイクロフローは活動を回収しません。 マイクロフローでは、 ** すべての列が、エンティティの一般化と専門化から取得されます。 さらに、関連するすべてのエンティティは、選択したエンティティが関連付けの親端にある場合に取得されます。

多くの属性を持つエンティティでは、データベースから多くのデータが取得されます。 親である多くの関連性を持つエンティティでは、これはまた、多くの追加のクエリにつながります。

microflow における最も効率的な検索は、所有者の型 `デフォルト` との関連性を持つオブジェクトであり、オブジェクトは `子の` です。 In other words, where you are retrieving an object which is at the `one` end of a `one-to-many` association. このオブジェクトを取得した場合、子テーブルであるため、デフォルトでは関連テーブルは読み込まれません。 1対多の協会を持つことは、必ずしも便利ではなく、1対1の協会を作ることです。 with owner type `どちらも` は関連付けを親と親の関連付けのように動作させ、オブジェクトの検索が常に関連付けられたオブジェクトを取得するようにします。

## 5 結論

この説明では、継承または関連付けをいつ使用するかという質問に対する明示的な答えは与えられていない可能性があります。 それは正解も間違った答えもないからです 継承と一対一の協会の両方に長所と短所があります。 あなたの状況に基づいて、あなたは特定のエンティティのために何が良いかを決定する必要があります。

しかし、明確な答えが与えられる場合がいくつかあります。

* エンティティに1対1の関連付けを使用します。
  * 異なるサブエンティティ上の多数のトランザクション（複数の変更または1秒あたりの作成はハイとみなされます）
  * ほんの一握りの共通属性だけです — 情報に関連付けられたオブジェクトを作成する価値がないと感じる場合は、どちらを継承する価値はありません。

* エンティティに継承を使用:
  * 関連するオブジェクトからの情報を常に必要とし、ユーザは集中的に関連する属性を検索してソートします。
