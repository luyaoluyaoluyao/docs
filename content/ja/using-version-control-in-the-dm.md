---
title: "デスクトップモデラーでバージョン管理を使用する"
category: "バージョン管理"
menu_order: 10
description: "バージョン管理の使い方と、発生する可能性のあるいくつかの問題を解決する方法"
tags:
  - "バージョン管理"
  - "競合"
  - "解決"
  - "結合"
  - "パッチ"
  - "ブランチ"
  - "開発"
---

## 1つの紹介

このリファレンスガイドでは、Desktop Modelerのバージョン管理の使用方法について説明します。 バージョン管理の仕組みの背後にある理論は Mendix で、コンセプトの定義は [Version Contol](version-control) にあります。

## 2 バージョン管理を使ったプロジェクトの開始

バージョン管理の新しいプロジェクトを開始するには、次の操作を行います。

1. Desktop Modelerで **New Project...** を選択します。
2. **App Settings** ダイアログで、 **Enable online services** を *Yes* に設定します。 このオプションは、Team ServerリポジトリとDeveloper Portalプロジェクトを作成します。
3. **プロジェクト ディレクトリ**を変更するか、Desktop Modelerが提案するデフォルトのままにします。
4. **Create app** をクリックします。

チームサーバー上にアプリが作成され、 **プロジェクトディレクトリ** に作業コピーが作成されます。 これは、即座に作業を開始できるように、Desktop Modelerで開かれます。

![](attachments/modeler-core/2018-03-02_11-11-18.png)

## 3 プロジェクトへの参加

すでにTeam Server対応のプロジェクトがある場合は、招待して参加することができます( [Team](/developerportal/collaborate/team) を参照)。

チームメンバーになると、十分な権利を持つロールが与えられます。 次のように操作できます。

1. Desktop Modelerで **Open project...** を選択します。
2. *Mendix Team Server* を **アプリはどこに保存されますか？**.
3. **Team Server App** ドロップダウンからアプリを選択します。
4. **プロジェクト ディレクトリ**を変更するか、Desktop Modelerが提案するデフォルトのままにします。
5. **Create app** をクリックします。

プロジェクトはチームサーバーからダウンロードされ、Desktop Modelerで開かれます。

![](attachments/modeler-core/open-new-team-server-app.png)

## 日々の4つの開発

プロジェクトの作業コピーがディスク上にあるとしましょう。 アプリに変更を加え、保存します。 保存された変更は他のユーザーにはすぐには表示されません。 変更された文書、フォルダ、およびモジュールは、 **ステータス** を見ることで識別できます。

一連の変更に満足している場合は、リポジトリに **** コミットします。 その後、それらの変更を更新して取得することを選択することができます。

他のユーザーによってコミットされた変更で作業コピーを **** 更新できます。

また、誰がコミットしたかに関係なく、コミットされたすべての変更の **履歴** を見ることができます。

### 4.1 ステータス

プロジェクトのステータスは、オリジナルと比較した場合の作業コピーのすべての変更の概要です。 モデラーは、プロジェクトエクスプローラーと **変更** ドックの両方でステータスを表示します。

プロジェクトエクスプローラには、何らかの方法で変更されたアイテム(ドキュメント、フォルダ、モジュール)の前にアイコンが表示されます。 異なるアイコンは、行われたさまざまな種類の変更を示しています。

| アイコン                               | 意味                                                  |
| ---------------------------------- | --------------------------------------------------- |
| ![](attachments/524294/688173.png) | このアイテムに何も起こりませんでした。 変更しない w.r.t です。 オリジナルに          |
| ![](attachments/524294/688172.png) | このアイテムを（内、ドキュメント、フォルダ、またはモジュールとして）修正しました。           |
| ![](attachments/524294/688175.png) | このアイテムを追加しました。                                      |
| ![](attachments/524294/688174.png) | このアイテムをプロジェクトツリー内の別の位置に移動しました。                      |
| ![](attachments/524294/688164.png) | このアイテムを削除しました。                                      |
| ![](attachments/524294/688165.png) | このアイテムは競合しています。 詳細は [競合への対処](#conflicts) を参照してください。 |

{{% alert type="info" %}}
1 つのアイコンのみのスペースがあり、ドキュメントが変更されて移動されている場合、ドキュメントが変更されて表示されます。
{{% /alert %}}

たとえば、microflow ChangePassword が変更されたとします。 また、「Flows」という新しいフォルダが追加され、このフォルダ内にすべてのマイクロフローが移動されました。 スクリーンショットでは、変更を含むフォルダーとモジュールが黄色のアイコンで表示されていることが確認できます。 移動したマイクロフローには青いアイコンがついています これにより、プロジェクト内の変更箇所をすばやく確認できます。

![](attachments/modeler-core/2018-02-21_13-27-21.png)

変更ドックにも同じ情報が表示されます。 この場合、 *変更* ごとに項目があります。 ドキュメントが両方とも変更され移動されている場合、そのドキュメントには *2行* 行があります。 ドックには、削除されたアイテム、プロジェクトエクスプローラが行うことができないアイテムも表示されます。

![](attachments/modeler-core/2018-02-21_13-41-50.png)

{{% alert type="info" %}}
プロジェクトのコミットに成功したとき これが新しいオリジナルになり全ての変更情報がプロジェクト・エクスプローラと 変更ドックから削除されます
{{% /alert %}}

### 4.2 コミット

リポジトリへの変更の送信は *コミット* と呼ばれます。 アイデアは、リポジトリに小さな一貫した作業をコミットすることです。 頻繁に変更をコミットすることをお勧めします。 好ましくは、リポジトリ内のバージョンは常にエラーなしで、Modelerはプロジェクトにエラーがある間、コミットに対して警告します。

To commit your changes, click the **Commit** button in the *Changes* dock, or choose the **Project > Commit...** menu item.

![コミットボタン](attachments/modeler-core/commit-button.png)

一般に、1つの機能を実装したり、1つのバグを修正したりした後にコミットすることをお勧めします。 頻繁にコミットすることによって、あなたの仕事は定期的に他の人の仕事と統合されます。 頻繁にコミットする利点は次のとおりです。

* もし衝突が起きたら変化はまだ新鮮だ
* 改訂は理解しやすいのです
* 何かを元に戻す必要がある場合は、小さな作業を元に戻すことができます

リポジトリ内の新しいリビジョンで結果をコミットします。 コミットを実行するときに、Desktop Modelerに次の情報を追加することができ、これは新しく作成されたリビジョンに添付されます。

* テキストメッセージ これはあなたが行った変更の概要である必要があります
* コミットに関連するデベロッパーポータルのストーリーのリスト。 小さなコミットは、おそらく一つの物語に関連します。 モデラーは、現在のスプリントにあるストーリーを表示し、 *Done* のステータスを持っていません。 ストーリーをコミットに追加すると、デベロッパーポータルのストーリーの状態は変更されません。 ステータスを 'Done' に設定するには、手動で行う必要があります。 *done* の定義に依存します。

![](attachments/modeler-core/2018-02-21_13-50-03.png)

モデラーはまた、いくつかの情報を自動的に添付します:

*   コミットした人 ( *作者*)
*   コミットの日時
*   変更されたドキュメント、フォルダ、モジュールのリストと変更の種類 ( *modify* や *add* など)
*   コミットに使用されたモデラーのバージョン

Javaソースコードも変更した場合。 追加されたウィジェットまたはプロジェクト ファイル以外のファイルに影響を与えるその他の変更を加えた場合は、 **ディスク** タブのページで変更を加えて、コミットしようとしているディスクの変更を表示します。

コミットは、作業コピーがリポジトリと最新の場合にのみ許可されます。 前回更新した時点から他の誰かが変更をコミットした場合は、最初に更新する必要があります。 これは、コミットを使用して作成したリビジョンが、あなたの変更と他の人による変更の両方を組み込む必要があるためです。 更新により、リポジトリの最新の変更が変更と結合されます。 結果を確認し、競合を修正した後、再度コミットすることができます。

### 4.3 更新

更新は、リポジトリから最新の変更を取得します。 リポジトリに変更をコミットする前に、作業コピーにまだない他の人によって行われた変更を組み込むためにこれを行う必要があります。 取得した変更数が少ないように頻繁に更新することをお勧めします。

To update the working copy of your app, click the **Update** button in the *Changes* dock, or choose the **Project > Update** menu item.

![更新ボタン](attachments/modeler-core/update-button.png)

更新時にリポジトリから受け取った変更は、作業コピーに加えた変更(もしあれば)と結合されます。 その後、作業コピーには変更内容と受け取った変更の両方が含まれます。 アップデートの一環として、作業コピーのオリジナルも更新されます。

たとえば、前回更新した場合、リビジョン 40 までのすべての変更を受け取ったことになります。 作業コピーの原本はリビジョン40だ 作業コピーに変更を加え始めて以来、チームの他の人々はさらに4つのコミット(41、42、43、44)を行っています。 今アップデートすると、それらの変更を受け取り、44があなたの変更が比較される新しい *オリジナル* になります。

通常、リポジトリからの最新のリビジョンと変更を組み合わせると自動的に行われます。 たとえば、ある人がマイクロフローを変更している間にフォームを追加することができます。 しかし、変更が近すぎると、競合が発生する可能性があります。 たとえば、いずれかのチームが、変更した同じデータビューのプロパティを変更した場合です。 コミットする前に、このような競合を解決する必要があります。 これを行う方法については、6章 [競合への対処](#conflicts) を参照してください。

チームが頻繁にコミットしている場合は、頻繁に更新する必要があります。 頻繁なアップデートには、アップデートごとに少ない変更を受け取るメリットがありますので、これらの変更を作業と統合するのが簡単です。

### 4.4 履歴

プロジェクトの *履歴* は、コミットされたすべてのリビジョンのリストです。 To view the history of the project, click the **History** button in the *Changes* dock, or choose the **Project > More Versioning > History...** menu item.

![履歴ボタン](attachments/modeler-core/history-button.png)

リビジョンは、逆年代順に表示されます(最新のものはリストの先頭に表示されます)。 履歴フォームには、各リビジョンのリビジョン番号、日付、時刻、作成者、およびメッセージが表示されます。

リビジョンを選択すると、関連する開発者ポータルのストーリー、変更されたドキュメント、モデラーのバージョン、ディスク上の変更などの詳細が表示されます。 アイコンは、プロジェクトで起こった変更の種類をまとめたものです。

![](attachments/modeler-core/2018-02-21_14-06-46.png)

## 5 変更を元に戻す

まだ反映されていない変更は元に戻すことができます。 たとえば、フォームに多くの変更を行っていると、結果に満足していないことを言います。 元に戻すことができます。つまり、変更を開始する前のフォームの状態です。

ドキュメント、フォルダ、モジュールの削除も元に戻すことができます。 これにより、彼らはプロジェクトに戻ります。 *コミットした*の最新バージョンを取り戻すことに注意してください。 たとえば、コミットする場合は、マイクロフローにいくつかの変更を加えてから、マイクロフローを削除します。 削除を元に戻すと、変更を加えずにマイクロフローを作成できます。

変更を元に戻すには、 *変更* ドック、または元に戻したいドキュメントの右クリックメニューから操作します。

![元に戻す2つの方法](attachments/modeler-core/revertx2.png)

## 6 競合への対処{#conflicts}

アプリを更新し、変更を自動的にマージできない場合は、競合があることを示すメッセージが表示されます。 二つの変更を組み合わせることができない場合、衝突が発生します。

![競合に関する警告](attachments/modeler-core/contains-conflicts.png)

競合の種類は 2 つあります:

* ドキュメントの競合
* プロジェクトの競合

### 6.1 ドキュメントの競合の解決

同じ *ドキュメント* 内の2つの変更が互いに本当に近い場合、ドキュメントの競合を引き起こす可能性があります。 例えば、二人ともページ上の同じ要素のプロパティを変更します。 ドキュメントは、 *変更* ドックで競合としてマークされます。 再度コミットする前に競合を解決する必要があります。

ドキュメントをダブルクリックして、どの要素が競合しているかを確認します。 また、あなたが行ったすべての変更、および他の人によって行われたすべての変更を見ることができます。

![詳細なドキュメントの競合](attachments/modeler-core/document-changes.png)

For each *document* you can decide whether to accept the conflicted elements which are **mine** and discard the changes to those by the other person, or to accept the conflicted elements which are **theirs**, if their changes are more relevant.

この決定はドキュメント内のすべての競合に適用されます。いくつかの競合する変更に対して、自分のバージョンを選択することはできませんが、他の変更に対しても適用されます。 競合しない変更は通常どおりマージされます。

Ensure you are viewing changes for the whole project in the *Changes* dock, select the document which is conflicted, and use the required option from the **Tasks** dropdown.

![変更ドックを使用して競合を解決する](attachments/modeler-core/resolve-document-conflict.png)

たとえば、フォーム内のデータビューを削除し、そのデータビュー内で別の人が何かを変更した場合などです。 「マイニングを使用」をクリックして、他の変更を破棄することを選択できます。

競合を解決すると、競合は解消されますが、文書は可能性があります。 もちろんコミットに変更があれば変更されるとマークされています

## 6.2 プロジェクトの競合の解決

プロジェクトのコンフリクトは、プロジェクトのレベルでのコンフリクトです。 プロジェクトの競合には2つの原因があります:

1.  ある人がドキュメントを削除し、もう一方はそのドキュメント内で変更を行います。
2.  両方の人は、ドキュメントを移動しますが、プロジェクトツリー内の別の場所に移動します。

関係するドキュメントは競合としてマークされており、理由は *変更* ドックの詳細欄に表示されます。

![プロジェクトの競合の例](attachments/modeler-core/project-conflicts.png)

{{% alert type="info" %}}
フォルダ全体（またはモジュール）が *削除されていて、別の人がそのフォルダ内のドキュメントを変更した場合* フォルダ/モジュールが復元され、競合としてマークされます。 この方法では、そのフォルダを削除する意図があったことを知っているが、変更されたドキュメントのコンテキストを表示するために復元されています。
{{% /alert %}}

プロジェクトの競合を解決するには、 **Tasks > Use mine** を選択するか、ドキュメントやフォルダを削除します。

## 7 ブランチの使用

リポジトリには、いくつかの開発行を含めることができます。 各開発ラインは、他の開発ラインから独立した開発を提供します。 単純なケースでは、メインライン(subversionでは「trunk」と呼ばれる)と呼ばれる開発ラインが1つだけあります。 すべての開発はその一行の中で行われます。

![](attachments/524294/688156.png)

複数の開発ラインを持つことは、しばしば便利です。 たとえば、現在デプロイされているバージョンのプロジェクトのバグを修正するための1つの開発ラインと、新しい機能を開発する別の行です。 デプロイされたバージョンでバグが見つかった場合は、新しい機能が開発された開発ラインの状態に関係なく、対応する開発ラインでバグを修正できます。 ブランチについての詳細は [バージョン コントロール](version-control) を参照してください。

### 7.1 ブランチをいつ利用するか

#### 7.1.1 デプロイ済みアプリケーションにパッチを適用する

デプロイされたアプリケーションにいくつかの機能を追加したい場合、またはバグを修正したい場合。 他の開発を邪魔することなくできるのです

1. デプロイされたアプリケーションのバージョンを決定します。 この情報は開発者ポータルにあります。 もしくは、デプロイパッケージ(mda)アーカイブの **モデル** サブフォルダにあるmetadata.jsonファイルのバージョンを見つけることもできます。 例えば、 `"ModelVersion": "1.0.0.16"`
2. Choose **Project > More Versioning > Manage Branch Lines...** and create a branch based on the tag with the that version number as its name.

    ![](attachments/modeler-core/create-from-tag.png)

3. 機能を追加するか、新しく作成されたブランチのバグを修正してください。
4. 物事が意図したように動作することをテストします。
5. より高いバージョン番号を持つ新しいデプロイメント・アーカイブを作成します(パッチまたはマイナーバージョンを増やす)。

{{% alert type="info" %}}
必要に応じて、固定メンテナンスブランチをメインラインにすばやく統合することをお勧めします。 マージが複雑すぎる場合は、メインラインが大きすぎるため自動的に行うことができません。 変更はまだあなたの心の中で新鮮になるので、あなたは、メインラインに手で修正を適用する方法を知るでしょう。

もちろん、すべてのメンテナンス修正をメインラインに統合する必要はありません。 時には、メインラインで完全に再設計または削除されたものの修正です。 この場合、マージは不要です。
{{% /alert %}}

#### 7.1.2 独立した新機能の開発

ブランチを作るもう一つの理由は、他の開発に干渉せずに大きな新機能を開発することです。 これにより、半実装された機能を、おそらくエラーであってもコミットする自由が与えられます。 他の人がメインラインでコミットしたり更新したりできます 分岐線を使用せずに あなたのプロジェクトがエラーフリーでシステムの他の部分を壊さないことを常に確認する必要があります

まず、 **プロジェクト > その他のバージョン > ブランチの管理...** を選択し、メインラインのリビジョンからブランチを作成します。

![](attachments/modeler-core/2018-02-28_13-50-39.png)

機能が完了するまでブランチで作業し、完了した作業をコミットします。

ブランチ全体をメインラインにマージして機能を統合したい場合。 次の操作を行います:

1. メインラインを開きます。
2. 選択 **プロジェクト > その他のバージョン > Merge changes here**.
3. **統合機能ブランチ** を選択します。

    ![](attachments/modeler-core/2018-02-28_14-05-23.png)

4. ブランチを選択し、 **Merge** をクリックします。
5. 競合やエラーを解決します。
6. 新しい機能をメインラインにコミットします。

必要に応じて、ブランチをマージした後に削除できます。

### 7.2 Desktop Modelerでのブランチの操作

#### 7.2.1 ブランチ

本線以外の開発線を分岐線と呼ぶ。 私たちのアドバイスは、 *メイン ライン* で新機能を開発し、デプロイされたバージョンのバグを修正するために *分岐線* を使用することです。 これはモデラーが容易にするシナリオですが、より複雑なプロジェクトに対しても他のシナリオがサポートされています。

You can create branch lines from the Branch Line Manager which you can find at **Project > More Versioning > Manage Branch Lines...**.

![](attachments/modeler-core/2018-02-21_14-16-20.png)

#### 7.2.2 マージ

複数の開発ラインがある場合は、ある開発ラインから別の開発ラインに変更を移植したい場合があります。 たとえば、本番バージョンのブランチラインで行った修正は、新しい2にも適用されます。 バージョンはメインラインで開発中です もちろん、これを手作業で行うこともできますが、Modelerはある開発ラインから別の開発ラインへの変更をマージするのにも役立ちます。

結合は、作業コピーを開いている間は常に行われます。 マージにより、作業コピーに追加のローカル変更が生じます。 追加の変更を作業コピーにマージする前に、最初にローカル変更をコミットすることをお勧めします。 そうでなければ、 コミットされていないローカル変更とマージによって引き起こされる変更が結合されます。マージに不満がある場合は、それらを解くことは非常に困難です。 モデラーは、変更を反映していない場合に警告します。

**プロジェクト > その他のバージョン > 変更をマージする ここ** を選択してください。

適切な *マージの種類*を選択します。たとえば、 **ポートフィックス**。

![](attachments/modeler-core/2018-02-21_14-19-47.png)

1 つの開発ラインから別の開発ラインに、1 つのリビジョン、または全体のリビジョンのいずれかをマージできます。 分岐線がメインラインに完全に統合したい大きな新機能を表す場合。 を選択すると、すべてのリビジョンをマージできます。

#### 7.2.3 Reverse Merging

変更をリバートすると、まだ反映されていない変更に対して機能します。 コミットされた変更は、決して削除することはできません。 ただし、「逆に」変更を適用してコミットすることができます。 この機能はモデラーでは「リバースマージ」と呼ばれます。

**プロジェクト > その他のバージョンを選択 > 逆マージ変更...**

![](attachments/modeler-core/revert-committed-changes.png)

逆マージ後、プロジェクトは変更が発生したことがないように見えます。 フォームの追加を逆にすると、フォームはローカルに削除されます。 通常のマージを行っているときと同じように、競合が発生する可能性があります。 例では、後で追加されたフォームをコミットすると、逆マージは競合になります。 問題を解決した後、結果をリポジトリにコミットできます。

## クラウドにデプロイされたプロジェクトの8バージョン

### 8.1 ローカルにデプロイする

開発中は、メニューアイテムを使用してローカルマシンでアプリをデプロイして実行することができます **実行 > ローカルで実行**. これにより、現在ローカルマシンに保存されているアプリをテストすることができます。

### 8.2 作業コピーをデプロイする

クラウドにデプロイする場合、ローカルマシンに保存されているアプリのバージョンを選択できます。 *作業コピー* し、それをデフォルト環境にデプロイします。 Mendix Cloud、または他のパートナークラウド(SAP BTPなど)を使用している場合。 メニュー アイテムを選択します。 **実行 > 実行** ローカルマシンに保存されているアプリのバージョンをコミットし、デフォルト環境にデプロイします。

### 8.3 特定の開発ラインと改訂の選択

また、特定の開発ラインとリビジョンを選択してデフォルト環境にデプロイしたり、パッケージを作成したりすることもできます。

この場合、モデラーは選択したリビジョンの新しいチェックアウトを作成します。 つまり、どのチームメンバーでも、このバージョンのデプロイパッケージを常に再作成できます。 言い換えれば、モデラーは ** バージョン管理されたデプロイメントパッケージを作成するためにローカルファイルに依存しません。

{{% alert type="warning" %}}
コミットされた変更のバージョン管理パッケージのみを作成できます。 バージョン管理されたデプロイパッケージにデプロイするローカル変更がある場合は、最初にコミットします。
{{% /alert %}}

パッケージが作成されると、Modelerはプロジェクトのこのバージョンを表すタグも作成します。 このバージョンを後で変更したい場合は、 他の開発とは関係なく、このタグに基づいてブランチを作成できます。 タグの名前は、選択したバージョン番号です。

#### 8.3.1 Mendix ライセンスクラウドノードに特定のバージョンをデプロイする

Mendix Cloudを使用している場合は、 **Project > Deploy to Licensed Cloud Node** を選択して、特定のバージョンをdpeloy することができます。

![](attachments/modeler-core/2018-02-21_17-05-05.png)

#### 8.3.2 特定のバージョンからデプロイパッケージを作成する

別のホスティング環境を使用している場合は、メニュー項目 **プロジェクト > デプロイメントパッケージを作成...** を使用してデプロイパッケージを作成します。

![](attachments/modeler-core/2018-02-28_13-44-04.png)

## 9 デスクトップモデラーの外での作業

モデラーはファイル管理を自動的に行います。 カスタム ウィジェットを追加または削除すると、バージョン管理からも自動的に追加または削除されます。 バージョン管理に反映されないように、いくつかのファイルとディレクトリ (例えば、リリースディレクトリ) は自動的に無視されます。

私たちは常にModeler内でコミットし、更新することをお勧めします。この方法で有用なメタデータがリビジョンに追加されます。 Modelerは外部の更新やマージから回復する方法を持っていますが、それに依存しないことが最善です。

### 9.1 TortoiseSVN と Subclipse{#tortoisesvn-subclipse}

Javaアクションやリソースをプロジェクトに追加するなど、ファイルにさらに高度な変更を行う場合。 TortoiseSVN をコンピュータにインストールし、自分で操作を行う必要があります。 無料で [http://tortoisesvn.tigris.org/](http://tortoisesvn.tigris.org/) (バージョン1.7を選択) からダウンロードできます。

また、Eclipseを使用してJavaアクションを開発している場合は、Javaファイルのバージョン管理を支援するSubclipseをインストールすることをお勧めします。 Eclipse 内の Eclipse マーケットプレイス、または [http://subclipse.tigris.org/](http://subclipse.tigris.org/) から Subclipse をダウンロードできます。

### 9.2 ファイルとディレクトリの追加

Windowsエクスプローラを使用してファイルやディレクトリを追加したり、ファイルを削除したりすると、モデラーはバージョン管理からも自動的に追加または削除します。

バージョン管理下にあるディレクトリをプロジェクトにコピーする場合は、TortoiseSVN の SVN 書き出し機能を使用してください。

### 9.3 ファイルとディレクトリの削除

プロジェクトからファイルを削除すると、モデラーも自動的にチームサーバーから削除します。

ディレクトリ全体を削除する場合は、TortoiseSVN の delete コマンドを使用する必要があります。 ディレクトリを右クリックし、「TortoiseSVN > 削除」を選択すると、このコマンドを実行できます。
