---
title: "アプリの設定"
parent: "プロジェクト"
menu_order: 10
description: "アプリ全体に適用される設定。"
tags:
  - "アプリ"
  - "構成"
  - "ランタイム:"
  - "Studio Pro"
  - "言語"
  - "証明書"
  - "テーマ"
  - "ハッシュ"
  - "ハッシュアルゴリズム"
---

## 1つの紹介

**アプリ設定** ダイアログボックスで、アプリ全体に適用可能な設定を変更できます。

![](attachments/project-settings/project-settings-configuration.png)

以下のカテゴリが利用可能です。

## 2つの設定タブ

構成は設定のグループです。 任意の数の構成を定義できます。 有効な構成 (意味) アプリケーションの実行時に使用されるものは、Studio Pro のツールバーのドロップダウンメニューによって決定されます。

設定の詳細については、 [Configuration](configuration) を参照してください。

## 3 Runtime Tab

これらの設定は、アプリケーションの実行時のランタイムの動作に影響します。

### 3.1 ディスクからの静的リソース

このオプションが有効な場合、 モバイルアプリケーションの静的リソースは、アプリをナビゲートするのではなく、アプリを開くとすぐにダウンロードされます。 これは、ファイルをサーバからではなくディスクから取得できるため、ネットワーク リクエストの数を大幅に削減することができます。

リソースは各デプロイメントごとに一度デバイスにダウンロードされ、その後のアプリケーションの実行に再利用されます。 これは、テーマ、JavaScript クライアント、CSS ファイル、ページなど、さまざまなファイルに影響します。

### 3.2 ネットワーク通話の最適化 {#optimize-network-calls}

このオプションが有効になっている場合（デフォルトでは**true** ） Mendixは、クライアントからトリガーされるすべてのマイクロフローを分析し、送信に必要なオブジェクトの数を最小限に抑えます。 これはあなたのアプリを大幅にスピードアップします。

オブジェクトが失われているように見えるアプリの実行中に問題が発生した場合は、このオプションを無効にして問題を解決することができます。 これが問題を解決する場合は、プラットフォームで問題を解決できるようにバグレポートを提出してください。

### 3.3 起動後{#after-startup}

ここでは、アプリケーションの起動直後に自動的に実行されるマイクロフローを選択できます。

{{% alert type="warning" %}}
起動後のマイクロフローには、 *11分* のタイムアウトがあります。 起動後のマイクロフローが11分を超えると、アプリ全体が起動できなくなります。

起動後、アプリを初期化するように設計され、したがって *の前に* 実行されると、アプリは受信サービスの要求に応答することができます (例えば、 公開されたRESTサービス)。
{{% /alert %}}

### 3.4 シャットダウン前

ここでは、アプリケーションがシャットダウンする直前に、shutdown コマンドが与えられたときに自動的に実行されるマイクロフローを選択できます。

### 3.5 健康チェック

ここでは、アプリの健全性を評価するために必要と思われる実行中のアプリのチェックを実行するマイクロフローを選択できます。

各チェックの結果は文字列として返され、 [Developer Portal](/developerportal/deploy/environments) に表示されます。 microflow が空の文字列を返すと、アプリケーションは正常に動作します。さもなければ、文字列はアプリケーションが健全でない理由を説明します。

このマイクロフローは、アプリがまだ健康であるかどうかを確認するために10秒ごとに呼び出されます。 これは、アプリの管理ポートでm2eeを使用して実行することによって行われます。 詳しい情報については、 [Mendix Runtime](monitoring-mendix-runtime#check-health) の *ヘルスチェック* のセクションを参照してください。

{{% alert type="info" %}}

ヘルスチェックマイクロフローは、 [Mendix Cloud](/developerportal/deploy/mendix-cloud-deploy) に固有のものです。 他のクラウドでは、管理者ポートを呼び出すことも、REST APIを通じてヘルスチェックマイクロフローを公開することもできます。

{{% /alert %}}

### 3.6 週の最初の日 {#first-day-of-the-week}

日付ピッカーウィジェットの週の最初の日を設定します。

| Option                      | 説明                                      |
| --------------------------- | --------------------------------------- |
| デフォルト (ロケールに基づく)  *(デフォルト)* | 日付ピッカーウィジェットの週の最初の日は、ユーザーのロケールに基づいています。 |
| 日曜日                         | 日付ピッカーウィジェットで週の最初の日として日曜日を使用します。        |
| 月曜日                         | 日付ピッカーウィジェットでは、月曜日を週の最初の日として使用します。      |
| 火曜日                         | 日付ピッカーウィジェットでは、週の最初の日として火曜日を使用します。      |
| 水曜日                         | 日付ピッカーウィジェットで週の最初の日として水曜日を使用します。        |
| 木曜日                         | 日付ピッカーウィジェットで週の最初の日として木曜日を使用します。        |
| 金曜日                         | 日付ピッカーウィジェットで週の最初の日として金曜日を使用します。        |
| 土曜日                         | 日付ピッカーウィジェットで週の最初の日として土曜日を使用します。        |

### 3.7 デフォルトのタイムゾーン

デフォルトのタイムゾーンは、新しく作成したユーザーのタイムゾーンを決定します。 アプリケーションが1つのタイムゾーンでのみ使用されている場合 このデフォルトを設定すると、アプリケーションのユーザーが自分のタイムゾーンを設定する必要がないことを確認できます。

### 3.8 予定イベントタイムゾーン {#scheduled}

スケジュールされたイベントタイムゾーンは、スケジュールされたイベントが実行される時点で定義されます。 デフォルトは UTC であり、これは 3.0 以降のケースです。 スケジュールされたイベントを別のタイムゾーンで実行したい場合(会社オフィスのタイムゾーンやアプリのデフォルトタイムゾーンなど) ここで選んでいいのよ

これは、解析や文字列への日付の書式設定、現在の日の始まりの取得など、時間帯に関連する操作に影響します。

オンプレミスで実行する場合は、サーバが設定されているタイムゾーンを選択できます。 ただし、クラウド上のアプリケーションサーバーの所在については保証されていませんのでご注意ください。

### 3.9 ハッシュアルゴリズム{#hash-algorithm}

ハッシュアルゴリズムは、 **ハッシュ文字列** 型の属性(例えば、ユーザのパスワード)のハッシュ値を生成するために使用されます。 Mendixは2つの推奨ハッシュアルゴリズムを提供しています:

| Option           | 説明                                   |
| ---------------- | ------------------------------------ |
| BCrypt（デフォルト、推奨） | ブルートフォース検索攻撃に耐性があります。                |
| SSHA256          | シードされたセキュアハッシュアルゴリズム2、ダイジェスト長256ビット。 |

Mendixは、両方のアルゴリズムはMendix内にパスワードを保存するのに十分な安全性があると考えています。 BCryptとSSHA256の主な違いは、BCryptアルゴリズムが意図的に比較的遅いように設定されていることです。 ブルートフォース攻撃を止めるために特別に設計されたからです このため、SSHA256 アルゴリズムと若干のパフォーマンス差が生じます。

#### 3.9.1 パフォーマンス

このパフォーマンスの違いは、サインイン時に単一のユーザーにはほとんど顕著ではありません(ログイン時に入力したパスワードは、選択したアルゴリズムを使用してハッシュ化されます)。 つまり、パフォーマンスだけがBCryptよりSSHA256を選ぶ理由ではありません。 この状況は、ハッシュ操作の並行性が高い場合に変化する可能性があります。 これが起きる領域の一般的な例は、短時間のマイクロフローのように、迅速に計算される操作を公開する Web サービスです。

#### 3.9.2 パフォーマンステスト

(Webサービス)ユーザーは、Webサービス操作を実行するためにサインインします。 手術が終わるのを待って最終的に結果を返します (もしあれば)。

公開された Web サービスとして公開されていない何も返さない空のマイクロフローを想像してみてください。 1分間(SoapUIでシミュレート)でできるだけ多くの操作を実行するよう、1人のユーザーに依頼します。 まず、ハッシュアルゴリズムをBCryptに設定し、次にそれをSSHA256に設定します。 ここでの余分なオーバーヘッド(コネクションの確立、XMLメッセージの構築など)は基本的にハッシュアルゴリズムです。 操作には0ミリ秒近くかかり、結果はありません。 だから、ログイン、またはより正確には、パスワードのハッシュだけを残します。

| ハッシュアルゴリズム | 合計操作が実行されました | 1秒あたりの操作 | オーバーヘッド（ミリ秒単位） |
| ---------- | ------------ | -------- | -------------- |
| BCrypt     | 654          | 10.88    | 91.9           |
| SSHA256    | 7163         | 119.36   | 8.4            |

1回の操作で80ミリ秒というのはそんなに大きくありません まあ、それは操作自体にどのくらいかかるかによって異なります。

| 運転時間 (秒) | 1時間あたりの操作 (BCrypt) | 1時間あたりの操作 (SSHA256) | 差 %    |
| -------- | ------------------ | ------------------- | ------ |
| 0.1      | 18760              | 33210               | +77%   |
| 0.25     | 10529              | 13932               | +32%   |
| 1        | 3297               | 3570                | +8%    |
| 5        | 707                | 719                 | +1.67% |
| 15       | 239                | 240                 | +0.5%  |

操作に時間がかかる場合、差が顕著になります。 したがって、ハッシュが行われる操作で非常に多くの同時実行が期待される場合 (ログイン操作が関与している最も一般的な場所) ハッシュアルゴリズムを変更したいと思うかもしれません

{{% alert type="info" %}}
ハッシュアルゴリズムを変更するときに覚えておくべき重要なのは、(System$User password 属性のような) ハッシュ化された属性がハッシュに設定されていることです。 つまり、ハッシュタイプを有効にするためには、既存のハッシュ属性を新しいハッシュタイプを使用してリセットする必要があります。
{{% /alert %}}

### 3.10 ラウンド番号{#rounding}

**Round Numbers** の設定は、計算を行うときに数値を丸める方法を選択するために使用されます。

四捨五入方法 **0 ゼロ** と **最も近い偶数の半分から** は、ネクタイの場合にどのように丸められるかを示します (例えば、 2.5.

この表は、与えられた数字の丸め方で、入力を1桁に丸めた結果を示しています。

| Input Number | Zero  *(デフォルト)* から半分離れています | 最寄りの偶数の半分です |
| ------------ | -------------------------- | ----------- |
| 5.5          | 6                          | 6           |
| 2.5          | 3                          | 2           |
| 1.6          | 2                          | 2           |
| 1.1          | 1                          | 1           |
| 1.0          | 1                          | 1           |
| -1.0         | -1                         | -1          |
| -1.1         | -1                         | -1          |
| -1.6         | -2                         | -2          |
| -2.5         | -3                         | -2          |
| -5.5         | -6                         | -6          |

### 3.11 ユーザあたりの複数のセッション {#multiple-sessions}

このオプションが有効になっている場合、ユーザーは異なるクライアント(デスクトップブラウザやタブレットなど)を介して複数回サインインできます。 そうでなければ、ユーザーが他の場所にサインインしたときに、ユーザーのための既存のセッションがサインアウトされます。

{{% alert type="warning" %}}

本番環境では、同時利用者に基づくライセンスのみで動作します。

{{% /alert %}}

デフォルト: *はい*

## 4言語タブ {#languages-tab}

アプリケーションで異なる言語を使用する方法の詳細については、 [言語メニュー](translatable-texts) を参照してください。

### 4.1 標準言語

デフォルトの言語は、ユーザーが言語を選択していないときに使用される言語を示します。 特定のテキストが他の言語に翻訳されていない場合、デフォルトの言語は代替言語としても使用されます。

### 4.2 言語 {#languages}

これは、アプリケーションがユーザーが利用できる言語のリストです。

各言語で、すべての必須テキストに値があるかどうかを確認できます。 デフォルトの言語は常にチェックされます。 ある言語がチェックされておらず、Studio Proで特定のテキストが翻訳されていない場合は、デフォルトの言語がフォールバック言語として使用されます。 つまり、インターフェイスを部分的に新しい言語に翻訳しても、アプリケーションを実行することができます。

## 5証明書タブ

証明書は、以下の要件が満たされた場合、HTTPS 経由で Web サービスに接続するために使用されます。

* サーバーは自己署名された証明書権限を使用しています。
* クライアント証明書（秘密鍵を持つ証明書）が必要です

これらの証明書は **インポート** ボタンを使用して Studio Pro にインポートできます。 Certificate authority ファイルは通常、 *.crt* 拡張子を持ち、クライアント証明書は通常、 *.p12* または *.pfx* 拡張子を持ちます。 インポート後、証明書に関する詳細情報を取得するには、 **View detail** を使用します。

ここで追加されたクライアント証明書は、サーバーがクライアント証明書を受け入れるたびに使用されます。 複数のクライアント証明書をアップロードすると、サーバーの要件に基づいてそのいずれかが選択されます。 If you need more control over client certificates, you should not upload the certificates here, but use the [Runtime customization](custom-settings) *ClientCertificates*, *ClientCertificatePasswords*, and *ClientCertificateUsages* settings.

{{% alert type="warning" %}}

Studio Pro または Eclipse から実行する場合、証明書は *HTTPS* を介して接続するために自動的に使用されます。 サーバー上で実行する場合、証明書ファイルの場所は、構成ファイル内で指定する必要があります。

{{% /alert %}}
{{% alert type="warning" %}}

ローカルデプロイ中、証明書ファイルは **デプロイメント** フォルダ、 **モデル/証明書**の下に配置されることに注意してください。 そのため、開発中は本番証明書を使用しないでください。

{{% /alert %}}
{{% alert type="info" %}}

証明書は **証明書のインストール** ウィザードを使用して Windows 証明書ストアにインストールすることができます **詳細を表示** フォーム。 これは、クライアント証明書を必要とする *HTTPS* 接続を使用して WSDLファイルにアクセスしようとするときに便利です。

{{% /alert %}}
{{% alert type="info" %}}

When an SSLException occurs at runtime with the message `HelloRequest followed by an unexpected handshake message` or when a web service does not respond (Java 6 update 21 and above) when using the imported certificates, this is caused by either the client or server not being [RFC-5746](http://www.ietf.org/rfc/rfc5746.txt)-compatible.

クライアントとサーバーを RFC-5746 と互換性があるように更新することはできません。 この例外を避けるために、 **Server** タブの **Extra JVM パラメータ** に以下を追加する必要があります。

`-Dsun.security.ssl.allowUnsafeRenegotiation=true`

これは、RFC-5746 で修正されたエクスプロイトに対して、クライアント-サーバ間の通信が脆弱になることに注意してください。

クライアントとサーバーが RFC-5746 互換性がある場合、このJVMパラメータは削除することができます。

背景情報については、 [Transport Layer Security (TLS) Renegotiation Issue Readme](http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html) を参照してください。

{{% /alert %}}

## 6 Theme Tab

### 6.1 UI リソースパッケージ

Mendix アプリケーションのルックアンドフィールは、 [UI リソース パッケージ](ui-resources-package) によって管理されます。 このパッケージは、ページテンプレートとビルディングブロックに一致するすべての必要なテーマ情報をアプリに提供します。 UI リソースパッケージとして指定されているモジュールは、 **UI リソースパッケージ** 設定によって管理されます。 通常、これは新しい UI リソースパッケージがインポートされると自動的に更新されます。 ただし、この設定では、希望のモジュールも手動で設定できます。

### 6.2 テーマの ZIP ファイル

{{% alert type="warning" %}}

[Deprecated] アプリのテーマを設定するためにZIPファイルを使用することは推奨されません。 [UI リソース パッケージ](ui-resources-package) は、テーマを共有するための好ましい方法です。

{{% /alert %}}

古いアプリは、テーマの基盤としてテーマ ZIP ファイルを使用することができます。 この状況 **テーマ ZIP ファイル** の設定を使用して、 **テーマ** フォルダにあるすべての ZIP ファイルを切り替えることができます。 この練習は非推奨であり、将来のバージョンで削除されることに注意してください。

ZIP ファイルから UI リソースパッケージへの切り替えは簡単です。

1. まず、テーマフォルダの内容を希望するZIPファイルの内容に置き換えます。

2. 次に、上記の **UIリソースパッケージ** 設定を使用してモジュールを選択します。 理想的には、このモジュールには、ページテンプレートやビルディングブロックなどの UI ドキュメントのみが含まれている必要があります。 これにより、参照エラーを心配することなく、モジュールを他のアプリにエクスポートしてインポートすることができます。

3. 最後に、 **Theme ZIP file** の設定を **None** に設定します。

### 6.3 UI リソースモジュールとしてマーク

テーマのスタイルを含むモジュールは、UI リソースモジュールとしてマークする必要があります。 これを行うには、App Explorer で **モジュール {name}** を右クリックし、 **UI リソース モジュール** としてマーク をクリックします。 これにより、モジュールに緑色のアイコンが表示され、テーマモジュールと他のモジュールの区別が容易になります。 また、スタイルがモジュールから適用される順序にも影響します。

![グリーンモジュール](attachments/project-settings/green-module.png)

### 6.4 UI リソースモジュールの注文

モジュールにスタイリング(SCSS/CSS)が含まれている場合は、コンパイルされたCSSファイルに他のファイルに対する相対的な正しい順序で追加されていることを確認してください。 たとえば、テーマモジュールが **Atlas_Core**で定義されているスタイルを上書きする場合。 テーマモジュールが ** の** *の後に* **Atlas_Core** に追加されることが重要です。

テーマ設定 (**アプリ設定** > **テーマ** ) で明示的な順序を設定できます。 UI リソースモジュールとしてマークされているすべてのモジュールのリストが含まれています。 そして、CSSファイルに追加される順序を明示的に設定できます。 リスト内の下位のモジュールが順序付けられているため、優先順位が高いことに注意してください。 たとえば、会社のテーマモジュールを使用するアプリは、以下のように順序付けできます。

![アプリのテーマ設定](attachments/project-settings/app-theme-settings.png)

## 7 ワークフロー タブ {#workflows}

### 7.1 ユーザーエンティティ

**ユーザー エンティティ** は、 [ユーザー タスク](user-task#user-assignment) の割り当てに使用されるエンティティを定義します。 XPathを使用してユーザータスクを割り当てる場合は、このエンティティの属性を使用できます。 マイクロフローを使用している場合、エンティティはマイクロフローが期待する戻り値の型を定義します。 詳細については、 [ユーザー タスク](user-task#user-assignment) の *ユーザー タスク* の</em> セクションを参照してください。

## 7.2 実行

実行時に同時に実行できるワークフローとユーザー タスク トランザクションの最大数を設定できます。 これは開発者にアプリのパフォーマンスを制御させる高度な設定です。

### 7.2.1 並列ワークフローの実行

実行時に同時に実行するワークフロートランザクションの最大数を定義します。 上限は10です。

### 7.2.2 並列タスクの実行

実行時に同時に実行するユーザータスクの最大数を指定します。 上限は10です。

## 8つのその他のタブ {#miscellaneous}

これらの設定は、このアプリの Studio Pro の動作を決定します。 このアプリを使用しているすべてのユーザーに設定が適用されます。

### 8.1 ローカルで実行するときのウィジェットのバンドル

クラウドにデプロイする場合、カスタムウィジェットがバンドルされ、クライアントとサーバーの通信が最適化されます。 ローカルにデプロイする場合、このステップはスキップされて起動時間を加速します。 場合によっては、カスタムウィジェットの故障によってエラーが難読化されることがあります。

このオプションが設定されている場合、カスタム ウィジェットもローカルにバンドルされます。 これにより、本番環境を模倣し、起動時間を要するリスクを排除します。

### 8.2 マイクロフロー内の小文字変数名を提案する

有効にすると、Studio Pro がマイクロフローで提案する名前は、大文字ではなく小文字で始まります。

### 8.3 アクティビティのデフォルトの色

この表では、アプリケーションで利用可能な各マイクロフローアクティビティタイプのデフォルトの色を選択できます。 選択した色は、アプリ内のそのタイプのすべてのマイクロフローアクティビティの背景色として使用されます。 マイクロフローエディタで個々のアクティビティのこのデフォルト値を上書きすることができます。 アクティビティタイプのデフォルトの色を変更する場合 アプリには個別の背景色が指定されたタイプのアクティビティがあります これらのアクティビティにも新しい既定の色を適用できるダイアログが表示されます。
