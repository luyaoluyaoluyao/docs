---
title: "予定されたイベント"
category: "デスクトップ モデラー"
#menu_order:
description: "スケジュールされたイベントを構成するためのオプション"
tags:
  - "予定されたイベント"
  - "実行プロパティ"
  - "タイミング"
  - "間隔"
  - "スケジュールの問題"
  - "タイムゾーン"
  - "夏時間の節約"
---


スケジュールされたイベントを使用すると、ランタイムが特定のタイミングでマイクロフローを実行できるようになります。 イベントは、例えば毎日、特定の間隔で繰り返すこともできます。

A scheduled event is added to your module as a document (right-click your module and you will find it listed under *Add other...*).

{{% alert type="warning" %}}
スケジュールされたイベントはローカルでテストできますが、アプリが無料アプリとしてデプロイされている場合は実行されません。 無料アプリの制限に関する詳細については、 [Mendix Cloud](/developerportal/deploy/mendix-cloud-deploy#free-app) の無料アプリセクションを参照してください。
{{% /alert %}}

## 共通のプロパティ

| 属性     | 説明                                                                                            |
| ------ | --------------------------------------------------------------------------------------------- |
| 名前     | スケジュールされたイベントの名前。 この名前は実行時に ScheduledEventInformation オブジェクトに格納されるため、スケジュールされたイベントの実行が認識可能です。 |
| ドキュメント | このフィールドは文書化のみを目的としています。 その値はエンドユーザーには表示されず、アプリケーションの動作に影響を与えません。                              |

## 実行プロパティ

| 属性      | 説明                                                                                                                                                     |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| マイクロフロー | スケジュールされたイベントが実行されたときに実行されるマイクロフロー。 パラメータを持たず、すべての権限で実行する必要があります ( [Microflow](microflow) を参照)。                                                        |
| 有効      | マイクロフローは、スケジュールされたイベントが有効な場合にのみ実行されます。 この設定は、モデラーまたはEclipseから実行する場合にのみ適用されます。 運用環境では、スケジュールされたイベントは、適切なツール(開発者ポータル、Windows サービスコンソールなど)を介して有効/無効になります。 |

## タイミングのプロパティ

| 属性        | 説明                                                                                                                                                                       |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 開始日時      | スケジュールされたイベントが最初に実行された日時。 開始日時がUTC時間の場合、スケジュールされたイベントは、UTC(Universal Coordinated Time)で指定された時刻で実行されます。 開始日時がサーバー時刻の場合 スケジュールされたイベントは、アプリケーションが実行されるサーバー上の指定された時間で実行されます。 |
| 繰り返し      | 繰り返しがオンの場合、スケジュールされたイベントは指定された間隔(例えば、5分ごと)で繰り返されます。                                                                                                                      |
| 間隔        | インターバルタイプとともに、この数字は、2つのイベントの間隔がどれくらい大きいかを示します。 この数値はゼロより大きくなければなりません。                                                                                                    |
| インターバルタイプ | interval 型により、間隔の単位が決まります。 インターバル番号と一緒に、2つのイベントの間隔がどれくらい大きいかを示します。 例えば、1日または10分。                                                                                         |

### 追加情報

プラットフォームは、スケジュールされたイベントを一定の間隔でスケジュールします。 つまり、起動時に、プラットフォームはスケジュールされたイベントが実行される次の繰り返し/間隔をスケジュールします。 これは間隔を取得することによって行われ、さらにプラットフォームはいくつかの計算を行います。 アプリがゆっくり起動している場合 1つの理由は、1つ以上のスケジュールされたイベントが過去に **開始日時** を持っていることです。 そのような場合、これらのスケジュールされたイベントのより最近の **開始日時** を設定するのに役立ちます。

秒、分、時間、日、および週は構成されているようにスケジュールされています。 しかし、月と年は予想どおりに実行されないかもしれません。 月は31日の間隔、1年は365日の間隔と解釈されます。

イベントを3月1日から開始する予定の場合 これは、5月2日、6月2日、7月2日、8月3日、9月3日などに実行されます。 イベントをスケジュールするときは気をつけてください。なぜなら、予定していたイベントの1日間実行される可能性があるからです。

これは、Mendix 5.3.2 リリースがどのように間隔を計算するかの実装の簡単な例です。 以降のリリースでは少し異なる動作をする可能性があります。

```java
switch(scheduledEvent.getIntervalType())
{
    case SECOND:
        timeUnit = TimeUnit.SECONDS;
        interval = scheduledEvent.getInterval();
        break;
    case MINUTE:
        timeUnit = TimeUnit.MINUTES;
        interval = scheduledEvent.getInterval();
        break;
    case HOUR:
        timeUnit = TimeUnit.HOURS;
        interval = scheduledEvent.getInterval();
        break;
    case DAY:
        timeUnit = TimeUnit.DAYS;
        interval = scheduledEvent.getInterval();
        break;
    case WEEK:
        timeUnit = TimeUnit.DAYS;
        interval = scheduledEvent.getInterval()*7;
        break;
    case MONTH:
        timeUnit = TimeUnit.DAYS;
        interval = scheduledEvent.getInterval()*31;
        break;
    case YEAR:
        timeUnit = TimeUnit.DAYS;
        interval = scheduledEvent.getInterval()*365;
        break;
}
```

{{% alert type="warning" %}}

特定の月の特定の日にスケジュールされたイベントを実行することが絶対に重要である場合は、イベントを毎日実行するようにスケジュールする必要があります。

{{% /alert %}}

マイクロフローでは、排他的なスプリットから始めて、次のような式を実行する必要があります。

```java
parseInteger( formatDateTime( [%CurrentDateTime%], 'dd') ) = 1
```

または

```java
parseInteger( formatDateTime( [%CurrentDateTime%], 'dd') ) = 15
// This will run the scheduled event on the 1th and 15th of the month
```

あるいは、 [Herbert Vujik](https://mxforum.mendix.com/questions/6934/How-are-monthly-Scheduled-Events-planned#10518) が示すように、この式を月の最後の日に実行するために使用します。

```java
formatDateTime([%CurrentDateTime%], 'dd') = formatDateTime([%EndOfCurrentMonth%], 'dd') 
```

毎月予定されているイベントに加えて、毎日のイベントをスケジュールする際にも注意が必要です。 特定の時間に毎日実行するイベントをスケジュールする場合は、日光の節約時間を認識する必要があります。

特定の時間に毎日実行するイベントを設定すると、指定された時間に開始されます。 しかし、この後は一定の間隔で実行されます(内部的にはXナノ秒ごとに実行するために計算されます)。 これは、毎日のイベントが24時間ごとに実行されることを意味します。 したがって、昼間の節約によって時間が変化した場合、あなたのイベント **は** 1時間休みになる可能性があります。

しかし、これはサーバーがホストしているロケール(タイムゾーン)によってのみ適用されます。 どんな選択肢を選択しても、あなたが日光の節約を適応する国にいる場合。 予定されているイベントのスケジュールに気づくでしょう 特定のUTC時間から開始するイベントをスケジュールする場合、UTCは昼間の節約を知らないため、プラットフォームは技術的に問題を抱えません。 ただし、ユーザーは別の時間に実行するイベントを経験します。

残念ながら、この問題に対する大きな回避策はありません。 上記のようなソリューションを作成することができます。 これは、日付フォーマット式 'dd' を使用する代わりに、同じ型の式で行うことができます。 'HH'(0-23時間)または'kk'(1-24時間)を使用してください。
