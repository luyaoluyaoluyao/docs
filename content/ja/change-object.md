---
title: "オブジェクトの変更"
parent: "object-activity"
menu_order: 20
tags:
  - "studio pro"
---

{{% alert type="warning" %}}
このアクティビティは、 **Microflow** と **Nanoflows** の両方で使用できます。
{{% /alert %}}

## 1つの紹介

変更オブジェクトのアクティビティは、オブジェクトのメンバを変更するために使用できます。 これは、コミットの有無にかかわらず、イベントの有無にかかわらず実行できます。

## 2つのプロパティ

変更されたオブジェクトのプロパティの例を以下の画像に示します。

![オブジェクトのプロパティを変更](attachments/object-activities/change-properties.png)

このアクティビティには2つのプロパティがあります。 左側のダイアログボックスと右側のプロパティ ペインに表示されています

変更オブジェクトのプロパティペインは以下のセクションで構成されています:

* [アクション](#action)
* [一般的な](#common)

## 3 アクションセクション {#action}

プロパティ ペインの **アクション** セクションには、このアクティビティに関連付けられたアクションが表示されます。

アクションの横にある省略記号 (**…**) をクリックすることで、このアクションを構成するためのダイアログボックスを開くことができます。

また、マイクロフロー内のアクティビティをダブルクリックするか、アクティビティを右クリックして **プロパティ** を選択することで、ダイアログボックスを開くこともできます。

### 3.1 オブジェクト

**オブジェクト** は変更されたオブジェクトを定義します。

### 3.2 コミット

**コミット** はオブジェクトがコミットされる方法を定義します。 コミットの詳細については、 [コミットの動作](committing-objects#how-commits-work) のセクション *コミットオブジェクト* を参照してください。

| Option        | 説明                                                            |
| ------------- | ------------------------------------------------------------- |
| イベントハンドラでははい  | オブジェクトがデータベースに保存され、 [イベントハンドラ](event-handlers) がトリガーされます。     |
| はい、イベントハンドラなし | オブジェクトはデータベースに保存されますが、 [イベントハンドラ](event-handlers) がトリガーされません。 |
| *なし（デフォルト）*   | このオブジェクトはデータベースに保存されずに変更されます                                  |

#### 3.2.1 コミットを設定するための使用例

データビューからフローがトリガーされた場合 (たとえばテキストフィールドの「変更時」など)、まだデータビューオブジェクトに加えた変更を反映したくないことがよくあります。 エンドユーザーは、format@@0またはformat@@1ボタンを押して、変更をコミットまたはロールバックできます。

ただし、 データグリッドボタンからフローがトリガーされた場合、選択範囲で操作を実行するだけで、変更を反映して損失を避けることができます。

#### 3.2.2 Nanoflow内のコミット

Nanoflowはイベントなしでのコミット変更をサポートしていません。 オンラインアプリで実行中にコミットすると、Mendix Runtimeにコミットリクエストが送信され、イベントが実行されます。 変更オブジェクトアクションがオフラインアプリで使用されている場合、変更はオフラインデータベースに反映されます。

### 3.3 クライアントで{#refresh-in-client} を更新

この設定では、データがデータベースにコミットされた後にデータソースを再実行するかどうかを定義します。

デフォルト: *いいえ*

{{% alert type="info" %}}
Mendix アプリのページを効率的にするために、多くのウィジェットはページにキャッシュされたオブジェクトの属性から値を表示します。 Attributes in widgets which use cached data are *always* reflected in the client even if they are not committed and irrespective of the value of **Refresh in client**.

If a widget is only updated when a [data source](data-sources) is loaded, then changes will only be seen if changes are committed and **Refresh in client** is set to *Yes*.

アプリをテストする際は、選択したウィジェットで希望するデータが表示されていることを確認してください。
{{% /alert %}}

#### 3.3.1 マイクロフローは、オンラインアプリでクライアントから呼び出されます

クライアント **の更新** が *いいえ*に設定されている場合、変更はクライアントに反映されません。

*はい*に設定すると、関連する [データ ソース](data-sources) の再ロードを含む、オブジェクトはクライアント全体でリフレッシュされます。

#### 3.3.2 マイクロフローはオフライン、ネイティブ、またはハイブリッドアプリで呼び出されます

オフライン、ネイティブ、またはハイブリッドアプリから呼び出されるマイクロフロー内の場合 **クライアントの** オプションは無視され、 **いいえ** に設定されているかのように機能します。

詳細については、 [オフライン-First Reference Guide](offline-first#microflows) の *Microflow* セクションを参照してください。

#### 3.3.3 アクションは Nanoflow にあります

**クライアントの更新** オプションは、 [nanoflow](nanoflows) で変更オブジェクトが使用されている場合は使用できません。 この場合、更新の動作は **コミット タイプ** オプションに依存します。 これは [visibility](common-widget-properties#visibility-properties) を含む、クライアントの変更された属性値を常に反映します。

If **Commit type** is set to *Yes*, the object is refreshed across the client as if **Refresh in client** was set to *Yes*.

### 3.4 メンバーの変更

オブジェクトに適用する変更のリストを指定できます。 メンバーに対する値は [式](expressions) で指定され、メンバーと同じ型でなければなりません。

参照セットの関連付けについては、(メンバの設定だけではなく)関連付けの追加と削除を行うこともできます。 **add**では、オブジェクトまたはオブジェクトのリストを現在関連付けられているオブジェクトに追加できます。 **remove**では、現在関連するオブジェクトからオブジェクトまたはオブジェクトのリストを削除できます。

## 4つの共通セクション{#common}

{{% snippet file="refguide/microflow-common-section-link.md" %}}
