---
title: "Clustered Mendix Runtime"
category: "Mendix Runtime"
description: "クラスタ機能を使用して、Mendixアプリケーションを設定してロードバランサの背後で実行し、フェイルオーバーおよび/または高可用性アーキテクチャを有効にできます。"
tags:
  - "ランタイム:"
  - "cluster"
  - "ロードバランサー"
  - "フェイルオーバー"
  - "studio pro"
---

{{% alert type="info" %}}
<img src="attachments/chinese-translation/china.png" style="display: inline-block; margin: 0" /> 簡体字中国語の翻訳については、 [<unk> <unk> <unk>](https://cdn.mendix.tencent-cloud.com/documentation/refguide8/refguide8/clustered-mendix-runtime.pdf) をクリックしてください。
{{% /alert %}}

## 1つの紹介

このページでは、実行中のMendix Runtimeの動作と影響をクラスタとして説明します。 クラスタ機能を使用して、Mendixアプリケーションを設定してロードバランサの背後で実行し、フェイルオーバーおよび/または高可用性アーキテクチャを有効にできます。

クラスタリングを可能にする主な特徴は、Mendix のステートレスランタイムアーキテクチャです。 これは、 dirty 状態 (永続性のないエンティティインスタンスと、まだ永続性のない変更) が、サーバー上にではなく、クライアント上に保存されることを意味します。 これにより、各クラスタノードはクライアントからのリクエストを処理できるため、Mendix Runtimeのスケーリングがはるかに簡単になります。 ステートレスなランタイムアーキテクチャにより、アプリケーション状態におけるより良い汚れた状態のメンテナンス性とより良い洞察が可能になります。

## 2 クラスタリングのサポート

クラスタリングサポートは、Cloud Foundryビルドパックの実装にネイティブに組み込まれています。 これは、Cloud Foundryを使用して単純にスケールアップできることを意味します。 ビルドパックを使用すると、システムがクラスタとして自動的に動作を開始します。

Kubernetesではクラスタリングもサポートされていますが、 *StatefulSet* を使用する必要があります。 詳細については、 [Kubernetes](/developerportal/deploy/run-mendix-on-kubernetes#scaling) 上でMendixを実行する方法 *Scaling* のセクションに詳しい情報があります。

## 3つのクラスターインフラストラクチャ

Mendix Runtime クラスタには、次のインフラストラクチャが必要です。

![](attachments/16714073/16844074.png)

つまり、Mendix クラスタでは、利用可能なランタイムクラスタノードにクライアントの負荷を分散させるためにロードバランサが必要になります。 これは、すべてのノードが同じMendixデータベースに接続する必要があることを意味します。 そしてファイルをS3に保存する必要があります(詳細については、 [ファイルストレージ](#file-storage) のセクションを参照してください)。 クラスタ内のノードの数は、アプリケーション、高可用性要件、およびその使用量によって異なります。

## 4 Cluster Leader & Cluster Slaves

Mendix Runtimeにはクラスターリーダーの概念があります。 これは、クラスター管理アクティビティを実行するMendix Runtimeクラスター内の単一ノードです。 これらは以下のような活動です:

* **セッションのクリーンアップ処理** - 各ノードはセッションの期限が切れます (意味: 設定された時間帯には使用されていません）、クラスターリーダーはデータベースで永続的なセッションを削除します
    * 例外的なケース(例えば、ノードがクラッシュするなど)では、いくつかのセッションがデータベースから削除されない場合があります。 その場合クラスターリーダーは
* **クラスターノードの有効期限の処理** - クラスターノードが期限切れになった後に削除する (意味、設定されたタイムスタンにハートビートを与えない)
* **バックグラウンドジョブの有効期限の処理** - 情報の有効期限が切れた後にバックグラウンドジョブに関するデータを削除します (意味、特定の時間帯より古い)
* **ブロックを解除したユーザー**
* **スケジュールされたイベントの実行** - スケジュールされたイベントはクラスターリーダーでのみ実行されます
* **新しいデプロイ後にデータベースの同期を実行します**
* **新しいデプロイ後に永続的なセッションをクリアする** - 最新のモデルのバージョンと同期するように、既存のすべてのセッションを無効にする

これらのアクティビティはクラスタリーダーによってのみ実行されます。 クラスターリーダーが実行されていない場合は、クラスターは引き続き機能します。 ただし、上記の活動は行いません。

Cloud Foundry Buildpackは、どのクラスターノードがクラスターリーダーになり、どのクラスタースレーブになるかを決定します。

## 5 Cluster Startup

クラスター内の個々のノードは、アプリの稼働時間に影響を与えずに起動および停止することができます。 ただし、新しいバージョンのアプリケーションをデプロイすると、クラスター全体が再起動され、クラスターリーダーはデータベースの同期が必要かどうかを決定します。 これは、これが完了している間にアプリがデプロイされるといくつかのダウンタイムが発生することを意味します。

データベース同期が必要な場合、クラスタスレーブはクラスタリーダーがデータベース同期を完了するまで待機します。 データベースの同期が完了すると、すべてのクラスタノードが完全に機能するようになります。

データベース同期が不要な場合、すべてのクラスタノードは起動直後に完全に機能するようになります。

## 6ファイルストレージ {#file-storage}

アップロードされたファイルは、すべての Mendix Runtime ノードが同じファイルにアクセスするため、共有ファイルストレージ機能に保存する必要があります。 ローカルストレージ機能が共有されるか、Amazon S3ファイルストレージなどの中央ストレージ機能にファイルが保存されます。 Microsoft Azure Blob ストレージ、または IBM Bluemix Object Storage 。

これらのストレージ機能にファイルを格納するための Mendix Runtime の設定についての詳細は、 [Runtime Customization](custom-settings) を参照してください。

## 7 起動後 & 前にシャットダウンするマイクロフロー {#startup-shutdown-microflows}

Mendixで `起動後` と `Before-シャットダウン` マイクロフローを設定することができます。 Mendix クラスタでは、これらのマイクロフローがノードごとに呼び出されることを意味します。 これにより、リクエストハンドラーやその他のアクティビティを登録できます。 しかし、これらのマイクロフロー中にデータベースをメンテナンスすることは、同じクラスタの他のノードに影響を与える可能性があるため、非常に推奨されません。 クラスターの起動時やシャットダウン時にマイクロフローを実行する可能性はありません。

## 8 クラスター制限

### 8.1 マイクロフローのデバッグ

マルチノードクラスタの実行中は、マイクロフローが実行されるノードを予測することはできません。 そのため、Mendix Studio Pro からクラスタでこのようなマイクロフロー実行をデバッグすることはできません。 ただし、Mendix Runtimeの単一インスタンスを実行しているときにも、マイクロフローをデバッグできます。

### 8.2 クラスタ全体のロック (単一実行保証)

アプリによっては、特定の時点での特定のアクティビティの単一実行を保証する必要があります。 単一のノード Mendix ランタイムでは、JVM ロックを使用することで、これは保証されます。 ただし、分散シナリオでは、これらのJVMは異なるマシンで動作するため、利用可能なロックシステムはありません。 Mendixはクラスタ全体のロックをサポートしていません。 これを回避できない場合は、外部の分散ロックマネージャーに頼る必要があります。 ただし、分散システム内のロックは複雑で失敗しやすいことに留意してください(例えば、ロック飢餓やロックの有効期限など)。

{{% alert type="info" %}}
上記の理由から、マイクロフローの **並行実行** プロパティは単一のノードにのみ適用されます。
{{% /alert %}}

## 9ダーティステート（クラスタ内）

ユーザーがMendixアプリケーションにサインインし、特定のアプリケーションフローを通過し始めたとき。 まだデータベースに残っていない間にシステムは一時的にデータを保持できます データは Mendix Client メモリに保持され、ユーザーの代わりにMendix Runtime ノードに通信されます。

例えば、フライト、ホテル、レンタカーのあるMendixアプリで休暇を予約しているとします。 最初のステップでは、フライトを選択して設定します。 3番目のレンタカーと最後のステップで予約と支払いを確認します これらのステップはそれぞれ異なる画面に表示されますが、ステップ1からステップ2に移動すると、それぞれのステップが異なる画面に表示されます。 予約済みのフライトを覚えておきたいか? これは「汚い状態」と呼ばれています データはまだ確定されていませんが、異なるリクエスト間で保持される必要があります。 確実にスケールアウトし、フェイルオーバーシナリオをサポートする必要があるためです。 状態はリクエスト間の Mendix Runtime ノードの メモリに保存できません。 そのため、状態は呼び出し元(Mendixクライアント)に返され、後続のリクエストに追加されます。 全てのノードがリクエストの状態で動作するようにしました

次の画像はこの動作を示しています:

![](attachments/16714073/16844072.png)

オブジェクトを読み取り、Mendix データベースからオブジェクトを削除することは、依然として「クリーンな状態」です。 既存のオブジェクトを変更したり、新しいオブジェクトをインスタンス化したりすると、「汚れた状態」が生成されます。 Dirty 状態はリクエストごとに、Mendix クライアントから Mendix Runtime に送信する必要があります。 オブジェクトをコミットまたはロールバックすると、それらが汚れた状態から削除されます。 インスタンス化または変更されたオブジェクトが削除された場合も同じことが起こります。 非永続エンティティは常に汚れた状態の一部です。

Mendix クライアント(同期呼び出しと非同期呼び出しの両方)から発生するリクエストに対する不適切な状態のみがリクエスト間で保持できます。 スケジュールされたイベント、Webサービス、バックグラウンド実行などの他のすべてのリクエストでは、ステートは現在のリクエストのみ有効になります。 その後、汚れた状態は、永続化または破棄する必要があります。 Mendix Client 要求がダーティな状態を保持することを許可するだけの理由は、現在、これが実際のユーザー入力で動作する唯一のチャネルであるためです。 ユーザー入力には、リクエスト間のデータに対して、より多くのインタラクションと柔軟性が必要です。 これらのリクエストが不適切な状態を保持することを許可するだけです Mendix Runtimeと外部ソースの負荷が最小限に抑えられ、パフォーマンスが最適化されます。

{{% alert type="info" %}}
Mendix Client が再起動されると、すべての状態は破棄され、Mendix Client メモリにのみ保存されます。 ブラウザータブを再読み込みすると、Mendix Client が再起動されます (例えば、 <kbd>F5</kbd>を押すと、モバイルハイブリッドアプリを再起動するか、明示的にサインアウトします。
{{% /alert %}}

汚れた状態の一部であるより多くのオブジェクト より多くのデータは、Mendix Runtime と Mendix Client 間のリクエストと応答で転送されなければなりません。 したがって、これはパフォーマンスに影響を与えます。 クラスタ環境では、同期が性能に及ぼす影響を最小限に抑えるために、汚れ状態の量を最小限に抑えることをお勧めします。

Mendix Client は、リクエストの処理中に読み取る可能性のあるデータのみを送信することで、Mendix Runtime に送信される状態の量を最適化しようとします。 For example, if you call a microflow that gets `Booking` as a parameter and retrieves `Flight` over association, then the client will pass only `Booking` and the associated `Flight`s from the dirty state along with the request, but not the `Hotel`s. この動作は最善の努力であることに注意してください。 マイクロフローが複雑すぎて分析できない場合(例えば、 Javaアクションが状態オブジェクトをパラメータとして呼び出された場合、Dirty状態全体が送信されます。 この最適化は、 [ネットワーク呼び出しの最適化](project-settings#optimize-network-calls) プロジェクト設定で無効にできます。

{{% alert type="warning" %}}
Mendixで外部Webサービスを呼び出して外部データを取得する場合に気づくことが重要です。 これらのアクションの応答はMendixエンティティに変換されます。 Mendix データベースに永続化されていない限り。 彼らは汚い状態の一部になり、アプリケーションのパフォーマンスに悪影響を及ぼします。 この影響を軽減するために、この動作は将来的に変化する可能性があります。
{{% /alert %}}

大きなリクエストとレスポンスのパフォーマンスへの影響を軽減する アプリ開発者は、大きなリクエストと応答を引き起こす以下のシナリオに注意する必要があります。

* 多数の非持続可能エンティティを作成し、ページに表示するマイクロフロー
* 外部データを取得し、非持続可能エンティティに変換するためにWebサービスを呼び出すマイクロフロー
* 複数のマイクロフローデータソースデータビューを持つページは、それぞれがマイクロフローを処理するためにMendix Runtimeに転送される状態を引き起こします

{{% alert type="warning" %}}
上記のシナリオがアプリに適用されると、汚れた状態が大きすぎないようにする。 必要がなくなった時は明示的に削除することをお勧めします これにより、Mendix Runtime ノードのメモリが解放され、リクエストを処理し、パフォーマンスが向上します。
{{% /alert %}}

## `System.Session` または `System.User` とエンティティを関連付ける10

`$currentSession` *セッション* オブジェクトはマイクロフローで利用可能で、現在のセッションへの参照を容易に得ることができます。 When an object needs to be stored, its association can be set to `$currentSession`, and when the object needs to be retrieved again, `$currentSession` can be used as a starting point from which the desired object can be retrieved by association. 関連するオブジェクトは、所望のニーズを満たすように設計することができます。 このパターンは、 `System.User` に関連付けられたエンティティにも適用されます。 その場合、 `$currentUser` *ユーザー* オブジェクトを使用できます。

![](attachments/core/2018-03-01_17-49-15.png)

For example, you can add `Key` and `Value` members to a `Data` entity associated with `System.Session` (and have constants for key values).

![](attachments/core/2018-03-01_17-42-38.png)

`値` は、 `データ` インスタンスのリストの `キー` の値を検索することで簡単に取得できます。

![](attachments/core/2018-03-01_17-56-37.png)

{{% alert type="warning" %}}
データが現在のユーザーまたは現在のセッションに関連付けられている場合、自動的にゴミ収集されることはできません。 そのため、このデータはすべてのリクエストと共にサーバに送信され、リクエストの応答によって返されます。 したがって、この一時的なデータを保持する他のソリューションがない場合、エンティティインスタンスを現在のユーザーと現在のセッションと関連付ける必要があります。
{{% /alert %}}

## 11 セッションは常に永続的です

シームレスなクラスタリングをサポートするには、常にデータベースでセッションが継続されます。 以前のバージョンでは、これは既知のパフォーマンスボトルネックでした。 Mendixには、このパフォーマンスヒットを軽減するための最適化が含まれるようになりました。

この目的のためにデータベースへのラウンドトリップは、永続的なセッションに30秒の最大キャッシュ時間を与えることによって削減されます(デフォルト)。 つまり、セッションにサインアウトした後でも、クラスターの他のノードではセッションに30秒間アクセスできる可能性があります。 しかし、そのノードがログアウトが起こる直前にセッションで以前のリクエストを処理した場合のみ。 このタイムアウトは設定できます。 これを下げると、設定された時間ウィンドウ内でセッションがアクセス可能である可能性が小さいため、クラスタはより安全になります。 しかし、これはまた、パフォーマンスに影響を与えるデータベースへのより頻繁な往復を必要とします。 タイムアウトを増やすと逆の効果があります。 これは `SessionValidationTimeout` (ミリ秒単位の値) を設定することで設定できます。

永続的なセッションには、各リクエストに最後にアクティブな日付も保存されます。 パフォーマンスのこの特定の側面を向上させるために。 セッションの最終日付属性は、リクエストごとにすぐにデータベースにコミットされなくなりました。 代わりに、この情報は、Mendix データベースに保存される設定可能な間隔でアクションを実行するためにキューに入れられます。 このアクションは、セッションが別のノードによってログアウトされていないかどうか、および最後のアクティブな日付がデータベース内のものよりも最近であるかどうかを確認します。 `ClusterManagerActionInterval` (ミリ秒単位) を設定することで間隔を設定できます。

{{% alert type="warning" %}}
`SessionTimeout` と `ClusterManagerActionInterval` の既定値を上書きすると、「ライブを保持」の動作に影響を与え、予期しないセッションログアウトになります。 ベストプラクティスは、 `ClusterManagerActionInterval` を `SessionTimeout` の半分に設定し、各ノードがセッションタイムアウト間隔の間に少なくとも一度クリーンアップアクションを実行する機会を得ることです。
{{% /alert %}}

