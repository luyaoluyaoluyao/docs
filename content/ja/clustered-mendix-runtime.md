---
title: "Clustered Mendix Runtime"
category: "Mendix Runtime"
description: "このページでは、Mendix Runtime をクラスタとして実行する際の影響と動作について説明します。 クラスタ機能を使用すると、Mendixアプリケーションを設定してロードバランサの背後で実行し、フェイルオーバーおよび/または高可用性アーキテクチャを有効にできます。"
tags:
  - "ランタイム:"
  - "cluster"
  - "ロードバランサー"
  - "フェイルオーバー"
---

## 1つの紹介

このページでは、Mendix Runtime をクラスタとして実行する際の影響と動作について説明します。 クラスタ機能を使用すると、Mendixアプリケーションを設定してロードバランサの背後で実行し、フェイルオーバーおよび/または高可用性アーキテクチャを有効にできます。

Mendix 7 には、クラスタリングのためのまったく新しいビルドアプローチが含まれています。 これを可能にする主な特徴はステートレスなランタイムアーキテクチャです。 これは、 dirty 状態 (永続性のないエンティティインスタンスであり、まだ変更が継続されていない) が、サーバー上ではなくクライアント上に保存されていることを意味します。 これにより、各クラスタノードがクライアントからのリクエストを処理できるため、Mendix Runtimeのスケーリングがはるかに簡単になります。 ステートレスなランタイムアーキテクチャにより、アプリケーション状態におけるより良い汚れた状態のメンテナンス性とより良い洞察が可能になります。

## 2 クラスタリングのサポート

クラスタリングサポートは、Cloud Foundryビルドパックの実装にネイティブに組み込まれています。 これは、Cloud Foundryを使用して単純にスケールアップできることを意味します。 ビルドパックを使用すると、システムがクラスタとして自動的に動作を開始します。

Kubernetesではクラスタリングもサポートされていますが、 *StatefulSet* を使用する必要があります。 これについては、 *Scaling* のセクション [Kubernetes](/developerportal/deploy/run-mendix-on-kubernetes#scaling) で Mendix を実行する方法を参照してください。

## 3つのクラスターインフラストラクチャ

Mendix Runtime Clusterは以下のインフラストラクチャが必要です。

![](attachments/16714073/16844074.png)

つまり、Mendix Clusterは、利用可能なランタイムクラスターノードにクライアントの負荷を分散させるためにロードバランサーを必要とします。 また、すべてのノードが同じMendixデータベースに接続する必要があり、ファイルをS3に保存する必要があることを意味します (ファイルストレージトピックを参照してください)。 クラスタ内のノードの数は、アプリケーション、高可用性要件、およびその使用量によって異なります。

## クラスターリーダー、クラスタースレーブ

Mendix Runtimeにはクラスターリーダーの概念があります。 これは、クラスター管理アクティビティを実行するMendix Runtimeクラスター内の単一ノードです。 これらのアクティビティは以下のとおりです:

* `セッション有効期限処理` - セッションが期限切れになった後にセッションを削除する (設定されたタイムスタンには使用されていません)
    * For version [7.23.4](/releasenotes/studio-pro/7.23#7234) and above – each node expires its sessions (after not having been used for a configured timespan) and the cluster leader removes the sessions persisted in the database; in exceptional cases (for example, a node crash), some sessions may not be removed from the database, in which case the cluster leader performs a clean-up of the sessions
    * バージョン [7.23.3](/releasenotes/studio-pro/7.23#7233) 以下の場合、クラスターリーダーは期限切れ後にセッションを削除します (設定されたタイムスタンに使用されていない)
* `クラスターノードの有効期限の処理` - クラスターノードが期限切れになった後に削除する (設定されたタイムスタンにハートビートを与えない)
* `バックグラウンドジョブの有効期限の処理` - 情報が期限切れになった後、バックグラウンドジョブに関するデータを削除します(特定の時間帯以外)
* `ブロックを解除したユーザー`
* `スケジュールされたイベントの実行` - スケジュールされたイベントはクラスターリーダー上でのみ実行されます
* `新しいデプロイ後にデータベースの同期を実行します`
* `新しいデプロイ後に永続的なセッションをクリアする` - 最新のモデルバージョンと同期するように、既存のすべてのセッションを無効にする

これらのアクティビティはクラスタリーダーによってのみ実行されます。 Cluster Leaderが実行されていない場合でも、クラスタは機能しますが、上記のアクティビティは実行されません。

どのクラスタノードがクラスタリーダーになり、どのクラスタスレーブがクラスタスレーブになるかはCloud Foundry Buildpackによって決定されます。

## 5 Cluster Startup

クラスターリーダーは、データベース同期を実行する責任があります。 したがって、新しいアプリケーションのデプロイが検出された場合、クラスターのリーダーがデータベースの同期を完了するまで、すべてのクラスタースレーブが待機します。 データベースの同期が完了すると、クラスタスレーブとクラスタリーダーは自動的に完全に機能します。

データベース同期が不要な場合、すべてのクラスタノードは起動直後に完全に機能するようになります。

## 6ファイルストレージ

アップロードされたファイルは、すべての Mendix Runtime ノードが同じファイルにアクセスするため、共有ファイルストレージ機能に保存する必要があります。 ローカルストレージ機能が共有されるか、Amazon S3ファイルストレージなどの中央ストレージ機能にファイルが保存されます。 Microsoft Azure Blob ストレージ または、IBM Bluemix Object Storage (これらのストレージ施設にファイルを格納するMendix Runtimeを構成する詳細については、 [カスタム 設定](custom-settings) を参照してください)。

## 7 起動後とシャットダウン前のマイクロフロー {#startup-shutdown-microflows}

Mendixで `起動後` と `Before-シャットダウン` マイクロフローを設定することができます。 Mendix Clusterでは、これらのマイクロフローがノードごとに呼び出されることを意味します。 これにより、リクエストハンドラーやその他のアクティビティを登録できます。 しかし、これらのマイクロフロー中にデータベースのメンテナンスを行うことは、同じクラスタの他のノードに影響を与える可能性があるため、非常に推奨されません。 クラスターの起動時やシャットダウン時にマイクロフローを実行する可能性はありません。

## 8 クラスター制限

### 8.1 マイクロフローのデバッグ

マルチノードクラスタの実行中は、マイクロフローがどのノードで実行されるかは予測できません。 したがって、Mendix Modelerからクラスタでこのようなマイクロフローの実行をデバッグすることはできません。 ただし、Mendix Runtimeの単一インスタンスを実行しているときにも、マイクロフローをデバッグできます。

### 8.2 クラスタ全体のロック (単一実行保証)

アプリによっては、特定の時点での特定のアクティビティの単一実行を保証する必要があります。 単一のノード Mendix Runtime では、JVM ロックを使用することで、これは保証されます。 ただし、分散シナリオでは、これらのJVMは異なるマシンで動作するため、利用可能なロックシステムはありません。 Mendixはクラスタ全体のロックもサポートしていません。 これを回避できない場合は、外部の分散ロックマネージャーに頼る必要があります。 ただし、分散システム内のロックは複雑で、障害が発生しやすいこと(ロック飢餓、ロックの有効期限など)を覚えておいてください。

{{% alert type="info" %}}
上記の理由から、マイクロフローの **並行実行** プロパティは単一のノードにのみ適用されます。
{{% /alert %}}

## 9ダーティステート（クラスタ内）

ユーザーがMendixアプリケーションにサインインし、特定のアプリケーションフローを通過し始めたとき。 まだデータベースに残っていない間にシステムは一時的にデータを保持できます データは Mendix Client メモリに保持され、ユーザーの代わりにMendix Runtime ノードに通信されます。

例えば、フライト、ホテル、レンタカーで構成されるMendixアプリを通じて休暇を予約しているとします。 最初のステップでは、フライトを選択して設定します。 3番目のレンタカーで予約と支払いを確認します これらのステップはそれぞれ異なる画面に表示されます。 でもステップ1からステップ2まで行ったら 予約済みのフライトを覚えておきたい これを「汚い状態」と呼ぶ。 データはまだ確定されていませんが、異なるリクエスト間で保持される必要があります。 確実にスケールアウトし、フェイルオーバーシナリオをサポートすることが必要です。 状態はリクエスト間の Mendix Runtime ノードの メモリに保存できません。 そのため、状態は呼び出し元(Mendixクライアント)に返され、後続のリクエストに追加されます。 全てのノードがリクエストの状態で動作するようにしました

次の画像は、その動作を説明しています:

![](attachments/16714073/16844072.png)

オブジェクトの読み込みとMendix Databaseからの(変更されていない)オブジェクトの削除は依然として「状態を削除」です。 既存のオブジェクトを変更したり、新しいオブジェクトをインスタンス化したりすると、「Dirty State」が作成されます。 'Dirty State'はリクエストごとにMendixクライアントからMendixランタイムに送信する必要があります。 オブジェクトをコミットまたはロールバックすると、それらが「Dirty State」から削除されます。 インスタンス化または変更されたオブジェクトが削除された場合も同じことが起こります。 非持続可能エンティティは常に「Dirty State」の一部です。

Mendix クライアント(同期呼び出しと非同期呼び出しの両方)からのリクエストに対する「Dirty State」のみがリクエスト間で保持できます。 スケジュールされたイベント、ウェブサービス、バックグラウンド実行など、その他のすべてのリクエストでは、state は現在のリクエストに対してのみ存続します。 その後、「Dirty State」は永続化されるか、破棄されます。 Mendix Client リクエストのみが 'Dirty State' を保持できるようにする理由は、現在、これが実際のユーザー入力で動作する唯一のチャンネルであるためです。 ユーザ入力には、リクエスト間のデータのやり取りと柔軟性が必要になります。 これらのリクエストが「Dirty State」を保持できるようにするだけで、Mendix Runtimeと外部ソースの負荷が最小限に抑えられ、パフォーマンスが最適化されます。

Mendix Client が再起動されるたびに、Mendix Client メモリにのみ保持されるため、すべての状態が破棄されることに注意してください。 ブラウザータブを再読み込みすると、Mendix Client が再起動されます (例えば、 <kbd>F5</kbd>を押すと、モバイルハイブリッドアプリを再起動するか、明示的にログアウトします。

「Dirty State」の一部であるより多くのオブジェクト。 より多くのデータは、Mendix Runtime と Mendix Client 間のリクエストと応答で転送されなければなりません。 そのため、パフォーマンスに影響を与えます。 クラスタ環境では、同期のパフォーマンスへの影響を最小限に抑えるために、'Dirty State'の量を最小限に抑えることをお勧めします。

Mendix Client は、リクエストの処理中に読み取る可能性のあるデータのみを送信することで、Mendix Runtime に送信される状態の量を最適化しようとします。 For example, if you call a microflow that gets `Booking` as a parameter and retrieves `Flight` over association, then the client will pass only `Booking` and the associated `Flight`s from the dirty state along with the request, but not the `Hotel`s. この動作は最善の努力であることに注意してください。 マイクロフローが複雑すぎて分析できない場合(例えば、 Javaアクションが状態オブジェクトをパラメータとして呼び出された場合、Dirty状態全体が送信されます。 この最適化は、 [`ネットワーク呼び出しの最適化` プロジェクト設定](project-settings#optimize-network-calls) によって無効にできます。

{{% alert type="warning" %}}

Mendixで外部Webサービスを呼び出して外部データを取得する場合に気づくことが重要です。 これらのアクションの応答はMendixエンティティに変換されます。 Mendix Databaseで永続化されていない限り。 彼らは `Dirty State` の一部となり、アプリケーションのパフォーマンスに悪影響を与えます。 この影響を軽減するために、この動作は将来的に変化する可能性があります。

{{% /alert %}}

大きなリクエストとレスポンスのパフォーマンスへの影響を軽減するために、アプリ開発者はそれらの原因となる状況を認識する必要があります。 これらの原因となるシナリオがいくつかあります:

| シナリオ                                                                                |
| ----------------------------------------------------------------------------------- |
| 多数の非持続可能エンティティを作成し、ページに表示するマイクロフロー。                                                 |
| Webサービス/アプリサービスを呼び出して外部データを取得し、持続不可能なエンティティに変換するマイクロフロー。                            |
| ページには複数のマイクロフローデータソースデータビューがあり、それぞれが、マイクロフローを処理するためにMendix Runtimeに転送された状態を引き起こします。 |

{{% alert type="warning" %}}

上記のシナリオがアプリに適用されると、汚れた状態が大きすぎないようにする。 必要がなくなった時は明示的に削除することをお勧めします これにより、Mendix Runtime ノードのメモリが解放され、リクエストを処理し、パフォーマンスが向上します。

{{% /alert %}}

## `System.Session` または `System.User` とエンティティを関連付ける10

`$currentSession` 変数はマイクロフローで利用可能で、現在のセッションへの参照を容易に得ることができます。 When an object needs to be stored, its association can be set to `$currentSession`, and when the object needs to be retrieved again `$currentSession` can be used as a starting point from which the desired object can be retrieved by association. 関連するオブジェクトは、所望のニーズを満たすように設計することができます。 このパターンは、 `System.User` に関連付けられたエンティティにも適用されます。 その場合は、 `$currentUser` 変数を使用できます。

![](attachments/modeler-core/2018-03-01_17-49-15.png)

For example, you can add `Key` and `Value` members to a `Data` entity associated with `System.Session` (and have constants for key values).

![](attachments/modeler-core/2018-03-01_17-42-38.png)

`値` は、 `データ` インスタンスのリストの `キー` の値を検索することで簡単に取得できます。

![](attachments/modeler-core/2018-03-01_17-56-37.png)

{{% alert type="warning" %}}

データが現在のユーザーまたは現在のセッションに関連付けられている場合、自動的にガベージコレクションすることはできません。 そのため、このデータはすべてのリクエストと共にサーバに送信され、リクエストの応答によって返されます。 したがって、この一時的なデータを保持する他のソリューションがない場合、エンティティインスタンスを現在のユーザーと現在のセッションと関連付ける必要があります。

{{% /alert %}}

## 11 セッションは常に永続的です

シームレスなクラスタリングをサポートするために、常にデータベースでセッションが継続されます。 以前のバージョンでは、これは既知のパフォーマンスのボトルネックでした。 Mendix 7には、このパフォーマンスヒットを移行するためのいくつかの最適化が含まれています。 この目的のためにデータベースへのラウンドトリップは、永続的なセッションに30秒の最大キャッシュ時間を与えることによって削減されます(デフォルト)。 つまり、セッションからログアウトした後でも、クラスターの他のノードで30秒間セッションにアクセスできる可能性があります。 しかし、そのノードがログアウトが起こる直前にセッションで以前のリクエストを処理した場合のみ。 このタイムアウトは設定できます。 それを下げると、設定された時間内にセッションがまだアクセス可能である可能性が小さいため、クラスタはより安全になります。 データベースへの往復も頻繁に必要です (パフォーマンスに影響を与えます)。 タイムアウトを増やすと逆の効果があります。 設定は `SessionValidationTimeout` (ミリ秒単位) を設定することで構成できます。

永続的なセッションには、各リクエストに「最後のアクティブ」日付も保存されます。 パフォーマンスのこの特定の側面を向上させるために。 セッションの「last active」日付属性は、リクエストごとに直ちにデータベースにコミットされなくなりました。 代わりに、Mendix Databaseに保存される設定可能な間隔でアクションを実行するために、この情報がキューに追加されます。 このアクションは、セッションが別のノードによってログアウトされていないかどうか、および最後のアクティブな日付がデータベース内のものよりも最近であるかどうかを確認します。 `ClusterManagerActionInterval` (ミリ秒単位) を設定することで間隔を設定できます。

{{% alert type="warning" %}}
`SessionTimeout` と `ClusterManagerActionInterval` のデフォルト値を上書きすると、動作を保持し、予期しないセッションログアウトになります。 In particular, the best practice is to set the `ClusterManagerActionInterval` to half of the `SessionTimeout` so that each node gets the chance to run at least once before the cluster leader (version [7.23.3](/releasenotes/studio-pro/7.23#7233) and below) or a node (version [7.23.4](/releasenotes/studio-pro/7.23#7234) and above) attempts to delete a session.
{{% /alert %}}
