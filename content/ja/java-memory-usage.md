---
title: "Java メモリ使用量"
parent: "runtime-Java"
menu_order: 2
tags:
  - "ランタイム:"
  - "ジャバ"
  - "メモリ使用量"
  - "メモリ"
  - "studio pro"
---

Javaメモリは異なるメモリ使用量ブロックに分割されます。 これらの各ブロックは、そのセグメントの実際のメモリ使用量のスナップショットです。 各メモリ使用量ブロックは4つの異なる値に分割することができます。

| メモリブロック      | 説明                                                                                                                                             |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **_init_**   | 起動時にこのセグメントのメモリ管理のためにオペレーティングシステムからJava仮想マシンが要求するメモリ量(バイト単位)を表します。 Java仮想マシンは、オペレーティングシステムから追加のメモリを要求することがあり、また、時間の経過とともにメモリをシステムに解放することがあります。 |
| **_使用中_**    | は、積極的に使用されるメモリ量を表します(バイト単位)。                                                                                                                   |
| **_コミット済み_** | Java仮想マシンで使用できることが保証されているメモリ量(バイト単位)を表します。 コミットされたメモリの量は、時間とともに変化する可能性があります(増加または減少)。                                                          |
| **_最大_**     | メモリ管理に使用できる最大メモリ量(バイト単位)を表します。 定義された場合、メモリの最大量は時間とともに変化する可能性があります。 maxが定義されている場合、使用されるメモリとコミットされるメモリの量は常にmax以下になります。                           |

すべてのMendixアプリケーションの場合、initとmaxの値は同じ値で始まります。 JVMは起動直後にガベージコレクションを実行し、メモリ使用量を修正することができます。

## メモリセグメント

### **_Perm Gen & Code Cache _**

Permanent Generation 領域はすべてのクラスとライブラリに割り当てられます。 Perm Gen に割り当てられたメモリは、かなり静的なままであり、新しいライブラリやクラスがアプリケーションにロードされている場合にのみ増加します。 Perm Gen は Java ヒープの一部ではなく、割り当てられたヒープの上に追加されます。 詳細については、 [永続的な世代の発表](https://blogs.oracle.com/jonthecollector/presenting-the-permanent-generation) を参照してください。

右の画像は、メモリ内でデータがどのように移動するかを詳しく示しています。 スタックはすべてのスレッドから構成されています クラスおよびMendixの場合には、マイクロフロードメインモデルおよびその他すべてのMendix固有の情報に関するすべての情報も含まれています。

![](attachments/16714070/16844065.png)

スタックに関するすべての情報はメモリに保存されます。 すべてのランタイム情報はヒープに保存され、プログラムまたはJVM固有の情報は非ヒープに保存されます。

Mendix Platform、カスタム Java コード、およびユーザー ライブラリのすべてのクラスは、非ヒープに格納されます。 これには、デプロイメントアーカイブの情報も含まれます。

![](attachments/16714070/16844066.png)

ヒープ内のすべてのデータは、ガベージコレクションが実行されると別のセグメントにのみ移動します。 マイナーなガベージコレクションランとメジャーコレクションランの違いがわかります。

マイナーガベージコレクションの実行は頻繁に実行され、実行するリソースがほとんど必要ありません。

マイナーなガベージコレクションは、 **Young Generation** の主要なセグメントである **Eden Space** のみをレビューします。

Eden Spaceには通常多くのゴミが含まれており、マイナーなガベージコレクションは短時間で一度に多くの未使用のオブジェクトを取り除くように最適化されています。

Any objects that are in use during the minor garbage collection will be moved to the **Survive Space**, which is part of the **Young Generation** segment.

**Young Generation** が容量に達すると、主要なガベージ回収プロセスがトリガーされます。 This will evaluate if the objects in the survivor space are still used and remove them if possible, otherwise they will be moved to the **Old / Tenured Generation.**

主要なごみ回収プロセスは、大量のメモリを無駄にすることなく、迅速なごみ回収のために最適化されています。

**Old / Tened Generation** は、ガベージコレクタによって頻繁に清掃されません。 定年生成領域は、容量の+/- 70%に達するまで、または数日後に増加し続けます。 定住スペースは着実に増加し、ガベージコレクションの後に0%近く落ちるはずです。

### 例

![](attachments/16714070/16844068.png)

少量のメモリを消費する健全なMendixアプリケーションは、右側の最初のグラフに似たグラフを表示します。

![](attachments/16714070/16844067.png)

右のグラフは不健康なアプリケーションを示しています。 ここで見られるように、メモリ使用量は1週間を通じて着実に増加しています。 これはメモリを消費し続けるプロセスによってのみ引き起こされます。

アプリケーションがテニュアされた世代空間で多くのメモリを消費することは許容されます。 JVMは主要なガベージコレクションを実行し、テネリングされた世代をゼロにする必要があります。
