---
title: "一時オブジェクト & ごみ収集中"
parent: "runtime-Java"
menu_order: 1
description: "このページでは、持続可能オブジェクトと非持続可能オブジェクトの両方のライフサイクルと、それらがプラットフォームメモリにどのように流れるかについて説明します。"
tags:
  - "永続的な"
  - "非永続性"
  - "transient"
  - "オブジェクト"
  - "garbage"
  - "回収中"
---

## 1つの紹介

このページでは、持続可能オブジェクトと非持続可能オブジェクトの両方のライフサイクルと、それらがプラットフォームメモリにどのように流れるかについて説明します。 一時的なオブジェクトの動作を理解するためには、いくつかの事実を認識する必要があります。

*   一時的なオブジェクト (永続性のないオブジェクトとも呼ばれます) は、一時的とみなされ、メモリ内にのみ存在するオブジェクトです。
*   コミットされていない変更された持続可能オブジェクトはメモリ内に存在し、一時オブジェクトと同様の動作をします
*   Mendix プラットフォームは、それらがもはや「使用」されていないときに自動的にオブジェクトを削除します(「使用」の定義は後述します)

## 2 Mendix 7の動作

Transient Objectsのメモリ内にとどまる方法はMendix 7で大きく変化しました。 これらは、もはやサーバー側のMendixプラットフォームキャッシュに保存されず、クライアントで維持されます。 つまり、サーバーサイドのガベージコレクションは行われなくなります。 これにより、サーバー側のオブジェクトの処理が簡単になります。サーバー上に存在するオブジェクトはガベージコレクションされないためです。

オブジェクトはリクエストのレスポンスと共にクライアントに返されます。 リクエストのコンテキスト外で作成されたオブジェクト (スケジュールされたイベント実行など) は、スケジュールされたイベントが終了すると自動的に破棄されます。

### 2.1 応答サイズへの影響

利用可能なオブジェクトは自動的にサーバーの呼び出しで返されます。 クライアントやその後のリクエストには役に立たないTransient Objectsを削除することで、レスポンスサイズを小さくすることができます。 これは、永続性のないオブジェクトを削除したり、永続性のあるオブジェクトをロールバックしたりすることで発生します。

## 3クライアントサイドガベージコレクション

Mendix クライアントにはガベージコレクタがあります。 このガベージコレクタは、使用されなくなったオブジェクトやメモリ内に保持するために必要なオブジェクトを削除することで、自動的にメモリを解放します。 オブジェクトはウィジェットで表示されるときに使用されます。 持続不可能なオブジェクトについては、他の使用されているオブジェクトがそれらを参照しているときに、それらがインユースとして見られることも意味します。 必要に応じてMendixデータベースから再読み込みできるため、変更されていない持続可能オブジェクトは使用されていないときにメモリから削除されます。

### 3.1 例外的ケース

非永続性のあるオブジェクトが現在のユーザーまたは現在のセッションに関連付けられている場合、それら(関連付けられている非永続性のオブジェクトを含む)はガベージコレクションされません。 これにより、オブジェクトがリクエストを生き残るための方法として機能することができます。 これは気をつけて使うべきではありますが成長状態に至りやすいのです

## 4 状態の成長追跡

状態はクライアントによって管理されます。 Mendixのすべてのクライアントによって使用されるすべての状態の概要を得ることが困難になります (それはもはや1つの場所で利用できません)。 しかし全ての依頼人に分配されている) ただし、Mendixにはログファイルを観察することで状態の成長を追跡する手段があります。

### 4.1 セッション別の状態の成長を観察する

`RequestStatistics` ログノードで `TRACE` レベルのロギングを有効にすることによって。 Mendix Runtime は状態に関する情報を含むリクエストごとにメッセージをログに記録します。 この情報はJSON構造体の形で記録され、ツールで時間をかけてグラフを作成することができます。 ログ文の例を参照してください (この場合、読みやすさのためにフォーマットされています)。
```
TRACE: Request-State statistics: {
  session: "fd0771fe-8c12-49cf-8667-921058b116a3",
  action: "execute-action",
  total: 5,
  details: {
    "MyModule.MyEntity": 3,
    "AnotherModule.SomeEntity": 2
  }
}
```
詳細セクションには、リクエストの状態で使用可能なエンティティタイプごとのインスタンス数があります。

### 4.2 大きな状態でリクエストを検出する

デフォルトでは、リクエストの状態が設定された閾値を超えた場合に備えて、Mendix Runtime は `WARNING` を `RequestStatistics` ログノードに記録します。 log 文の例を参照してください:

```
警告: 551オブジェクトのリクエスト状態サイズが500オブジェクトの閾値を超えています。 リクエストの詳細: セッション `fd0771fe-8c12-49cf-8667-921058b116a3` に `execute-action` を入力します。 State は以下で構成されます:
 * MyModule.MyEntity: 421 objects
 * AnotherModule.SomeEntity: 130 objects
```
This threshold can be configured with the custom setting `com.mendix.webui.StateSizeWarningThreshold` (the value is a number that reflects the total number of objects in the request state).

#### 4.2.1 正しいしきい値レベルの選択

閾値に適切なレベルを選択することは非常に重要です。設定が小さすぎると、あまりにも頻繁にトリガーされ、高すぎると問題の検出が遅すぎるからです。 これは、状態メモリリークを検出することを意味します。つまり、状態が特定のレベルまで拡大し、適切なガベージコレクションを取得しないことを意味します。 一部のアプリケーションでは、ページによっては永続性のない大量のオブジェクトを使用してデータを画面上に表示することが可能です。 その場合、しきい値を大きくする必要があり、この警告が頻繁にログに記録されることを防ぐために、この画面に通常表示されるオブジェクトの量を指定します。

#### 4.2.2 大きな要求状態問題に対するアクション

リクエスト状態が設定されたしきい値を超えた場合、次の原因のリスト(またはそれらの組み合わせ)を確認できます。

* ウィジェットの問題 (ウィジェットが時点で表示されているオブジェクトの更新から自分自身を登録解除しない場合)
* 現在のセッションまたはユーザーに関連付けられているオブジェクトが多すぎます
* 非永続オブジェクトは、レイアウト内のウィジェットに表示されているオブジェクトを関連付けます (つまり、このレイアウトが表示されている限り、このオブジェクトは使用中のままです)。 通常は長い時間です

この状態サイズの根本原因を見つけるために クライアントの開発ツールを使って状態の概要をダンプする必要があります これにより、状態にあるオブジェクトと、それらがガベージコレクションされていない理由を見ることができます。

## サーバー側メモリ管理

Mendix Runtime へのすべてのリクエストに対して、クライアントまたはWebサービスコールを介してオブジェクトがクリーンアップされます。 つまり、マイクロフロー内に多くの一時オブジェクトを作成すると、リクエストの終了までRuntimeメモリが占有されます。

## 6もっと読む

*   [Java メモリ使用量](java-memory-usage)
