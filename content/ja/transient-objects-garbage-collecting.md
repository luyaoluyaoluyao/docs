---
title: "非永続的なオブジェクト & ごみの収集"
parent: "runtime-Java"
menu_order: 1
description: "このページでは、持続可能オブジェクトと非持続可能オブジェクトの両方のライフサイクルと、それらがプラットフォームメモリにどのように流れるかについて説明します。"
tags:
  - "永続的な"
  - "非永続性"
  - "オブジェクト"
  - "garbage"
  - "回収中"
---

## 1つの紹介

このページでは、持続可能オブジェクトと非持続可能オブジェクトの両方のライフサイクルと、それらがプラットフォームメモリにどのように流れるかについて説明します。 永続性のないオブジェクトの動作を理解するためには、いくつかの事実を認識する必要があります。

*   非永続オブジェクトは一時的とみなされ、メモリ内にのみ存在するオブジェクトです。
*   コミットされていない変更された持続可能オブジェクトはメモリ上に存在し、非持続可能オブジェクトと同様に動作します。
*   Mendix プラットフォームは、それらがもはや「使用」されていないときに自動的にオブジェクトを削除します(「使用」の定義は後述します)

## 2つの動作

Mendix の永続性のないオブジェクトは [Runtime Server](runtime-server)には保持されませんが、 [Mendix Client](mendix-client) で保持されます。 つまり、サーバ側のガベージコレクションは存在しません。 これにより、サーバー側のオブジェクトの処理が簡単になります。サーバー上に存在するオブジェクトはガベージコレクションされないためです。

オブジェクトは、リクエストへのレスポンスとともにクライアントに返されます。 リクエストのコンテキスト外で作成されたオブジェクト (スケジュールされたイベント実行など) は、スケジュールされたイベントが終了すると自動的に破棄されます。

### 2.1 応答サイズへの影響

利用可能なオブジェクトは自動的にサーバーの呼び出しで返されます。 クライアントやその後のリクエストには役に立たない永続性のないオブジェクトを削除することで、レスポンスサイズを小さくすることができます。 これは、永続性のないオブジェクトを削除したり、永続性のあるオブジェクトをロールバックしたりすることで発生します。

## 3クライアントサイドガベージコレクション

Mendix クライアントにはガベージコレクタがあります。 このガベージコレクタは、使用されなくなったオブジェクトやメモリ内に保持するために必要なオブジェクトを削除することで、自動的にメモリを解放します。 オブジェクトはウィジェットで表示されるときに使用されます。 持続不可能なオブジェクトについては、他の使用されているオブジェクトがそれらを参照しているときに、それらがインユースとして見られることも意味します。 必要に応じてMendixデータベースから再読み込みできるため、変更されていない持続可能オブジェクトは使用されていないときにメモリから削除されます。

### 3.1 例外的ケース

#### 3.1.1 現在のユーザーまたはセッションに関連付けられたオブジェクト

非永続性のあるオブジェクトが現在のユーザまたは現在のセッションに関連付けられている場合、それらのオブジェクト(およびそれに関連付けられている非永続性のあるオブジェクト)はガベージコレクションされません。 これにより、オブジェクトがリクエストを生き残るための方法として機能することができます。 これは気をつけて使うべきではありますが成長状態に至りやすいのです

#### 3.1.2 Web ページのパラメータであるオブジェクト

ウェブブラウザで閉じられているページのパラメータであるオブジェクトは、5つの新しいページが開かれた後に収集されたガベージのみです。 つまり、エンドユーザーはブラウザで「戻る」ボタンを使用し(限られた回数)、以前に見たのと同じページを見ることができます。 たとえパラメータが持続不可能な場合でもです

{{% alert type="info" %}}
これは、ページが同じように閉じられず、常に生き続けているため、モバイルアプリでは関係ありません。
{{% /alert %}}

## 4 状態の成長追跡

状態はクライアントによって管理されます。 Mendixのすべてのクライアントによって使用されているすべての状態の概要を取得するのは難しい場合があります(1つの場所では利用できません)。 しかし全ての依頼人に分配されている) ただし、Mendixにはログファイルを観察することで状態の成長を追跡する手段があります。

### 4.1 セッション別の状態の成長を観察する

`RequestStatistics` ログノードで `TRACE` レベルのロギングを有効にすることによって。 Mendix Runtime は状態に関する情報を含むリクエストごとにメッセージをログに記録します。 この情報はJSON構造体の形で記録され、ツールで時間をかけてグラフを作成することができます。 ログ文の例を参照してください (この場合、読みやすさのためにフォーマットされています)。
```
TRACE: Request-State statistics: {
  session: "fd0771fe-8c12-49cf-8667-921058b116a3",
  action: "execute-action",
  total: 5,
  details: {
    "MyModule.MyEntity": 3,
    "AnotherModule.SomeEntity": 2
  }
}
```
詳細セクションには、リクエストの状態で使用可能なエンティティタイプごとのインスタンス数があります。

### 4.2 大きな状態でリクエストを検出する

デフォルトでは、リクエストの状態が設定されたしきい値を超えると、Mendix Runtime は `WARNING` を `RequestStatistics` ログノードに記録します。 log 文の例を参照してください:

```
警告: 551オブジェクトのリクエスト状態サイズが500オブジェクトの閾値を超えています。 リクエストの詳細: セッション `fd0771fe-8c12-49cf-8667-921058b116a3` に `execute-action` を入力します。 State は以下で構成されます:
 * MyModule.MyEntity: 421 objects
 * AnotherModule.SomeEntity: 130 objects
```
This threshold can be configured with the custom setting `com.mendix.webui.StateSizeWarningThreshold` (the value is a number that reflects the total number of objects in the request state).

#### 4.2.1 正しいしきい値レベルの選択

スレッショルドに適したレベルを選択することは非常に重要です。なぜなら、設定が小さすぎると、あまりにも頻繁にトリガーされ、設定が大きすぎると、問題の検出が遅すぎるからです。 これは、状態メモリリークを検出することを意味します。つまり、状態が特定のレベルまで拡大し、適切なガベージコレクションを取得しないことを意味します。 一部のアプリでは、永続性のないオブジェクトを大量に使用して、データを画面上に表示することが可能です。 その場合、しきい値を大きくする必要があり、この警告が頻繁にログされることを防ぐために、この画面に通常表示されるオブジェクトの数を指定します。

#### 4.2.2 大きな要求状態問題に対するアクション

リクエスト状態が設定されたしきい値を超えた場合、次の原因のリスト(またはそれらの組み合わせ)を確認できます。

* ウィジェットの問題 (例えば、ウィジェットが以前に表示したオブジェクトの更新から自分自身を登録解除しない場合)
* 現在のセッションまたはユーザーに関連付けられているオブジェクトが多すぎます
* 非持続可能オブジェクトは、レイアウトのウィジェットに表示されるオブジェクトに関連付けられます (つまり、このオブジェクトはこのレイアウトが表示されている限り使用され続けます)。 通常は長い時間です

この状態サイズの根本原因を見つけるために クライアントの開発ツールを使用して状態の概要をダンプするには、 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>G</kbd> を押してください。 結果はブラウザコンソールに表示されます。 これにより、状態にあるオブジェクトと、それらがガベージコレクションされていない理由を見ることができます。

## サーバー側メモリ管理

Mendix Runtimeへのリクエストごとに、クライアントからのリクエスト、またはWebサービスコールを介して、リクエストの最後にオブジェクトがクリーンアップされます。 つまり、マイクロフロー内に多くの一時オブジェクトを作成すると、リクエストの終了までRuntimeメモリが占有されます。

## 6もっと読む

* Mendix blog [状態の芸術, パート1: クライアントの状態への入門 ](https://www.mendix.com/blog/the-art-of-state-part-1-introduction-to-the-client-state/)
* [Java メモリ使用量](java-memory-usage)
