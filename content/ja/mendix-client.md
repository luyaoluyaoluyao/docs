---
title: "Mendix クライアント"
category: "Mendix Runtime"
description: "ランタイムのMendixクライアントの説明とそれがどのように機能するか。"
menu_order: 20
tags:
  - "ランタイム:"
  - "mendixクライアント"
  - "offline-first"
  - "ブラウザー"
  - "javascript"
  - "ナノフロー"
  - "ウィジェット"
  - "起動"
---

## 1つの紹介

Mendix Client は、エンドユーザーのデバイス上で動作し、エンドユーザーとアプリの間のインターフェイスを処理します。 時には、Runtime Serverとは完全に独立して実行し、すべての処理をローカルで実行することができます。 ほとんどの場合、Runtime Serverと相互作用して共有データを取得または更新したり、追加のアプリケーションロジックを実行したりします。

Mendix Client のこの説明は、クラウドで実行されているアプリケーションの Runtime Server の使用に基づいています。 Mendixはテスト用にローカルで実行することもできますが、これは概念的にも同じです。

## 2つの説明 {#description}

Mendix Client は Mendix で構築されたすべてのアプリケーションの一部です。Web、モバイル、ハイブリッドです。

**Web アプリケーション**の場合、Mendix Client は単一のページアプリケーションとして機能します。 これは、異なるURLを使用して提供される別のページではなく、すべてのページングがMendixクライアントによって処理されることを意味します。 Mendix Client は、 `テーマ` が提供する HTML ページから *mxui.js* スクリプトをロードすることでブートストラップされます。

**モバイルアプリケーション** Mendix Client は React Native アプリケーションとして機能します。 これはMendixによって作成されたアプリが、 *ラッパー* と *バンドル*の2つの部分で構成されていることを意味します。 ラッパーは、バンドルを読み込んでプラットフォーム機能を公開するネイティブのiOSまたはAndroidアプリケーションです。 このバンドルには、Client Core、Pluggable Widgets、およびナノフローやページなどのアプリケーション固有のリソースが含まれます。

モバイルアプリケーション用の3種類のラッパーは以下のとおりです。

* [ネイティブアプリにする](getting-the-make-it-native-app)
* [カスタム開発者アプリ](/howto/mobile/how-to-devapps)
* [ネイティブアプリ](/howto/mobile/deploying-native-app)

これらの最初の2つは動的にバンドルをロードしますが、最後の2つは後で [更新](/howto/mobile/how-to-ota) できるパッケージ化済みバンドルを含みます。

**ハイブリッドアプリケーション**は、ほとんどの目的でブラウザで動作するアプリとして扱うことができます。 ただしこの場合は ブラウザーはモバイルアプリケーションに埋め込まれており、 [Cordova](https://cordova.apache.org/) プラグインを介してモバイルデバイスの機能にアクセスできます。 モバイルデバイスで動作する Mendix アプリを作成したい場合は、ハイブリッドアプリではなくネイティブのモバイルアプリを使用することをお勧めします。

以下は、Mendix Clientのコンポーネントを示すチャートです。 各コンポーネントは、チャートの下に記載されています。

![Mendixクライアントの構成](attachments/runtime/mendix-client.png)

### 2.1 クライアントコア

これはクライアントの通訳として見ることができます。 エンドユーザーからのリクエストの処理方法を決定するために、クライアントの設定とクライアントの状態を使用します。 クライアント・コアは、リクエストに応答するために必要なさまざまなプロセスを制御します。 これらのプロセスには、データの取得と操作、クライアント側の式、およびナビゲーションが含まれます。

クライアント・コアは JavaScript で記述されています。

Mendix アプリはクライアントコアを変更せず、すべてのロジックはモデル内で保持されます。 ただし、Mendix の各パッチバージョンには、クライアントコアの独自のバージョンが付属しています。

### 2.2 ウィジェット

これらはMendixクライアントの基本的な構成要素です。 クライアントが取るすべてのアクションはウィジェットによって制御されます。 ページに表示される内容と、ユーザー入力の管理方法について責任を負います。 下記の [ウィジェット](#widgets)には、ウィジェットの詳細な説明があります。

### 2.3 Javascript アクション

これは、アプリ開発者によって追加されたカスタムJavaScriptを実行し、クライアントの設定でJavaScriptアクションとして保持されます。

### 2.4 UI レイヤー

UI レイヤーは、ナビゲーション、リソースロード、プラットフォーム統合を実行します。 Mendix クライアントのアクションに応じてエンドユーザーに提示されるページを構築する責任があります。 適切な言語とその他のロケール設定を使用します。

### 2.5 HTTPS サーバー

HTTPS サーバーは、モデルで保持されているページ、ウィジェット、および javascript アクションを、アプリのエンドユーザーに提供します。

### 2.6 Logic

これは、モデル内のナノフローで定義されたクライアント側ロジックを実行します。

### 2.7 Platform API

これらは Mendix Client が実行されている環境の機能です。 ほとんどの場合、これはカメラやGPSの位置などのモバイルデバイスの機能になります。 ただし、Mendix Native APIへの呼び出しや、画像ファイルへのアクセスなどのブラウザ関数も含めることができます。

### 2.8 クライアント設定

これは、Mendix Client によって必要とされる静的データです。 ブラウザベースのクライアントの場合、このデータはオンラインでRuntime Serverと共に保持されます。 ネイティブ モバイル アプリの場合、これはデバイス上でローカルに保持されます。

これらには、Mendix クライアントを起動するために必要な最初の環境(ブラウザのシェルページなど)が含まれます。 アプリのテーマを定義するカスケーディングスタイルシート (css ファイル) とクライアント側のロジックを定義する JavaScript ファイル。

### 2.9 データ API

これにより、Mendix Client はオフラインストレージまたは Mendix ランタイム内のデータをフェッチおよび操作できます。

### 2.10 オブジェクトキャッシュ

これは Mendix Client によってメモリ上で使用されているオブジェクトを保持および管理します。例えば、永続性のないオブジェクトなどです。 新しいオブジェクトとRuntime Serverによって返されたオブジェクトがページに表示されます。 これらのオブジェクトの属性と関連性の変更も保持します。

ステートの処理は、必要がなくなったときにメモリが解放されるようにガベージコレクションを実行します。

### 2.11 オフラインストレージ

これは、オフラインモードで実行されているアプリにデータを保存することができるモバイルデバイスに通常、永続的なストレージです。 ここでのデータは、セッションの最後に失われないという点で、一時的なオブジェクトストレージとは異なります。 しかし、Runtime Serverに同期されるまで保持されます。

### 2.12 State/Sync/Session

Runtime Serverへのリクエストを管理します。 Mendix Client 内のいくつかのアクションは、Runtime Server へのアクセスを必要としないことに注意してください。 たとえば、Object Cache が既に一時的なオブジェクトストレージ内の必要なデータにアクセスできる場合。 または、アプリが "offline-first" と書かれている場合。

Mendix Client と Runtime Server 間の通信についての詳細は、Mendix Runtime [の通信パターン](communication-patterns) を参照してください。

#### 2.12.1 要塞処理

これにより、アプリの現在の状態(オブジェクトキャッシュに保持されている)がRuntime Serverに通信されます。 状態が Mendix クライアントで保持されているため、Runtime Server はステートレスにすることができます。 これにより、任意のインスタンスが任意のリクエストを処理できるようにインスタンスを追加することで、アプリケーションを水平方向に拡張することが容易になります。

パフォーマンスの問題を回避するために、Mendix Client はステート全体をランタイムに送信しません。 状態処理は、アプリケーションのデプロイ時にモデルを解析することによって、状態のどの部分を送信するかを決定します。

状態の詳細については、次のブログを参照してください: [https://www.mendix.com/blog/the-art-of-part-1-introduction-to-the-client-state/](https://www.mendix.com/blog/the-art-of-state-part-1-introduction-to-the-client-state/). これには、Runtime Serverにどのように状態が渡されるかを確認し、自分自身で複製することができる作業例も含まれています。

状態の処理はガベージコレクションも担当します。 この点についてもっと知りたい場合は、このブログをご覧ください: [https://www.mendix.com/blog/the-art-of-state-part-2-garbage-collection/](https://www.mendix.com/blog/the-art-of-state-part-2-garbage-collection/).

#### 2.12.2 同期

アプリが「オフラインファースト」の場合、アプリ内で作成および変更されたデータはRuntime Serverと同期されるまでローカルに保存されます。 このジョブは、同期プロセスによって実行されます。 これにより、オフラインストレージとオブジェクトキャッシュがランタイムサーバーと同期されます。 オフラインファーストのアプリと同期の詳細については、 [Offline-First](offline-first) を参照してください。

#### 2.12.3 セッション

これにより、ランタイムを持つすべてのセッションが確実に生き続け、必要に応じて復元されます。 また、それを必要とするランタイムとのすべての通信のための認証として機能します。

### 2.13 ランタイムサーバー

Runtime ServerはMendixクライアントからのリクエストを待ち、リクエストを処理し、要求されたデータと適切な場合は追加の状態情報を返します。 これは *xas* と呼ばれるプライベート API を介して行われます。

また、アプリに変更が加えられたときにMendixクライアントに通知します。 開発者は、デバッガをクライアントに接続してナノフローをデバッグすることができます。

すべての情報は Mendix Client に送信され、ページを構築するため、Mendix Client 内のすべてがエンドユーザーに表示されます。 セキュリティはRuntime Serverで実行され、ユーザーが表示することを許可されているMendixクライアントにのみ情報を送信します。

Runtime Server の説明については、 [Runtime Server](runtime-server) を参照してください。

## 3ウィジェット{#widgets}

Mendix ページは個々のウィジェットから構成されます。 ウィジェットは次のタイプのいずれかを指定できます:

* コア ウィジェット – Mendix クライアントの一部
* Pluggableウィジェット – React または React Nativeに基づいてユーザが作成したり、Marketplaceからダウンロードしたりしています。
* カスタム ウィジェット – ユーザーによって書かれた、またはマーケットプレイスからダウンロードされた道場に基づいています。

これらは以下のセクションで説明されています。

### 3.1 コアウィジェット

MendixにはMendixページの標準機能をサポートする多くのコアウィジェットがあります。 コア ウィジェットはコア クライアントの一部です。 これらのウィジェットのほとんどはネイティブとウェブの実装を持っていますが、一部は1つのプラットフォームに限られています。

ネイティブ モバイル アプリケーションでは、React Native フレームワークに基づく実装が使用されます。 Webアプリケーションでは、実装はReactまたはDojoのいずれかに基づいています。 道場を使用するウィジェットにはいくつかの制限があります。例えば、 [pluggable ウィジェット](/apidocs-mxsdk/apidocs/pluggable-widgets-property-types#widgets) 内では使用できません。 これらの道場の実装は徐々に置き換えられています。

### 3.1 強化ウィジェット

コアウィジェットで十分でない場合には、 **Pluggable widget**と呼ばれる独自のウィジェットを作成することもできます。 Pluggableウィジェットはマーケットプレイスからダウンロードできます。 これらは React (ウェブアプリケーション) や React Native (ネイティブモバイルアプリケーション) に基づいており、ウィジェットの作成方法として推奨されています。 以下で説明されているカスタムウィジェットを置き換えます。

詳細については、 [Pluggable Widgets API](/apidocs-mxsdk/apidocs/pluggable-widgets) を参照してください。

### 3.2 カスタムウィジェット

**カスタム ウィジェット** を書くこともできます。 これらは道場フレームワークに基づいており、Webアプリケーションでのみ実行されます。 彼らはプラグ可能なウィジェットよりも異なる、より低レベルの API にアクセスできます。 カスタムウィジェットは、Pluggable ウィジェットで機能を作成できない場合にのみ使用する必要があります。

## 4 Mendix Client Startup

エンドユーザーがMendixアプリを使用したい場合 Runtime Serverに接続する前に、クライアントをデバイスで起動する必要があります。 この仕組みは、クライアントの実行に使用されるメソッドによって異なります。 これは次のいずれかになります。

* ブラウザー
* ネイティブモバイルアプリ

Mendix Client の起動方法については、以下のセクションを参照してください。

### 4.1 ブラウザで Mendix クライアントを起動する

ブラウザでは、環境は最初のページ「シェル」に構築されており、その上にコードがブートストラップされています。

#### 4.1.1 起動フロー

エンドユーザーがブラウザでアプリを起動すると、次のようなフローが起動します。

1. エンドユーザーは、ブラウザにアプリのURLを入力します。

2. ブラウザはHTMLウェブページ("shell")を読み込みます。

3. Webページは、コアウィジェットと一緒にMendixクライアントをロードして開始します。

4. Mendix Client は、任意のカスタム ウィジェットをロードします。

5. Mendix Client はランタイムサーバーに接続し、エンドユーザーを認証します。

6. Mendix Client は、Runtime Server から必要な追加の構成を取得します。


    *Mendix Client は、エンドユーザーとのやり取りを開始する準備ができており、エンドユーザーのセッションが続く限り、以下の手順を繰り返します。*

7. Mendix Client は、ページ定義をロードします。

8. Mendix Client は、ページで使用されるプラグイン可能なウィジェットをロードします。

9. Mendix Client は、Runtime Server から必要なデータを取得します。

10. Mendix Client はページをビルドします。

11. Mendix Client は、エンドユーザーにページを表示します。

12. Mendix Client は、エンドユーザーからの入力を処理し、上記の手順を繰り返して正しいページを表示します。


#### 4.1.2 Mendix クライアント リソースの場所

アプリがデプロイされると、CDNと呼ばれる構造体に静的リソースが配置されます。 これには以下が含まれます。

* 索引。 tml - エンドユーザーがMendixクライアントを起動したときにロードされる最初のHTMLページ — これはクライアントの構成と他の非Mendixコンテンツを含みます (例えばGoogleアナリティクスがアプリに追加された場合)
* mxui.js – メインMendixクライアントコード
* アプリのスタイリング/Atlas – ページの表示方法を定義するアプリ固有の CSS スタイルと静的視覚要素。
* ウィジェット – このアプリで使用されているネイティブとWebコアウィジェット
* ページ定義 – Mendix Client このアプリのページがどのように見えるかを示す xml ページ定義

#### 4.1.3 クッキー

Mendixクライアントが実行されると、セッションに関する情報を記録するための多くのテクニカルクッキーが作成されます。 これらはセッションの終了時に期限切れになり、次のことができます:

* デバイスタイプ
* JSESSIONID
* プロフィール
* SessionTimeZoneOffset
* \_\_VCAP\_ID\___
* XASID
* XASSESSIONID
* originURI
* xasid

### 4.2 ネイティブMendixクライアントの起動

ネイティブモバイルアプリの起動時のフローは、ブラウザでの起動とは異なります。 詳細情報はアプリの一部としてローカルに保存され、ネイティブモバイルアプリは「オフラインファースト」を実行するように設計することもできます。 つまり、Runtime Serverへの接続なしでも実行できます。

ここで説明するフローは本番アプリ向けです。 開発中のフローは同じではありません。 これにより、より高速なデプロイメントとオンラインデバッグを行うことができます。

1. エンドユーザーがデバイスでアプリを開きます。 これはプロジェクト固有のシェルアプリで、iOSやAndroidでネイティブに動作します。 これは、デバイスに適したアプリストアにリリースされます。 アプリの新しいバージョンがデバイスにダウンロードされた場合。 アプリは、たとえすでにデバイス上で開いていたとしても、エンドユーザーが初めて開いたかのように動作します。

2. シェルアプリはネイティブバンドルをロードします。 これはブラウザで動作する Mendix Client によって使用される Mendix Client リソースと同等です。 例えば、Mendix Client コードとページ定義が含まれています。 ただし、Runtime Serverではなく、デバイス上でローカルに保持されます。

3. デバイスに有効な認証トークンがない場合。 Mendix Client は、Runtime Server に接続し、エンドユーザーを認証し、Runtime Server から必要な追加の構成を取得します。

4. アプリが初めて起動した場合、またはアプリへの更新後初めての場合 Mendix Client は、Runtime Server との同期を実行します。

5. Mendix Client は、Visual Studio App Center に保存されているリソースにネイティブバンドルの更新がないかチェックします。 これにより、アプリストアから新しいバージョンのアプリをダウンロードすることなく、アプリを最新の状態に保つことができます。

    *Mendix Client は、エンドユーザーとのやり取りを開始する準備ができており、実行を続ける限り、次の手順を繰り返します。*

6. Mendix Client は、デバイス上のデータを使用してページを準備します。

7. Mendix Client は、ページをエンドユーザーに表示します。

8. Mendix クライアントはエンドユーザー入力に反応します。