---
title: "オブジェクト & キャッシュ"
category: "Mendix Runtime"
description: "このページでは、ランタイムリクエスト内でオブジェクトが相互に相互作用する方法について説明します。"
tags:
  - "ランタイム:"
  - "MendixObject"
  - "キャッシュ"
  - "context"
  - "セッション"
  - "リクエスト"
  - "マイクロフロー"
  - "studio pro"
---

## 1つの紹介

このページでは、オブジェクトがキャッシュされている場合、データベースからオブジェクトが読み込まれる方法について説明します。 キャッシュされたオブジェクトが取得され、オブジェクトが変更されてコミットされたときに何が起こるかを確認します。

「object」という用語はMendixエンティティのインスタンスを指します。

## 2 オブジェクトキャッシュ

Mendix は複数のリクエストに対して Mendix Runtime 内のオブジェクトをキャッシュしません。 リクエスト内で変更されたオブジェクトへの参照を収集し、保持します。 若干の検索アクションにおいて、この物体はデータベースの上で有病率を得、他の物体では有病率を得ません。 これはパフォーマンスとシステムの仕組みに影響します。

## 3どのオブジェクトがトラッキングされているか

永続化できないオブジェクト、新しいオブジェクト、および変更されたオブジェクトのみが追跡されます。 つまり、実行時のリクエストの間、メモリ内に保持されることになります。 リクエストが完了すると、オブジェクトの状態はクライアントに返されるか、クライアント以外のアクションの場合は破棄されます。 オブジェクトがコミットされるとすぐに、非持続可能オブジェクトを除いて、そのオブジェクトは追跡されなくなります。 オブジェクトのロールバックにも同じことが当てはまります。

変更されていない既存のオブジェクトはリクエストスコープで追跡されません。 彼らは変更された場合にのみ追跡されます!

{{% alert type="warning" %}}
Mendix Runtime は、クライアントがその状態にアクセスするのに十分な権限を持っていない場合、オブジェクト状態をクライアントに返すことはできません。 これは、変更されたが、読み取りアクセス権がないオブジェクトをコミットしないマイクロフローをトリガーする場合に意味します。 変更はリクエストの最後に破棄されます。
{{% /alert %}}

## 4追跡範囲

オブジェクトはリクエストスコープで追跡されます。 リクエストスコープは常にセッションスコープより小さく、コンテキスト間で共有できます。 API `ISession.createContext()`を使用する場合、新しいコンテキストとともに新しいリクエストスコープが作成されます。 コンテキストがクローンされると、リクエストスコープはクローンされたコンテキストと共有されます。 リクエストスコープへの変更は、複製されたすべてのコンテキストに表示されます。

## 5つのアクション

### 5.1 トラックしたオブジェクトを返すアクション

いくつかのアクションは、リクエストスコープからオブジェクトを最初に読み込みます。 利用できない場合は、データベースから読み込まれます。 以下はアクションです：

 * 関連づけで取得 (`Core.retrievByPath([..])`)
 * IDで取得/IDの一覧で取得 (`Core.retrieveId([..])` と `Core.retriveIdList([..])`)

つまり、取得されるオブジェクトがリクエストスコープで追跡されている場合(変更されている場合)。 これらのアクション/APIを呼び出すと、リクエストスコープからオブジェクトが返されます。

### 5.2 追跡されたオブジェクトを返さないアクション

1つのアクションは常にリクエストスコープを無視し、常にデータベースからオブジェクトを読み込みます: XPath (すべてのバリアント) により取得します。

これは、オブジェクトが変更された際にリクエストスコープで追跡される可能性があることを意味します。 新品のコピーはデータベースから読み込まれます 同じエンティティインスタンスのいずれかのコピーに加えられた変更は、他のコピーには表示されません。

## 6 影響

### 6.1 この動作がお客様のソリューションに及ぼす影響

エンティティインスタンスへの参照がいくつかあり、異なる方法でこれらの参照を取得した場合。 同じ実体のコピーかもしれない いずれかのコピーへの変更は、他のコピーには反映されないことに注意してください。

これを識別する明確な方法はありませんので、最新バージョンのオブジェクトがあることを確認してください。 データベースに変更が加えられたらすぐにそのオブジェクトを読み直すべきだ

### 6.2 マイクロフローへの影響

この動作は、同様の方法でマイクロフローに影響を与えます。 したがって、ここでのベストプラクティスは、(潜在的に)同じオブジェクトの別の参照に変更をコミットしたときにすぐにオブジェクトを再ロードすることです。

### 6.3 非持続可能エンティティの使用による影響 & マイクロフロー内の変更されたエンティティと Java アクション
ユーザーがクライアントからマイクロフローを呼び出すと、ランタイムへのリクエストと共に状態のコピーが送信されます。 このコピーはランタイムに留まり、このリクエストの処理中にランタイムによって更新されます。 リクエストの処理が完了すると、クライアントに戻り、レスポンスによって返された情報をクライアントの状態に更新します。

サーバー側では、この状態はそのリクエスト処理アクションによってのみアクセスできます。 これは、他のリクエストによって更新されたときに持続不可能なエンティティの状態を問い合わせることができなくなったことを意味します。 クライアント経由以外(この永続性のないエンティティをクライアントに返すために必要な他のリクエスト) これに続いてサーバーにリクエストを送ることになります

リクエストがランタイム上で非同期アクションをトリガーすると、開始された瞬間から状態を取得します。 このアクションがクライアントによって非同期で実行された場合、非同期アクションが完了した場合にのみ、クライアントによってアクションを追跡し、更新された状態を取得できます。 Javaアクションを使用してランタイム上で非同期アクションがトリガーされた場合 状態の更新はクライアントによって追跡できません(更新、データ復元、その他の手順と同様)。
