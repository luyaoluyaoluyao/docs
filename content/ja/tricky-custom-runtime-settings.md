---
title: "Mendix ランタイムでトリッキーなカスタム設定"
parent: "カスタム設定"
description: "通常よりも設定が少し難しいカスタム設定を説明します。"
tags:
  - "サポート"
  - "カスタム設定"
---

## 1つの紹介

Mendixには多くのカスタム設定があり、そのほとんどは [Runtime Customization](/refguide8/custom-settings) で説明されています。

しかし、より一般的に使用されるカスタム設定のいくつかは誤解されたり、予想外の効果を持つ可能性があります。 だからこそ、これらの設定に少し特別な注意を払って、それらを変更することの結果をより徹底的に説明したいと思います。

## 2セッション時間

### 2.1 ウェブクライアント設定

以下の設定はMendix Webクライアントの動作に影響します。

| 名前                | 説明                                                                                                                                                                                        | 既定値  |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| `EnableKeepAlive` | セッションのタイムアウトを防ぐために、 `SessionTimeout`/2ミリ秒ごとにウェブクライアントがキープアライブリクエストを送信するかどうかを定義します。 ブラウザー内の各クリックは `KeepAlive` としても機能します。 このプロパティを無効にすると、ブラウザが開いたままであっても、10分間の操作が行われないと、ユーザーは自動的にログアウトされます。 | true |

### 2.2 一般設定

以下のカスタム設定を構成できます。

| 名前                             | 説明                                                                                                                            | 既定値    |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------- | ------ |
| `セッションタイムアウト`                  | セッションが無効になる時間(ミリ秒単位)の後に定義します。 そのタイムアウト後、セッションは削除対象となります。 次回クラスターマネージャがアクティブなセッションを評価するまで、セッションは破棄されません。                       | 600000 |
| `ClusterManagerActionInterval` | すべてのクラスターマネージャーアクションの実行に使用する間隔 (ミリ秒単位)。 これらのアクションには、ブロック解除ユーザーと無効なセッションの削除が含まれます。 何も指定されていない場合、間隔は `SessionTimeout` の半分になります。 | 300000 |

セッションタイムアウトを増やすと、特にモバイルデバイスでのユーザーエクスペリエンスが向上します。 ユーザーがマイクロフローを実行したときに作成または取得されたユーザーまたはエンティティにデータを表示するために使用されるエンティティは、そのユーザーのセッションに関連付けられていることに留意しておくことが重要です。 長期間記憶され続けることができます ユーザーがサインアウトすると、これらのエンティティはメモリから削除されますが、ユーザーはアイドル状態でもサインアウトしていない場合(例えば、 他のタスクを実行中にブラウザタブを開いたままにした場合、またはサインアウトせずにブラウザを閉じた場合) セッションのタイムアウトは、アイドルセッションによってメモリ使用量が縛られないように保護することができます。 最初のケースは、 `EnableKeepAlive` カスタム設定を false に設定することで軽減することもできます。 ほとんどのブラウザーでは、この設定はアイドル状態のブラウザータブも同様にセッションタイムアウトの影響を受けることを保証します。

セッションタイムアウトチェックやその他の重要なイベントの頻度は `ClusterManagerActionInterval`に関連付けられているため、 値がたくさん増えた場合、セッションタイムアウトのデフォルト値の半分を使用しないことは理にかなっています(例えば、 24時間以上)。 It might make sense to put a maximum value on `ClusterManagerActionInterval`, regardless of how high the value of `SessionTimeout` is set. おおよその図は15分ですが、最終的にはアプリケーションの機能要件に依存します。

ステートレスランタイムでは、問題につながるメモリ使用量の可能性が2つの理由で低減されました。 最初の理由は、水平方向にスケールされた環境で実行できることです。 複数のランタイムは、意図しないメモリ使用量がランタイムに分割されることを意味し、1つのアイドルユーザーセッションの影響を軽減します。 しかし、主な(そして第二の)理由は、メモリ使用量の大部分がクライアントに移動されたことです。 したがって、メモリ内のすべてのエンティティがアプリケーションノードに終わるのではなく、 多くのシェアはクライアントのブラウザで終わるでしょう これは、 `SessionTimeout` のデフォルト値をはるかに高い値に増やすことによって引き起こされる可能性のあるアプリケーションノードの潜在的なひずみを大幅に減らす必要があります。

セッションのタイムアウトを増やすことによって影響を受ける可能性があるもう一つの重要な問題は、Mendixライセンスによって課されるユーザー制限です。 より長いセッションでは、いつでもより多くの同時ユーザーを意味する可能性があります。 これは、アプリケーションを実行する必要があるライセンスの詳細を決定するときに留意する必要があります。

最後に、セキュリティへの配慮があります。 アイドルセッションとは、ユーザが標準的なセキュリティ手順に従わない場合にハイジャックされる可能性があることを意味します。 彼らは任意の時点で自分のコンピュータをロック解除したままにし、後で自分のコンピュータに存在しない場合。 そのユーザーのコンピューターに物理的なアクセス権を持つ人なら誰でも盗んだり使ったりすることができ、自分の利益のためにセッションを利用することができます。 デフォルトのセッションタイムアウト値では、物理的なアクセスが可能であるウィンドウがはるかに制限されているため、このリスクは低減されます(意味)。 24時間のセッションタイムアウトは、10分間のセッションタイムアウトよりも危険です。 これがどれくらいの懸念事項であるかは、アプリケーションの中核的なビジネス目標とアプリで働く人のタイプによって異なります。 たとえば、ITプロフェッショナルは、他のほとんどのユーザーグループよりも標準的なセキュリティ手順に従う可能性が高いはずです。

したがって、これらの値を変更する際は、上記のすべてを覚えておいてください。 また、これらの値のいずれかを変更する決定は、適切な考慮事項に従って行われることを確認してください。

## 3 クエリログ

### 3.1 データベース設定: 共通設定

| 名前                    | 説明                                                                                                                                                                                                  | 既定値 |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| `LogMinDurationQuery` | ここで指定されたミリ秒後に終了した場合、 `ConnectionBus_Queries` ログノードを介してデータベースクエリをログに記録するかどうかを定義します。 デフォルトでは、SQLに関するクエリのみがログに記録されます。 `ConnectionBus_Queries` ログノードのログレベルをTRACEに設定して、このクエリにつながるページまたはマイクロフローの詳細を表示します。 |     |

`LogMinDurationQuery` は、予想よりも時間がかかっているクエリを検出するのに非常に役立つツールです。 これは、アプリで使用されるデータが大きくなった後に予想以上に時間がかかるクエリに特に便利です。 これは、数ヶ月の使用後にのみクエリが遅くなり、プレリリースのパフォーマンステストでは現れない可能性があることを意味するためです。 クエリが遅いことを判断することは、実行しているアプリの種類によって異なります。 しかし、一般的には、アプリを使用しているユーザーに直接影響を与えるクエリ(意味) バックグラウンドプロセスで実行されるクエリよりも遅い値を決定するための閾値が低くなります。 例えば、 何も選択する前に読み込むのに5秒かかるドロップダウンメニューは、1秒ではなく5秒かかる「遅い」クエリのために、4秒ではなく8秒を取るので、バックグラウンドで生成されたPDFよりも何回も悪いです。

Mendix Cloudでは、デフォルト値は10000(意味、10秒)に設定されています。 そのようなクエリは、アプリケーションのフロントエンドで顕著になります。 アプリケーションにバックグラウンドプロセスがない場合、この値が高すぎる可能性があります。 一方、ユーザーの操作を最小限に抑えてバックグラウンドプロセスを多数実行している場合、この値が低すぎる可能性があります。 最終的に、設定する正しい値は、アプリの機能要件に依存し、それに応じて設定する必要があります。

この設定の最も重要な部分は、この値を超えるクエリがないか定期的にアプリケーションログを確認し、問題があるとみなされる場合にそれらを解決することです。 この値をフォローアップせずに設定することは、値を設定しないのと同じくらい便利です。 実行中のクエリは、影響を受けるアクションのスループットに悪影響を及ぼす可能性があります。 アプリケーションのメモリ使用量、アプリケーションのCPU使用率、そして極端な場合の停止につながる可能性さえあります。 そのすべてを考えると、 Mendixは、アプリケーションにとって意味のある数値にこの値を設定し、ログに記録されたクエリをフォローアップすることを強く勧めます。

これらのログエントリは、アプリケーションログ内の次のフレーズを検索することで見つけることができます: **クエリは** で実行されます。 The phrase will appear in an example like this: `Jan 01 02:03:04.567 - WARNING - ConnectionBus_Queries: (1/4) Query executed in 642 seconds and 694 milliseconds: UPDATE "somemodule$someentity”`.

## 4 データベース接続数

### 4.1 接続プール

以下の設定は、データベース接続プールの動作を定義するために使用されます。 Runtime は、再利用可能なデータベース接続のプールを使用します。 たとえば、使用できる接続の数を定義できます。 コネクションプールは [Apache Commons Object-pooling API](http://commons.apache.org/pool/) を使用して実装されています。

| 名前                           | 値                                                                                                                                                                                                                                                       | 既定値 |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| `ConnectionPoolingMaxActive` | プールからアクティブなインスタンスの合計数にキャップを設定します。                                                                                                                                                                                                                       | 50  |
| `ConnectionPoolingMaxIdle`   | プール内の "idle" インスタンスの数の上限を設定します。                                                                                                                                                                                                                         | 50  |
| `接続プールミニイル`                  | プール内で許可されているオブジェクトの最小数を設定します。(アクティブな場合) 新しいオブジェクトを生成する前に、エビクタースレッドで許可されているオブジェクトの数を設定します。 `numActive` + `numIdle` >= `maxActive` の場合、オブジェクトは作成されないことに注意してください。  この設定は、アイドルオブジェクト回避ツールが無効になっている場合には効果がありません (つまり、 `timeBetweenEvictionRunsMillis` <= 0). | 0   |

{{% alert type="info" %}}
これらの設定を変更する場合は、変更を適用するためにアプリを再起動する必要があります。
{{% /alert %}}

{{% alert type="info" %}}
これらの設定は、ランタイムインスタンス *ごとに* に設定されています。 [がアプリケーション](/developerportal/deploy/scale-environment)をスケーリングしている場合 データベース側の接続数にランタイムインスタンスの数が乗算されます。 たとえば、 `ConnectionPoolingMaxIdle` を `50` に設定し、アプリケーションを2つのランタイムインスタンスにスケーリングする場合。 各ランタイムインスタンスは最大50の接続で作成されますが、データベース側では最大100の接続になります。
{{% /alert %}}

When changing the `ConnectionPoolingMaxIdle` and `ConnectionPoolingMinIdle` settings, consider the following points:

* より多くのアイドル接続はより多くのメモリ使用量を意味します
* より多くのアイドル接続は、接続自体を作成する必要がないため、クエリを開始する際のオーバーヘッドが少なくなります。
* アイドル接続が少ないため、メモリ使用量が少なくなります
* 接続自体を作成する必要があるため、アイドル接続はクエリを開始する際のオーバーヘッドを意味します。

最も興味深い設定は `ConnectionPoolingMaxActive`です。 特定の時点で並列に実行できるクエリの合計数が上限されているためです Mendix アプリケーションのこの値のデフォルト設定は 50 です。 これは、任意の時点で最大50個のクエリを並列実行することができることを意味します。 ほとんどのアプリケーションでは、ほとんどのクエリにミリ秒しかかからないため、これは非常に安全な番号になります。 50個のクエリが並行して実行されるまでには多くの同時実行ユーザーが必要です アプリが常に接続プール制限にある場合、次のようなエラーが表示されます。

* `警告 - 接続バス: データベース接続: 50、0アイドル状態。`
* `エラー - 接続バス: 1.2.3 への JDBC 接続を開きます。 :5432 は SQLState に失敗しました: null エラーコード: 0 メッセージ: コネクションを取得できません、プールエラー アイドルオブジェクトの再試行を待っています...(1/4)`

以下のようなDB接続プールグラフが表示されます。

![](attachments/tricky-custom-settings/mendix-customsettings-tricky-img1.png)

`ConnectionPoolingMaxActive` の値を (はるかに) 高い数値に増やすことが望ましいでしょう。 しかし、以下のいずれかが真実である場合、これは正しいアクションではありません。

* 長い実行中のクエリはアプリケーションログに表示されます – その場合、最初にそれらを試して修正する方が理にかなっています。 そうしないと最終的には同じ問題に陥ります しかし、アプリケーションの(再)起動後に発生するには少し時間がかかります
* データベースがメモリ不足、またはメモリ不足ですらありません — その場合。 データベースノードのサイズを最初にアップグレードする方が理にかなってる
    * この場合、アプリケーションログで長時間実行されているクエリを見つけることもできます。
* 特定の時点でアクティブなユーザーセッションはわずかです。3人のユーザーが常に50の並列データベース接続を使用する理由を説明できない限り、アプリケーションでリファクタリングが必要な場合があります。

ただし、以下のいずれかが真の場合は、 `ConnectionPoolingMaxActive` の値を (大いに) 高い数値に増やす必要があります。

* 大量の同時利用者がいます (意味、少なくとも数千)
* アプリケーション・ログに表示される実行中のクエリはありません。 たとえ `LogMinDurationQuery` が(3 秒のように) 比較的低い数に設定されていても、
* 常に利用可能なデータベースメモリがたくさんあります

一般的に `ConnectionPoolingMaxActive` の値を (はるかに) 高い値にすることは、適切なアクションをとることはめったにないことがわかります。 残念ながら接続プールの問題に遭遇すると

加えて、 Mendix Cloud v3で動作するアプリケーションのこの値を変更するには、Mendixのみが行えるデータベースノードの調整も必要になることに注意してください。 ですから、値を変更する前に [Mendix Support Portal](https://support.mendix.com/hc/en-us) に、値を変更する予定の番号を記載したチケットを提出してください。 Mendix Cloud v4でアプリケーションが実行されている場合、データベースノードを変更せずに値を変更することができます。

## 5 続きを読む

* [ランタイムのカスタマイズ](/refguide8/custom-settings)
