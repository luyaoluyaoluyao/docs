---
title: "Java 内存使用"
parent: "跑步java"
menu_order: 2
tags:
  - "运行时间"
  - "贾瓦"
  - "内存使用情况"
  - "内存"
---

Java 内存被分为不同的内存使用区块。 每个区块都是该区段实际内存使用情况的快照。 每个内存使用块可以分成四个不同的值

| 内存块        | 描述                                                                               |
| ---------- | -------------------------------------------------------------------------------- |
| **_init_** | 代表启动时运行系统中的 Java 虚拟机请求的内存初始量 (字节) Java 虚拟机可能需要从操作系统中获取额外内存，并且可能会随着时间的推移释放内存到系统中。 |
| **_已使用_**  | 表示正在使用的内存数量(字节)。                                                                 |
| **_已提交_**  | 表示保证有 Java 虚拟机可用的内存数量(字节) 承诺的内存量可能随着时间的推移而变化（增加或减少）。                             |
| **_最大值_**  | 代表可用来管理内存的最大内存数量(字节数)。 如果定义的话，内存的最大数量可能随时间而变化。 如果定义了最大值，使用和承诺内存总是小于或等于最大值。       |

对于所有Mendix 应用，输入值和最大值以相同的值开头。 启动 JVM 后立即可以执行垃圾收集并纠正内存使用情况。

## 内存段

### **_Perm Gen & 代码缓存 _**

永久一代空间分配给所有班级和图书馆。 分配给Perm Gen的内存保持相当静态，只有当新的库或类加载到应用程序时才会增加。 Perm Gen不是Java Heap的一部分，它被添加到所分配的热量的顶部。 欲了解更多详情，请参阅 [介绍永久生成](https://blogs.oracle.com/jonthecollector/presenting-the-permanent-generation)。

右侧显示的图像详细显示数据如何通过内存移动。 堆栈由所有线程组成， 班级和Mendix 的情况下也包含有关microflow域模型的所有信息和所有其他Mendix 特定信息。

![](attachments/16714070/16844065.png)

关于堆栈的所有信息都存储在内存中。 所有运行时信息都存储在Heap中，所有程序或JVM特定信息都存储在非Heap中。

Mendix 平台、自定义的 java 代码和用户库的所有类都存储在Non Heap中。 (因为Mendix 5，这也将保存在部署档案中的信息。)

![](attachments/16714070/16844066.png)

当垃圾收集执行时，Heap 中的所有数据只能转移到不同的区域。 我们可以看到正在进行的小垃圾收集与大量收集之间的差别。

小规模的垃圾收集工作经常被执行，执行所需的资源很少。

小垃圾收集只能检讨 **艾登太空** , 它是 **年轻一代的主要部分。**

艾登太空通常含有大量垃圾，小垃圾收集得到优化，以便在短时间内一次清除大量未使用的物体。

在小垃圾收集过程中使用的任何物体将被移动到 **生存空间**， 它是 **年轻一代** 部分的一部分。

当 **年轻一代** 达到其能力时，将触发大垃圾收集过程。 这将评估幸存者空间中的物体是否仍然被使用，并在可能的情况下移除它们。 否则他们将被移动到 **旧版/租用代期。**

主要垃圾收集过程得到优化，以迅速收集垃圾，而不浪费很多记忆。

垃圾收集器不会经常清理 **老产/租约生成** 租约生成空间要么一直在增加，直到达到其容量的+/-70%，要么几天后才增加。 租用空间将稳步增加，垃圾收集后将减少近0%。

### 示例：

![](attachments/16714070/16844068.png)

一个消耗少量内存的健康Mendix 应用程序将显示一个类似于右侧第一个图形的图形。

![](attachments/16714070/16844067.png)

右侧的图表显示了不健康的应用。 从这里可以看出，记忆使用率在一周内稳步上升。 这只能是一个不断消耗内存的过程造成的。

应用可以在终身生成空间消耗大量内存。 JVM应管理大型垃圾收集工作，并将终身生成的垃圾减少为零。
