---
title: "不可持久的对象 & 垃圾收集"
parent: "跑步java"
menu_order: 1
description: "此页将解释可持久和不可持续对象的生命周期，以及它们如何通过平台内存流动。"
tags:
  - "可保持的"
  - "不可用"
  - "对象"
  - "garbage"
  - "收集"
---

## 1 导言

这个页面解释了可持久和不可持续对象的生命周期，以及它们如何通过平台内存流动。 为了了解不可持续对象的行为，您需要了解以下几个事实：

*   不可持续对象是一个被视为临时且仅存在于内存中的对象
*   改变的可持久对象不仅存在于内存中，并且与不可持续对象行为相仿。
*   Mendix 平台将在对象不再“使用”时自动移除对象(稍后将解释“使用”的定义)

## 2 行为

Mendix 中不可持续的对象不保存在 [运行服务器](runtime-server)中，但保存在 [Mendix 客户端](mendix-client) 中。 这意味着没有服务器侧的垃圾收集。 这简化了服务器上对对象的处理，因为一个对象在服务器上存在时不会被收集到垃圾。

对象将连同对请求的响应一起退还给客户。 在请求范围之外创建的对象 (如预定事件执行) 将在预定事件完成后自动被丢弃。

### 2.1 影响对反应规模的影响

由于仍然可用的对象是自动通过服务器呼叫返回的， 可以通过删除对客户端或随后的请求不有用的不可持续对象来减少响应的大小。 这可以通过删除不可持续的对象或回滚更改的可持久对象来实现。

## 3个客户端垃圾收藏

Mendix 客户端有一个垃圾收集器。 这个垃圾收集器会自动释放内存，删除不再使用或内存所需的物体。 对象在部件中可见时使用。 对于不可持续的物体，它也意味着当其他使用过的物体提及它们时，它们被视为在使用。 当不可更改的可持久对象未被使用时，将从内存中移除，因为它们可以在必要时从 Mendix 数据库中重新装入。

### 3.1 例外案件

#### 3.1.1 与当前用户或会话相关的对象

当不可持续的对象与当前用户或当前会话相关联时，它们（以及与它们相关联的任何不可持续的对象）不会被收集垃圾。 因此，这可以成为物体生存请求的一种方式。 虽然应该谨慎地使用这种方法，因为它很容易导致一种日益增长的状态。

#### 3.1.2 是网页参数的对象

在网页浏览器中关闭页面的参数只能在打开五个新页面后收集到垃圾。 这意味着最终用户可以在浏览器中使用后退按钮(有限的次数)，并且仍然可以看到他们以前看到的那个页面。 即使参数是不可持续的。

{{% alert type="info" %}}
这与移动应用无关，因为页面不是以同样的方式关闭的，而且总是活着的。
{{% /报警 %}}

## 4 跟踪国家增长情况

因为状态由客户端管理， 很难得到所有客户端在 Mendix 中使用的所有状态的概述 (它在一个地方不可用) 但分发给所有客户）。 然而，Mendix 有通过观察日志文件跟踪状态增长的手段。

### 4.1 按届会观察国家增长情况

启用 `TRACE` 级登录 `请求统计` 日志节点， Mendix Runtime 将记录包含状态信息的每个请求。 此信息是以 JSON 结构的形式登录的，可以用它来工具创建一段时间的图表。 查看日志表示例(此处为可读性格式)：
```
TRACE: Request-State statistics: {
  session: "fd0771fe-8c12-49cf-8667-921058b116a3",
  action: "execute-action",
  total: 5,
  details: {
    "MyModule.MyEntity": 3,
    "AnotherModule.SomeEntity": 2
  }
}
```
在详细章节中，您可以在请求状态中找到每个实体类型的实例数目。

### 4.2 与大国一起侦测请求

默认情况下，Mendix 运行时间将在 `RequestStatistics` 日志节点上记录一个 `警告` 当请求状态超过配置的阈值时。 查看日志声明的示例：

```
警告：请求状态大小为551个对象超过500个对象的阈值。 请求详细信息: 在 `fd0771fe-8c12-49cf-8667-921058b116a3` 会话中输入 `execute-action` 。 状态由:
 * MyModule.MyEntity: 421 个对象
 * AnotherModule.有些实体: 130个对象
```
此阈值可以通过自定义设置 `com.mendix.webui 进行配置。 tateSizeWarningThreshold` (值是一个反映请求状态中对象总数的数字)。

#### 4.2.1 选择正确的阈值

为阈值选择正确的水平是至关重要的，因为如果设置得太低，那么它会经常触发，而设置得太高会导致问题的侦测时间太晚。 它意在检测国家内存泄漏，这意味着状态增加到一定的水平，并且没有适当收集垃圾。 在某些应用中，某些页面可能会使用大量不可持续的对象在屏幕上显示数据。 在这种情况下，阈值应该大于通常显示在此屏幕上的对象数量，以防止此警告被经常登录。

#### 4.2.2 就大请求国问题采取行动

当请求状态超过配置的阈值时，您可以查看以下可能的原因列表(或它们的组合)：

* 一个小部件中的问题 (例如，如果小部件没有取消订阅它以前显示的对象上的更新)
* 与当前会话或用户关联的对象太多了
* 不可持续的对象与布局小部件中显示的对象相关联(即只要显示此布局，这个对象仍然在使用中) 通常长时间)

为了找到这个状态大小的根本原因， 您需要按 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>G</kbd> 使用开发者工具在客户端进行状态概览导出。 结果显示在浏览器控制台。 这使您可以看到处于状态的对象以及为什么他们不会被收集到垃圾。

## 5 服务器侧面内存管理

对于Mendix Runtime的每个请求——无论是从客户端还是通过网络服务呼叫——在请求末尾对对象进行清理。 这意味着如果您在微流程中创建大量的临时对象，它们将占用运行中的内存直到请求结束。

## 6 阅读更多

* Mendix 博客 [状态艺术，第一部分：客户端状态介绍 ](https://www.mendix.com/blog/the-art-of-state-part-1-introduction-to-the-client-state/)
* [Java 内存使用](java-memory-usage)
