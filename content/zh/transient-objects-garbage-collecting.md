---
title: "短暂对象 & 垃圾收集"
parent: "跑步java"
menu_order: 1
description: "此页将解释可持久和不可持续对象的生命周期，以及它们如何通过平台内存流动。"
tags:
  - "可保持的"
  - "不可用"
  - "transient"
  - "对象"
  - "garbage"
  - "收集"
---

## 1 导言

此页将解释可持久和不可持续对象的生命周期，以及它们如何通过平台内存流动。 为了理解短暂对象的行为，您需要注意以下几个事实：

*   瞬时对象(也称为不可持续对象)是一个被视为临时并且仅存在于内存中的对象
*   更改的可持久对象不仅存在于内存中，并且其行为类似于瞬时对象
*   Mendix 平台将在对象不再“使用”时自动移除对象(稍后将解释“使用”的定义)

## 2 Mendix 7

在Mendix 7中，瞬间物体内存的方式发生了重大变化。 他们不再保存在服务器端的Mendix 平台缓存，而是保存在客户端。 这意味着不再进行服务器侧的垃圾收集。 这简化了服务器上对对象的处理，因为一个对象在服务器上存在时不会被收集到垃圾。

对象将在请求中返回客户端。 在请求范围之外创建的对象 (如预定事件执行) 将在预定事件完成后自动被丢弃。

### 2.1 影响对反应规模的影响

由于仍然可用的对象是自动通过服务器呼叫返回的， 可以通过删除对客户端或随后的请求没有用的瞬间对象来减少响应的大小。 这可以通过删除不可持续的对象或回滚更改的可持久对象来实现。

## 3个客户端垃圾收藏

Mendix 客户端有一个垃圾收集器。 这个垃圾收集器会自动释放内存，删除不再使用或内存所需的物体。 对象在部件中可见时使用。 对于不可持续的物体，它也意味着当其他使用过的物体提及它们时，它们被视为在使用。 当不可更改的可持久对象未被使用时，将从内存中移除，因为它们可以在必要时从 Mendix 数据库中重新装入。

### 3.1 例外案件

当不可持续的对象与当前用户或当前会话相关联时，它们（包括它们所关联的不可持续对象）不会被收集垃圾。 因此，这可以成为物体生存请求的一种方式。 虽然应该谨慎地使用这种方法，因为它很容易导致一种日益增长的状态。

## 4 跟踪国家增长情况

因为状态由客户端管理， 更难获得所有客户端在 Mendix 中使用的状态概览(它不再在一个地方可用)。 但分发给所有客户）。 然而，Mendix 有通过观察日志文件跟踪状态增长的手段。

### 4.1 按届会观察国家增长情况

启用 `TRACE` 级登录 `请求统计` 日志节点， Mendix Runtime 将记录包含状态信息的每个请求。 此信息是以 JSON 结构的形式登录的，可以用它来工具创建一段时间的图表。 查看日志表示例(此处为可读性格式)：
```
TRACE: Request-State statistics: {
  session: "fd0771fe-8c12-49cf-8667-921058b116a3",
  action: "execute-action",
  total: 5,
  details: {
    "MyModule.MyEntity": 3,
    "AnotherModule.SomeEntity": 2
  }
}
```
在详细章节中，您可以在请求状态中找到每个实体类型的实例数目。

### 4.2 与大国一起侦测请求

默认情况下，Mendix Runtime 将在 `RequestStatistics` 日志节点上记录 `警告` ，以防请求状态超过配置的阈值。 查看日志声明的示例：

```
警告：请求状态大小为551个对象超过500个对象的阈值。 请求详细信息: 在 `fd0771fe-8c12-49cf-8667-921058b116a3` 会话中输入 `execute-action` 。 状态由:
 * MyModule.MyEntity: 421 个对象
 * AnotherModule.有些实体: 130个对象
```
此阈值可以通过自定义设置 `com.mendix.webui 进行配置。 tateSizeWarningThreshold` (值是一个反映请求状态中对象总数的数字)。

#### 4.2.1 选择正确的阈值

为阈值选择正确的水平是至关重要的，因为如果设置过低，它会经常触发，设置过高会导致问题检测得太晚。 它意在检测国家内存泄漏，这意味着状态增加到一定的水平，并且没有适当收集垃圾。 在某些应用中，某些页面可能会使用大量不可持续的对象在屏幕上显示数据。 在这种情况下，门槛值应该大于通常在这个屏幕上显示的对象的数量，以防止这个警告被经常记录。

#### 4.2.2 就大请求国问题采取行动

当请求状态超过配置的阈值时，您可以查看以下可能的原因列表(或它们的组合)：

* 一个小部件中的问题 (如果小部件没有取消订阅它在某个时间点显示的对象上的更新)
* 与当前会话或用户关联的对象太多了
* 不可持续的对象关联在布局的小部件中显示的对象(即只要显示此布局，这个对象仍然在使用中， 通常长时间)

为了找到这个状态大小的根本原因， 您需要在客户端使用开发者工具进行状态概览导出。 这使您可以看到处于状态的对象以及为什么他们不会被收集到垃圾。

## 5 服务器侧面内存管理

对于Mendix Runtime的每个请求——无论是从客户端还是通过网络服务呼叫——在请求末尾清理对象。 这意味着如果您在微流程中创建大量的临时对象，它们将占用运行中的内存直到请求结束。

## 6 阅读更多

*   [Java 内存使用](java-memory-usage)
