---
title: "任务队列"
parent: "资源"
menu_order: 85
description: "任务队列的概念和使用"
tags:
  - "任务队列"
  - "处理队列"
  - "平行的"
  - "日程安排"
  - "微流"
---

## 1 导言

使用 **任务队列** 允许您异步运行微流或 Java 动作，同时通过将它们分配到任务队列来控制同时执行的任务数量。 您可以配置任务队列来控制这些任务在峰值使用期间给您应用程序加载的最大负荷，同时仍然确保所有微流和Java 操作最终被执行。

### 1.1 替换流程队列模块

这种在后台执行任务的方式取代了先前的 [进程队列](/appstore/modules/process-queue) 市场模块。

更多关于两个机制之间差异的信息，请参阅下面 [替换流程队列](#process-queue)部分。

## 2 个配置

当微流或 Java 动作使用 **调用微流** 或 **在 Studio Pro中调用Java 动作** 动作时，可以计划在后台运行 或通过 Java API。

### 2.1 任务队列中运行中

#### 2.1.1 添加任务到任务队列时的流程流

计划立即执行microflow 或 Java 动作。 任务将在交易完成后尽快在集群中的某个地方执行。

因为任务是在后台执行的，所以没有返回值。 您只能在任务成功运行时才能找到。 关于如何做到这一点的信息，见下面 [接口队列](#interfacing-queue)。

#### 2.1.2 任务在哪里？

在单个节点的情况下，任务队列中的任务将只是在单个节点上执行。

在集群设置中，Mendix 运行时间在整个集群中透明地分配这些任务。 如果集群节点在执行任务时关闭或中途失败。 接下来的集群节点将会拿起它(最终检测到节点会被降落时)并重新执行它。 这种情况是自动发生的，不需要管理。

当您创建任务队列时，您可以控制每个节点平行运行多少任务。 更多信息，请参阅 [创建任务队列](#create-queue)。

#### 2.1.3 任务队列中的内容

对于正在运行任务队列的微流程和 Java 动作，任务运行的上下文略有变化：

 * 他们总是在 *sundo* 环境中执行的。 即使计划微流程有 **应用实体访问** 设置为 *true* (详情请参阅 [Microflow Properties](microflow))。
 * 只有已承诺的可持久实体才能作为参数传递给任务。 通过一个可持久的 *新的* 或 *更改了* 实体会产生运行时间错误。 基本上，这意味着一个实体必须事先已经承诺或已经承诺进行与任务产生的同一交易。
 - 任务未立即执行。 此任务仅添加到任务队列中，当(和如果)它已经成功结束的交易中。 在这一点上，任何集群节点都可以采集。
 - 如果执行失败但有例外, 故障将登录到 `System.ProcessedQueueT` 表。

 {{% alert type="info" %}}
目前仍在讨论背景任务的背景，今后可能会发生变化。
{{% /报警 %}}

### 2.2 创建任务队列{#create-queue}

后台执行是在名为 **任务队列** 中完成的。 他们可以在 Studio Pro 中创建如下：

1. 右键点击模块或文件夹。

2. 选择 **添加其他**。

3. 点击 **任务队列**。

4. 为每个群集节点输入 **线程** 的值(最多40个)。

    任务队列有数个线程。 每个线程都可以同时处理一个任务。 这就是说，队列将接收到与它有线程一样多的并行任务。 每当任务完成时，下一个任务将被挑选。

    一般而言，一两条线索就足够了。 除非有大量的任务或任务需要很长时间并需要并行执行。 有许多线程将给数据库带来额外的负荷，如果不需要的话，就不应这样做。

    工人线程总数限制在40个(按群组节点)。 集群节点没有硬限制。

### 2.3 计划微流程执行

#### 2.3.1 In Studio Pro

在 Studio Pro， [调用微流程](microflow-call) 活动可以在任务队列中启动微流程。

1. 编辑 **调用 Microflow** 活动。
2. 勾选框 **在任务队列** 中执行此微流。
3. 设置 **选择任务队列** 到应该执行微流程的任务队列。

#### 2.3.2 通过 API

`核心` 类在 `com.mendix.core` 中包含一个方法 `微flowCall`。 它可以用于安排背景执行的微流，如以下示例：

```java
Core.microflowCall("AModule.Some Microflow")
  .withParam("Param1", "Value1")
  .withParam("Param2", "Value2")
  .executeInBackground(context, "AModule.OmotQueueName");
```

方法 `ExecuteInBacke` 需要两个参数：一个上下文和一个队列名称。 上下文仅用于创建任务；执行任务时将使用系统上下文。 查看 [API 文档](https://apidocs.rnd.mendix.com/9/runtime/com/mendix/core/Core.html#microflowCall(java.lang.String)) 获取更多信息。

### 2.4 调度Java 动作执行

#### 2.4.1 Studio Pro

在 Studio Pro， [调用 Java 操作](microflow-call) 可以在任务队列中启动一个 Java 操作。

1. 编辑 **调用 Java 动作** 活动。
2. 勾选框 **在任务队列** 中执行此 Java 操作。
3. 设置 **选择任务队列** 到应该执行Java 动作的任务队列。

#### 2.4.2 通过 API

`核心` 类在 `com.mendix.core` 中包含一个方法 `userActionCall`。 它可以用来安排一个 Java 动作来进行背景执行，如以下示例：

```java
Core.userActionCall("AModule.It JavaScript")
  .withParams(context, "Value1", "Value2")
  .executeInBackground(context, "AModule.有队列名称");
```

方法 `ExecuteInBacke` 需要两个参数：一个上下文和一个队列名称。 上下文仅用于创建任务；执行任务时将使用系统上下文。 查看 [API 文档](https://apidocs.rnd.mendix.com/9/runtime/com/mendix/core/Core.html#userActionCall(java.lang.String)) 获取更多信息。

### 2.5 配置选项{#configuration}

优雅地关闭队列的时间段可以配置为Studio Pro中的 [自定义运行时间](custom-settings) 设置。

| 配置选项                            | 示例值   | 解释                  |
| ------------------------------- | ----- | ------------------- |
| `TaskQueue.ShutdownGracePeriod` | 10000 | 关机时等待任务完成的时间以毫秒为单位。 |

{{% alert type="info" %}}
这个宽限期在 [关机](#shutdown) (下面描述)期间应用了两次，所以运行时等待任务结束的最大时间是这个数值的两倍。
{{% /报警 %}}

### 2.6 接口队列{#interfacing-queue}

除了安排和执行任务外，还包括安排和执行任务。 Mendix 平台将跟踪已经在上下文执行的任务：例如，已完成且失败的任务。

在内部，预定任务或运行任务由 Mendix 实体 `System.QueuedTask` 代理。 在高性能设置中，此实体不应被用户代码直接使用 ** ，因为基础数据库表被大量使用。 例如，计算有多少 `系统。 当前存在的 ueuedTask` 对象将锁定表格，并可能导致任务处理严重减缓。 您也不应该直接写入 `System.QueuedTask`。 相反，在 **通话微流程**  或 **调用 Java 行动** 活动或使用 Java API中标记背景执行任务。

已处理的任务，已经完成或失败，将被保存为实体类型 `System.ProcessedQueueTask` 的对象。 这些对象供用户使用。 例如，可以利用这些规则来做以下工作：

1. 如果需要，重新安排失败的任务 (这应该通过创建新的任务(s)来完成)
2. 验证任务已成功运行，或
3. 发生错误时调试应用程序。

`System.ProcessedQueueTasks` 对象永远不会被删除。 用户可在需要时自由删除它们。

### 2.7 任务状态

`System.QueuedTask` 和 `System.ProcessedQueueTas` 的 **状态** 属性反映了后台任务正在进行的状态。 值为：

* `空闲`: 任务已创建并正在等待执行。
* `运行`: 任务正在执行中。
* `完成`: 任务执行成功。  添加 `System.Processed队列任务` 以反映这一点。
* `失败`: 任务不再执行，因为发生了异常。 添加 `System.ProcessedQueueT` 包含异常以反映失败。 将不会检索此任务。
* `中止`: 任务不再执行，因为正在执行它的集群节点已经停止。 添加 `System.Processed队列任务` 以反映这一点。 任务将在另一个集群节点重试.
* `不兼容`: 任务永远不执行，因为模型改变了它的方式，不能再执行。 这可能是因为微流被移除/重命名、参数被更改或任务队列被移除。

### 2.8 模型变化

在 Mendix 运行时间启动过程中，需要检查以确保数据库中的预定任务符合当前模型。 检查以下条件：

* 微流已存在
* 参数匹配
* 队列存在

如果这些条件检查失败，任务将被移动到 `System.ProcessedQueueTasks` 与 **状态** `不兼容` 运行时间只有在所有预定任务被选中后才会开始。 即使有数千项任务，这总的来说也不应太长。

### 2.9 关机{#shutdown}

关闭时， `任务队列执行器` 将停止接受新任务。 正在运行的任务允许一个 [宽限期](#configuration) 完成。 在这段时间之后， 运行时间将发送中断到所有仍在运行的任务线程，然后让它们有一个宽限期。 在第二个宽限期之后，运行时间刚刚继续关闭，最终中止执行任务。 中止的任务将被重置，以便稍后或在其他集群节点重新执行。 在发展模式中，第一个宽限期缩短为1秒。

{{% alert type="info" %}}
中断任务线程可能导致失败。 这些任务将被标记为 `中止` 并稍后再试。
{{% /报警 %}}

## 3 监测

### 3.1 伐木中

[日志节点](logging#mendix-nodes) 名为 `队列` 专门存在于与任务队列相关的所有动作。

## 4 其他

执行 **查找任务队列上的使用** 只能在微流中找到该队列的发生。

{{% alert type="info" %}}
找不到 Java 动作引起的操作。
{{% /报警 %}}

### 4.1 任务队列帮助

您可以使用 [任务队列帮助](https://marketplace.mendix.com/link/component/117272) 模块在 Mendix 市场中帮助您实现任务队列。 它包含以下内容：

* 可用来监视任务队列的页面
* 可以执行基本维护任务的微流

### 4.2 限制

任务队列有以下限制：

* 在后台执行的 Microflow或 Java 动作，尽快按创建顺序执行，但可能是平行的。 它们是按FIFO订单消耗的，但在多个线程的情况下并行执行。 在任何时间点都无法执行单个微流程或 Java 动作(意思, 确保任务按顺序运行，除非线程数设置为1，而且只有一个运行时节点。
* Microflows or Java actions that are executed in the background can *only* use the following types of parameters: Boolean, Integer/Long, Decimal, String, Date and time, Enumeration, committed Persistent Entity.
* 在后台执行的 Microflow或 Java 动作使用所有权限的 sudo/system环境. 无法使用具有有限权限的用户背景。
* 一旦创建后的交易完成，背景微流或 Java 操作将立即开始执行。 这就确保了背景微流或Java 行动所需要的任何数据也能够做到。 无法立即启动背景微流程或 Java 操作，在交易过程中的一半时间。 请注意，如果交易被回滚，任务根本没有执行。
* 每个节点的平行总量限制在40。 这意味着最多可以定义40队列平行性1。 或单个队列，只要总队列不超过40，或有40队列之间的某处。
* 队列中已失败的操作目前无法重新排定。 您可以设置一个预定的微流程来重新尝试失败的任务。 他们可以从 `System.ProcessedQueueTask` 表查询。

### 4.3 高级别执行概况

任务存储在数据库中 `System.QueuedTask` 表。 每个后台任务都插入了一个新对象，并且有 `序列` 个数字。 `状态 = 空闲`,  `队列名称`, `队列Id`, `MicroflowName` 或 `UserActionName`, 和 `参数` 这将作为调用microflow 或 Java 动作的交易的一部分，并将其置于任务队列中， 这意味着在该交易成功完成之前，任务将不会在数据库中可见。

任务然后被执行者消耗，执行 `选择更新SKIP LOCKS` SQL 语句。 这将尝试要求下一个免费任务。 `SKIP LOCKS` 条款将跳过任何已被其他执行者锁定以更新的任务。 相应的 `更新` 更改了 `状态` 改为 `运行` 并将任务所有者设置为 `XASId` 和 `ThreadId` 属性。

任务执行后，它将被移动为 `系统的对象。 rocessedQueueTask` 实体与 `状态` `已完成` 或 `失败`. 如果任务失败但有例外情况，它将包含在 `错误消息` 属性中。

参数作为JSON值存储在 `参数` 属性中。 参数可以是任何原始类型 ([变量](variable-activities))或承诺的持久对象， 由 Mendix 标识符包含在 `参数` 字段中。 执行任务时，将使用Mendix 标识符从数据库检索相应的对象。 出于这个原因，必须在执行任务之前执行持久性对象，因为否则将出现运行时间异常。

当节点崩溃时，这最终会被另一个集群节点检测到，因为它不再更新它的心脏时间戳。 此时，另一个节点将重置在崩溃节点上运行的所有任务。 重置执行以下操作：

* 将任务副本创建为 `System.ProcessedQueueT` 对象，包含 `状态 = 中止`
* 设置 `状态` 返回 `空闲`
* 增加 `重试` 字段
* 清除 `XASId` 和 `ThreadId` 字段

然后该任务将被该组中剩余的一个节点自动消耗。 实际上，这意味着一项任务至少保证执行一次。

{{% alert type="warning" %}}
在正常情况下，任务只执行一次，但面对节点失败，任务可能(部分)执行多次。 这是分布式系统能够提供的最佳保障。
{{% /报警 %}}

### 4.4 替换流程队列{#process-queue}

**任务队列** 取代了较早的 [进程队列](/appstore/modules/process-queue) 市场模块，因为Mendix 9 的发布已废弃。 流程队列模块和 **任务队列** 之间有几个差异：

* **任务队列** 支持一个多节点集群设置，因此可以在水平缩放环境中使用。
* **任务队列** 不需要创建额外的实体。 因为Microflow或 Java 操作可以被标记为在后台执行。
* **任务队列** 还不支持自动重试失败的任务。
