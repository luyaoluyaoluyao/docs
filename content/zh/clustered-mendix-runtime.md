---
title: "集群的 Mendix 运行时间"
category: "Mendix 运行时间"
description: "此页面描述了运行 Mendix Runtime 作为集群的影响和行为。 使用集群功能，您可以设置您的 Mendix 应用程序在负载均衡器后运行，以启用失败和/或高可用性架构。"
tags:
  - "运行时间"
  - "群組"
  - "负载平衡器"
  - "失败"
---

## 1 导言

此页面描述了运行 Mendix Runtime 作为集群的影响和行为。 使用集群功能，您可以设置您的 Mendix 应用程序在负载均衡器后运行，以启用失败和/或高可用性架构。

Mendix 7包含一个全新的集群构建方法。 做到这一点的主要特点是无国籍的运行环境。 这意味着肮脏状态(不可持续的实体实例和尚未持续的更改)不存在于服务器上，而存在于客户端上。 这使Mendix Runtime更容易缩放，因为每个群集节点都可以处理客户端的任何请求。 无国籍的运行时架构也能够更好地进行肮脏状态的维护和更好地了解应用程序状态。

## 2 个集群支持

集群支持是本来就在我们的Cloud Foundry buildpack 实现过程中建立起来的。 这意味着您可以使用云端基金会来扩充。 构建包确保你的系统自动开始作为集群运行。

Kubernetes也支持集群，但您必须使用 *Statelfull Set*。 在 *个关于缩放* 部分 [如何在 Kubernetes 上运行Mendix](/developerportal/deploy/run-mendix-on-kubernetes#scaling) 中有更多关于这个问题的信息。

## 3 集群基础设施

Mendix 运行时集群需要以下基础设施：

![](attachments/16714073/16844074.png)

这意味着Mendix 集群需要负载均衡才能在可用的 Runtime 集群节点上分配客户端负荷。 这也意味着所有节点都需要连接到相同的 Mendix 数据库，并且文件需要存储在 S3 中(见文件存储主题)。 您的集群中的节点数量取决于应用程序、 高可用性要求及其使用情况。

## 4 集束领先，集束奴隶。

Mendix Runtime 有一个集群领先的概念。 这是Mendix Runtime 集群中的一个单一节点，执行集群管理活动。 这些活动是：

* `会话过期处理` - 在会话过期后移除会话(未用于配置的时间范围)
    * 版本 [7.23。](/releasenotes/studio-pro/7.23#7234) 及以上——每个节点都过期其会话(在没有用于配置的时间段后)，群集领导删除了数据库中持续的会话； 在特殊情况下(例如，节点崩溃)，某些会话可能无法从数据库中删除。 在这种情况下，群组领导人会对会话进行清理工作
    * 对于版本 [7.23.3](/releasenotes/studio-pro/7.23#7233) 和更低的版本 -- 集群领先删除过期后的会话 (没有用于配置的时间长度)
* `集群节点过期处理` - 在集群节点过期后移除集群节点(不是为配置的时间段提供心脏节点)
* `背景作业过期处理` - 在信息过期后移除背景作业数据 (超过特定时间)
* `解除屏蔽的用户`
* `执行预定事件` - 预定事件仅在集群头上执行
* `在新部署后执行数据库同步`
* `在新部署后清除持续会话` - 使所有现有会话与最新的模型版本同步。

这些活动只由分组领导人进行。 如果组长不开始工作，该组仍将运作，但上述活动将不予执行。

哪个集群节点成为集群领先，哪个集群成为集群从属，由Cloud Foundry Building 包决定。

## 5 Cluster Startup

集群领导负责数据库同步工作。 所以，如果检测到一个新的应用部署，所有的集群奴隶都会等到集群头领完成数据库同步为止。 当数据库同步完成后，集群奴隶和集群领先将自动全面运行。

如果不需要数据库同步，所有集群节点将在启动后立即完全运行。

## 6 个文件存储

上传的文件应该存储在共享的文件存储设施中，因为每个Mendix Runtime 节点都应该访问相同的文件。 要么共享本地存储设施，要么将文件存储在中央存储设施中，例如Amazon S3文件存储， 微软Azure Blob 存储 或 IBM Bluemix Object 存储器(关于配置Mendix Runtime 到这些存储设备上存储文件的更多信息，请参阅 [自定义设置](custom-settings))。

## 7 晚间启动和前期关闭微流 {#startup-shutdown-microflows}

可以在Mendix中配置 `后启动` and `前导关机` 微流。 在Mendix 集群中，这意味着这些微流被称为每个节点。 这可以让您注册请求处理程序和其他活动。 然而，在这些微流过程中维护数据库受到极大的劝阻，因为它可能影响到同一组的其他节点。 集群启动或关闭时无法运行微流。

## 8 集群限制

### 8.1 微流程调试

在运行多节点集群时，它不可预测将会在哪个节点执行微流。 因此，无法在Mendix Modeler的集群中调试这种微流程。 然而，您仍然可以在运行 Mendix Runtime 的单个实例时调试微流。

### 8.2 集群锁定(有保障的单一执行)

某些应用需要在某个时间点单次执行某项活动。 在单个节点 Mendix 运行时可以使用 JVM 锁来保证这一点。 然而，在分布式的情况下，这些JVM使用不同的机器运行，因此没有可用的锁系统。 Mendix 也不支持集群锁定。 如果无法绕过此项，您可能需要使用外部分布式锁管理器。 然而，铭记在分布式系统中锁定是复杂的，容易失败(锁定饥饿，锁定到期等等)。

{{% alert type="info" %}}
由于上述原因，微流程的 **禁止并行执行** 属性仅适用于单个节点。
{{% /报警 %}}

## 9 集群中的肮脏状态

当用户登录到Mendix 应用程序并开始通过特定的应用程序流程时， 系统可以暂时保留某些数据，同时不将其保留在数据库中。 数据保存在Mendix 客户端内存中，并代表用户传送到 Mendix Runtime 节点。

例如，请想象您通过由航班、旅馆和租车组成的Mendix 应用程序预订度假。 在第一步中，您将选择和配置您的酒店，第二步将选择您的酒店， 在你的第三辆出租车中，最后一步你确认预订和付款。 每个步骤都可以放在不同的屏幕上， 但当你从第一步走到第二步时，你仍然想记住你预订的飞行。 这叫做“肮脏状态”。 数据尚未最后确定，但应在不同请求之间保留。 由于可靠地缩小规模和支持失败的假设情景是必要的， 状态不能存储在请求之间的 Mendix Runtime 节点的内存中。 因此，该州被退回给打电话者(Mendix 客户)，并被添加到其后的请求中。 这样每个节点就可以在这些请求中使用该状态。

下面的图像描述了它的行为：

![](attachments/16714073/16844072.png)

从Mendix 数据库中读取对象并删除(未更改的)对象仍然是一个“清理状态”。 更改一个现有对象或实例化一个新对象将创建 'Dirty 状态'。 'Dirty State' 需要与每个请求从Mendix 客户端发送到Mendix Runtime。 提交对象或回滚将把它们从“脏状态”中移除。 如果一个实例化或更改对象被删除，也会发生同样的情况。 不可持续的实体总是神圣国家的一部分。

只有来自 Mendix 客户端的请求才能保留“Dirty State”（同步和异步呼叫）。 对于所有其他请求，例如预定的事件、网络服务或背景执行请求，国家只能在当前请求下生活。 此后，“Dirty State”要么必须继续存在，要么将被抛弃。 仅允许Mendix 客户端请求保留他们的“Dirty State”，原因是这是当前唯一能够使用实际用户输入的频道。 用户输入需要更多的与请求之间数据的互动和灵活性。 只允许这些请求保留他们的“Dirty State”，Mendix Runtime和外部源的负载就会被最小化并优化性能。

请注意，每当Mendix 客户端重启时，所有状态都将被丢弃，因为它只保存在Mendix 客户端内存中。 当重新加载浏览器标签时Mendix 客户端会重启(例如，) 按下 <kbd>F5</kbd>), 重新启动移动混合应用或明确登出。

Dirty State中的对象越多， Mendix Runtime 和 Mendix 客户端之间的请求和响应必须传输更多数据。 因此，它对业绩产生影响。 在集群环境中，建议尽量减少“Dirty State”的数量，以尽量减少同步对业绩的影响。

Mendix 客户端仅通过发送处理请求时可能读取的数据来优化发送给Mendix Runtime的状态数量。 例如， 如果您调用了一个微流程，它获取 `预订` 作为参数和检索 `飞行在关联上` 然后客户端将只会传递 `预订` 和关联的 `飞行`s来自肮脏状态以及请求。 但不是 `酒店`s。 请注意，这种行为是最好的努力； 如果微流过于复杂，不能分析 (例如) 当一个 Java 动作以状态对象作为参数被调用时，整个肮脏状态将会被发送。 此优化可以被 [`优化网络调用` 项目设置](project-settings#optimize-network-calls) 禁用.

{{% alert type="warning" %}}

重要的是要认识到，当在 Mendix 中呼叫外部网络服务以获取外部数据时。 这些行动的反应被转换成Mendix 实体。 只要它们不在Mendix 数据库中持续存在。 他们将是 `Dirty State` 的一部分，对应用程序的性能有负面影响。 为了减少这种影响，这种行为今后可能会改变。

{{% /报警 %}}

为了减少大量请求和响应的性能影响，应用程序开发者应该了解造成这种情况的情况。 有几种情况可能导致这样做：

| 场景                                                    |
| ----------------------------------------------------- |
| 微流程可以创建大量不可持续的实体，并在一个页面中显示它们。                         |
| 微流调用网络服务/应用服务来检索外部数据并将其转换为不可持续的实体。                    |
| 一个页面包含多个微流数据源数据视图，每个页面都会导致状态传输到 Mendix Runtime 来处理微流。 |

{{% alert type="warning" %}}

为了确保在您的应用中适用上述情景时，肮脏状态不会变得太大， 它建议当对象不再需要时明确删除它们，这样它们就不再是状态的一部分。 这将释放Mendix Runtime 节点的内存以处理请求并提高性能。

{{% /报警 %}}

## 10 个实体与 `System.Session` 或 `System.User`

`$currentSession` 变量可用于微流，这样就可以轻松地获得当前会话的引用。 当一个对象需要存储时，其关联可以设置为 `$currentSession`， 当对象需要再次检索 `$currentSession` 可以用作起点，从中获取所需对象可以通过关联获取。 相关对象的设计能够满足人们的需要。 此模式适用于与 `System.User` 相关的实体。 在这种情况下，您可以使用 `$currentUser` 变量。

![](attachments/modeler-core/2018-03-01_17-49-15.png)

例如， 您可以将 `密钥` 和 `值` 成员添加到一个 `数据` 实体与 `系统相关联。 会话` (并有关键值的常量)。

![](attachments/modeler-core/2018-03-01_17-42-38.png)

`值` 可以很容易地通过在 `密钥上查找` 的值 `数据` 实例列表中的值。

![](attachments/modeler-core/2018-03-01_17-56-37.png)

{{% alert type="warning" %}}

当数据与当前用户或当前会话相关时，它不能自动收集到垃圾。 因此，这种数据将随每次请求一起发送到服务器，然后根据这些请求的答复退回。 因此，在无法保留这种临时数据的情况下，应将实体实例与当前用户和当前会话联系起来。

{{% /报警 %}}

## 11 个会话现在总是持久的

为了支持无缝集群，会话将永远持续到数据库中。 在以前的版本中，这是一个已知的性能瓶颈。 Mendix 7包含几个优化来迁移此性能点击。 为此目的对数据库进行的回程访问会因为给持续会话最多30秒缓存时间（默认情况下）而减少。 这意味着会话退出后，会话仍可在群集的其他节点上访问30秒钟。 但只有在节点在退出之前处理了此次会话上的请求的情况下。 此超时可以配置。 降低它会使集群更安全，因为在配置的时间窗口内会议仍然可以访问的机会更小， 但也需要更经常地走访数据库（影响业绩）。 增加超时效果相反。 可以通过设置 `会期校验超时` (以毫秒为单位的值) 来配置该设置。

持续会话还会在每次请求时存储一个“最后活动”日期。 改进业绩的这一特定方面； 会话的 '最后一次活动' 日期属性不再在每次请求时立即承诺到数据库。 与此相反，这些信息已排队，可以在一个可配置的间隔下运行，存储在 Mendix 数据库中。 此操作可以验证会话是否被另一个节点注销，以及最后一个活动日期是否比数据库中的日期更近。 可以通过设置 `ClusterManagerActionInterval` (以毫秒为单位的值) 来配置间隔。

{{% alert type="warning" %}}
覆盖 `SessionTimeout` and `ClusterManagerActionInterval` 自定义设置可能会影响保持生命的行为并导致意外的会话注销. 尤其是， 最佳做法是将 `ClusterManagerActionInterval` 设置为 `SessionTimeout 的一半` ，以便每个节点都有机会在群集领导之前至少运行一次 (版本 [7)。 3.3](/releasenotes/studio-pro/7.23#7233) 及以下或节点(版本 [7.23.4](/releasenotes/studio-pro/7.23#7234) 及以上)试图删除会话。
{{% /报警 %}}
