---
title: "业绩最佳做法"
description: "描述优化应用性的Mendix 最佳做法。"
parent: "mx-assist-performance bot"
tags:
  - "studio pro"
  - "执行情况"
  - "性能机器人"
  - "mx 帮助"
  - "mendix 帮助"
---

## 1 导言

本文件概述了优化应用性能的性能问题和Mendix 最佳做法。

## 2 计算出来的属性最佳做法 {#mxp001}

<a name="mxp002"></a>当一个对象已经计算属性时，每次从存储中更改或检索该对象。 其计算出来的属性是通过调用微流程计算出来的。 如果计算出来的属性背后的逻辑检索其他对象或执行集成活动， 它将导致额外的负荷(和延迟)，而没有使用逻辑结果。 创建计算的属性总是会影响性能，所以您应该评估是否需要使用这些属性。 关于属性的更多信息，请参阅 [属性](attributes)。

在大多数情况下，计算属性背后的逻辑总是在使用对象时执行。 当没有检索方案用于检索活动（数据网格就是这种情况）时执行它。 计算属性背后的逻辑在以下元素中执行：

- 获取和更改微流中的对象活动
- 在 UI 小部件 (例如数据视图，自定义小部件)
- 当一个对象从UI作为参数传递到微流时(例如一个按钮触发微流)。

有两个不同的性能问题，您可以轻松地修复计算属性：

1. [当您在一个页面上使用计算出来的属性](#calculated-attribute-on-page)
2. [当有未使用的计算属性](#unused-calculated-attributes)

### 2.1 避免在页面上使用计算出来的属性 {#calculated-attribute-on-page}

获取活动触发计算属性的逻辑， 它可以导致数据库动作和微流程调用(通过计算属性相互检索对象)。

如果一个页面上的数据部件(列表视图，数据视图或数据网格)使用计算的属性， 这可能会影响加载和显示页面的时间。

#### 2.1.1 修理步骤

为了解决这个问题，请做以下工作：

1. 在域模型中，更改要存储而不是计算的属性。
2. 在哪里该属性将被用于数据库中，使用相关的微流计算值。

{{% alert type="info" %}}

您还需要迁移任何现有数据，因为当属性被更改为被存储时， 数据库将只包含该数据类型的默认值。

{{% /报警 %}}

### 2.2 删除未使用的计算属性 {#unused-calculated-attributes}

当获取活动触发计算属性的逻辑时， 它可能导致数据库动作和微流调用的执行链(通过计算属性相互检索对象)。

如果不使用计算出来的属性，它们可以安全地被移除，以避免多余的微流调用。

#### 2.2.1 修理步骤

要解决这个问题，请删除未使用的计算属性。

## 3 在排序条中添加索引到属性 {#mxp003}

[排序条](sort-bar) 用于排序数据部件中的项目。 排序条可以用于三种不同类型的数据部件：

- 数据网格
- 模板网格
- 参考设置选择器

排序栏中的每个排序项都被顺序用来在部件中排序数据。 在排序项目中使用的属性上添加一个 [索引](indexes) 可以使排序过程更快，随后提高页面的性能。

在一个实体上可以执行四个操作：创建、更新、删除和选择。 创建、更新数量的实体 并删除操作远远超过可调用的 *写密* 所选操作的数量，因为大多数操作都会在数据库中变换数据，而不是从数据库中选择。

所选操作数量大大超过创建、更新数量的实体 并删除操作可以叫做 *读取密集* ，因为大多数操作从数据库中选择数据。 重要的是仅在属于主要是 *读取密集的* 的实体属性上执行此优化。

由于读密和写密实体适用完全不同的最佳做法， 按实体所从事的业务类型区分实体将是有价值的。

### 3.1 修理步骤

为了解决这个问题，在页面按排序条条目的属性上添加索引。

## 4 避免在循环中用创建对象、更改对象或提交活动 {#mxp004}

<a name="mxp005"></a>在 microflow中，Mendix 对象可以通过三个活动持续到数据库： **创建对象** 活动。 **更改对象** 活动和 **提交** 活动 对于在循环中创建或改变的对象，将其立刻提交到循环中并不是最佳做法。 这涉及不必要的性能间接费用。 而是这样。 它建议在循环外面进行几次创建/更改的对象的批次承诺，并使用 **提交** 活动来减少数据库。 应用程序和网络间接费用。 关于 **创建对象**, **更改对象**和 **提交** 活动 参见 [创建对象](create-object), [更改对象](change-object), 和 [提交对象](committing-objects).

与个人承诺相比，提交对象清单具有以下好处：

- 数据库中创建或修改记录的已准备好的说明被JDBC驱动程序明确重新使用，具有以下好处：
    - 执行计划已缓存
    - 司机关心最小的网络开销。
- 对于更改数据的每个数据库动作，将采取以下动作并添加间接费用：
    - 保存点是在操作之前创建的，然后发布
    - 从数据库中检索自动提交的对象
    - 自动提交的对象被存储到数据库(如果相关)

### 4.1 修理创建或更改对象活动的步骤

若要修复 **的问题，请创建** 或 **更改循环中的对象** 的活动，请执行以下操作：

1. 更改 **提交** 选项a **创建**/**更改** 对象活动从 *无* 并确保创建/更改对象在列表中可用。
2. 当迭代完成或列表中对象数量达到1000时，在循环之后提交列表，以避免过多的内存使用。

### 4.2 规定承诺活动的步骤

修复 **提交** 活动的问题, 当迭代完成或列表中对象数量达到1000时，在循环结束后提交列表，以避免内存使用过多。

## 5 将合格的微流转换成纳诺夫洛斯 {#mxp006}

Nanoflow 直接在最终用户的设备或浏览器上执行。 这使它们更适合脱机使用。 与此相对照，微流运行于运行时服务器，因此涉及网络流量的使用。 将合格的微流转换为nanoflow 有助于避免网络上的通信并大大提高应用性能。 欲了解更多关于什么时候使用nanoflow以及什么时候使用它们的信息，请参阅 [Nanoflows](nanoflows)。

您可以使用以下标准识别可兑换微流：

- 2. 具有以下一个或多个类别的微额资金流：
    - 微流具有离线应用的逻辑意义。
    - Microflow 具有在线应用程序的逻辑，但不涉及任何与数据库相关的动作，如提交 **创建对象**， **提交**, **检索**, 和 **回滚** 活动
    - 微流程最多有一个与数据库相关的操作。 (不是最佳做法)
- 微流含有纳米但不兼容的活动。 欲了解纳米洛支持的活动信息，请参阅 [活动](activities)。
- 微流程表达式不包含以下变量： `$latestSoapFault`, `$latestHttpResponse`, `$currentSession`, `$currentUser`, `$currentDeviceType`. nanoflow不支持这些变量。
- 由于nanoflow 是在当前用户的情况下执行的，因此确保微流只有当前用户被授权的操作。 否则转换的nanoflow 将失败。

### 5.1 修理步骤

为了解决这个问题，请做以下工作：

1. 右键单击模块并选择 **添加 nanoflow** 来创建新的 nanoflow 。
2. 从微流中复制相同的逻辑。 新的纳米流必须看起来与微流几乎完全相同。
3. 通过右键单击微流并选择 **查找用途** 来检查微流的用法。 用新创建的nanoflow替换所有用法。
4. 删除未使用的微流。 您可以通过选择微流程并按 <kbd>删除</kbd> 或右键单击并选择 **删除** 来做到这一点。

## 6 将索引添加到用于XPath 表达式的属性 {#mxp007}

[XPath 表达式](xpath) 可能需要很长时间才能运行，这取决于底层实体包含多少记录。 对于读取密集实体来说，在XPath 表达式中使用的属性上添加一个索引是有意义的。 这将大大提高从数据库检索对象的性能。 XPath 表达式也可以通过按序排序，将尽可能多的项目排除在外。 这可以通过在表达式中早些时候使用索引属性来实现。 这将使数据集的其余部分尽可能小到加入/过滤，并减少数据库上的负荷。

请注意，XPath 表达式可以在三个不同的地方使用：

- 访问规则和实体
- 页面列表和网格的源/过滤器
- 获取微流和Java 动作中的操作

### 6.1 修理步骤

为了解决这个问题，请做以下工作：

1. 在添加索引前检查底层实体是否包含大量记录(至少为 10000项记录)。
2. 为 XPath 表达式中使用的每个属性添加索引，仅适用于主要在基础实体上执行的读密集操作的场景。

{{% alert type="info" %}}

这种优化可能对像布尔和枚举这样的数据类型不会非常有益，因为这些类型的可能值有限。 建议不要为此类类型添加索引。

{{% /报警 %}}

## 7 避免隐藏非持久实体 {#mxp008}

不可持续的对象是一个被认为是临时的对象，仅存在于内存中。 这是一个不可持续的实体的例子。 欲了解关于可持久和不可持久实体的更多信息，请参阅 [可持久性](persistability)。 由于这些对象仅存在于内存中，缓存它们是没有用的。 一方面，建立系统化实体或系统化实体不可持续的实体协会是多余的。 另一方面，重要的是缓存那些不经常变化但经常被逻辑使用的物体。 这将有助于避免数据库通信的间接费用。 可持久的实体可以连接到用户的 System.Session 并被用作缓存结果。 关于对象和缓存的更多信息，见 [对象 & 缓存](objects-and-caching)。

您可以使用以下指南来决定是否需要缓存：

- 数据不会经常更改
- 数据读取频率很高
- 数据量有限(通常低于10 000项记录)
- 使用陈旧数据的影响已被接受

### 7.1 修理步骤

为了解决这个问题，请做以下工作：

1. 对于一个不会经常改变的实体，如果其对象经常被用于您的逻辑，它就可以持续存在。
2. 如果不满足上述条件，请移除系统用户或系统用户的不稳定实体的关联。

