---
title: "在桌面模型中使用版本控制"
category: "版本控制"
menu_order: 10
description: "如何使用版本控制以及如何解决可能出现的一些问题"
tags:
  - "版本控制"
  - "冲突"
  - "决定"
  - "合并"
  - "补丁"
  - "分支"
  - "贸易和发展会议"
---

## 1 导言

此参考指南描述了如何使用版本控制桌面模型。 版本控制如何在 Mendix 中运行背后的理论以及概念的定义可以在 [版本Contol](version-control) 中找到。

## 2 开始一个版本控制的项目

若要启动一个带有版本控制的新项目，请执行以下操作：

1. 选择 **新项目...** 在桌面模型中。
2. 在 **应用程序设置** 对话框中，设置 **启用在线服务** 到 *是* 此选项创建团队服务器仓库和开发者门户项目。
3. 更改 **工程目录**，或保留桌面模型建议的默认值。
4. 点击 **创建应用程序**。

该应用创建在团队服务器上，并且在 **项目目录** 中创建了一个工作副本。 这将在桌面模型中打开，以便您可以立即开始工作。

![](attachments/modeler-core/2018-03-02_11-11-18.png)

## 3 加入一个项目

如果已经启用了团队服务器项目，您可以被邀请加入(见 [团队](/developerportal/collaborate/team))。

一旦您是团队成员，赋予您足够的权限， 您可以通过以下方式在应用上工作：

1. 选择 **打开项目...** 在桌面模型中。
2. 选择 *Mendix 团队服务器* 为 **您的应用程序存储在哪里？**。
3. 从 **团队服务器应用程序** 下拉列表中选择您的应用程序。
4. 更改 **工程目录**，或保留桌面模型建议的默认值。
5. 点击 **创建应用程序**。

该项目将从团队服务器下载并在桌面模式中打开。

![](attachments/modeler-core/open-new-team-server-app.png)

## 4个日常发展

让我们说你在磁盘上有一个项目的工作副本。 您对应用程序进行更改并保存。 保存的更改不会立即对其他人可见. 已更改的文档、文件夹和模块可以通过查看 **状态** 来确认。

When you are happy with a set of changes, you **commit** them to the repository. 然后其他人可以选择更新和检索这些更改。

You can **update** your working copy with changes committed by others.

您也可以看到所有已经执行的更改的 **历史** ，不管是谁实施的。

### 4.1 状态

您的项目状态是与原始项目相比的工作副本中所有变化的概述。 Modeler显示项目浏览器和 **更改** 基座的状态。

项目浏览器在项目前面展示了一个图标(文档、文件夹和模块)，这些项目以某种方式被更改。 不同的图标显示了所做的不同类型的更改。

| 图标                                 | 含义                                    |
| ---------------------------------- | ------------------------------------- |
| ![](attachments/524294/688173.png) | 这个项目没有发生任何事情。 它没有变化 w.r.t。 原始文件。      |
| ![](attachments/524294/688172.png) | 您修改了这个项目(在文档、文件夹或模块中)。                |
| ![](attachments/524294/688175.png) | 您添加了此项目。                              |
| ![](attachments/524294/688174.png) | 您将此项目移动到项目树中的另一个位置。                   |
| ![](attachments/524294/688164.png) | 您删除了此项目。                              |
| ![](attachments/524294/688165.png) | 此项目有冲突。 查看 [处理冲突](#conflicts) 了解更多信息。 |

{{% alert type="info" %}}
仅有一个图标的空间，如果文档都被修改并移动，则显示为修改。
{{% /报警 %}}

例如，microflowChangePassword 已被修改。 还添加了一个名为“Flows”的新文件夹，所有微流都被移动到这个文件夹中。 在屏幕截图中，您可以看到包含更改的文件夹和模块用黄色图标描绘。 移动的微流有蓝色图标。 这有助于您快速查看项目中的更改位置。

![](attachments/modeler-core/2018-02-21_13-27-21.png)

您可以在更改Dock中看到相同的信息。 在这种情况下，每次 *更改* 为一个项目有一个条目。 如果文档同时被修改并移动，该文档有 *两行* 行。 基站还显示已被删除的项目，项目浏览器无法做这件事。

![](attachments/modeler-core/2018-02-21_13-41-50.png)

{{% alert type="info" %}}
当您成功提交您的项目， 这将成为新的原始信息，并且所有更改信息都从项目浏览器和更改码头中删除。
{{% /报警 %}}

### 4.2 承诺

正在发送对资源库的更改称为 *提交*。 主意是让你将小块和一致的作品提交到仓库中。 我们建议您经常提交您的更改。 最好是仓库中的版本总是没有错误，当你的项目有错误时，Modeler会警告您不要执行任务。

要提交您的更改，请点击 *更改中的 **提交** 按钮* 码头， 或选择 **项目 > 提交。 。** 菜单项

![提交按钮](attachments/modeler-core/commit-button.png)

一般而言，在实现一个特性或修复一个bug后进行承诺是一个好主意。 通过经常性的承诺，您的工作与其他人的工作是一致的。 承诺的好处往往包括：

* 如果出现任何冲突，您的心中仍然还没有变化了
* 更容易理解修订版本
* 如果你需要恢复某些东西，你可以恢复一小块工作

提交结果导致仓库中的一个新版本。 当您执行提交时，您可以在桌面建模中添加以下信息，这将附加到新创建的版本：

* 文字信息。 这应该是您所做更改的摘要
* 与提交相关的开发者门户网站故事列表。 一个小的提交可能会涉及一个故事。 Modeler显示的故事在当前的冲刺中，且没有 *完成* 的状态。 在提交中添加故事不会改变开发者门户网站的故事。 将状态设置为“完成”必须手动完成，并取决于您的 *完成* 的定义。

![](attachments/modeler-core/2018-02-21_13-50-03.png)

Modeler也自动附加一些信息：

*   提交人( *作者*)
*   提交日期和时间
*   更改的文档、文件夹和模块列表以及更改类型(例如， *修改* 或 *添加*)
*   用于提交的 Moderr 版本

如果您也修改了 Java 源代码， 添加小部件或其他影响项目文件以外文件的更改，您将在磁盘</strong> 标签页上看到 **更改，显示您即将提交的磁盘更改。</p>

只有当您的工作副本是最新版本时才允许提交。 如果其他人在上次更新后进行了更改，您必须先更新。 这是因为您用承诺创建的版本应该包含您的更改和对方的更改。 更新将合并仓库中的最新更改和您的更改。 在检查结果并修复任何冲突后，你可以再次承诺。

### 4.3 更新

正在更新从仓库获取最新的更改。 您需要这样做才能将尚未在您的工作副本中的其他人所做的任何更改都包含进去，然后您才能将您的更改提交到仓库中。 最好经常更新，使您检索的更改数量更少。

若要更新您的应用程序的工作副本，请点击 *更改中的 **更新** 按钮* 码头， 或选择 **项目 > 更新** 菜单项。

![更新按钮](attachments/modeler-core/update-button.png)

更新时您从仓库收到的更改与您对工作副本所作的更改合并(如果有的话)。 之后，您的工作副本将包含您的更改和您收到的更改。 作为更新的一部分，您的工作副本原件也会更新。

例如，如果您上次更新，您收到的所有更改直到并包含版本40。 这意味着你的工作副本的原件是40。 自从你开始修改你的工作副本以来，你的团队中的其他人又做了另外4次承诺（41、42、43和44）。 如果您现在更新，您将收到这些更改，44将成为您的更改被比较的新的 *原始*。

通常情况下，将您的更改与来自仓库的最新版本合并将自动完成。 例如，在您更改微流程时，一个人可能会添加一个表格。 但是，如果变化太接近，就可能产生冲突。 例如，如果您的团队已经更改了相同数据视图的属性，您也已经更改。 你必须先解决这种冲突，然后才能完成。 请参阅第6节 [处理冲突](#conflicts) 关于如何处理这个问题的信息。

如果您的团队经常承诺，您将不得不经常更新。 经常更新的好处是您在每次更新中收到的更改较少，因此将这些更改与您的工作结合起来比较容易。

### 4.4 历史

项目的 *历史* 是所有已提交的修订的列表。 要查看项目历史，请点击 *更改中的 **历史记录** 按钮* 码头， 或选择 **项目 > 更多版本 > 历史记录。 。** 菜单项

![历史按钮](attachments/modeler-core/history-button.png)

修改按时间顺序反向显示(最新的修改列在列表之首)。 历史表单显示每个版本的版本号、日期、时间、作者和消息。

选择一个版本来查看更多详细信息，如相关的开发者门户故事、更改文档、Modeler版本和磁盘上的更改。 图标概括了项目中发生的变化类型。

![](attachments/modeler-core/2018-02-21_14-06-46.png)

## 5 次还原更改

尚未作出的改变可以恢复。 例如，你对表单做了许多更改，你对结果不满意。 您可以将表单还原为原始表单：即在您开始进行更改之前的表单状态。

文档、文件夹和模块的删除也可以恢复。 这将使他们回到项目中。 请注意，您将会收到您提交的 *的最新版本*。 例如，如果您提交，对微流进行一些更改，然后删除微流， 恢复删除将会给您提供微流，而不会做任何更改。

您可以还原 *更改* 基座中的更改，或者从您想要还原的文档上的右键菜单中还原。

![两种还原方式](attachments/modeler-core/revertx2.png)

## 6 处理冲突{#conflicts}

如果您更新了您的应用并且更改不能自动合并，您将收到一条消息，告诉您存在冲突。 当两种变化无法合并时，就会产生冲突。

![冲突警告](attachments/modeler-core/contains-conflicts.png)

有两种不同的冲突：

* 文档冲突
* 项目冲突

### 6.1 解决文件冲突

在相同的 *文档* 中进行两次更改，实际上彼此相近，可能会导致文档冲突。 例如，两个人都会改变页面上同一个元素的属性。 文档将在 *更改* Dock 中标记为冲突。 冲突必须先解决，然后才能再次提交。

双击文档以查看哪些元素有冲突。 你也可以看到你所做的所有更改，以及其他人所做的所有更改。

![详细文档冲突](attachments/modeler-core/document-changes.png)

对于每个 *文档* ，您可以决定是否接受由 **我** 组成的冲突元素，并放弃对方的更改。 或者接受有冲突的元素，它们是 **theirs**，如果他们的更改更相关。

此决定适用于文档中的所有冲突；您不能选择您的版本来进行一些冲突的更改，而是对其他的更改。 没有冲突的更改将作为正常情况合并。

请确保您在 *更改* 码头中查看整个项目的更改 选择冲突的文档，并使用 **任务** 下拉菜单中所需的选项。

![使用更改基座解决冲突](attachments/modeler-core/resolve-document-conflict.png)

例如，如果您删除了一个表单中的数据视图，而另一个人则更改了该数据视图中的某些内容。 您可以点击“使用地雷”来放弃对方的更改。

解决冲突将使冲突消失，但是文件可能使冲突消失。 当然，如果要提交更改，仍然会被标记为已经改变。

## 6.2 解决项目冲突

项目冲突是指项目一级的冲突。 项目冲突有两个原因：

1.  一人删除一份文件，另一人在该文件中作了修改。
2.  这两个人移动了一份文件，但却到项目树中的不同地方。

所涉文档被标记为冲突文档，您可以在 *更改* Dock 的详细列中看到原因。

![项目冲突示例](attachments/modeler-core/project-conflicts.png)

{{% alert type="info" %}}
If a whole folder (or module) was *deleted* and another person changes a document inside that folder, the folder/module is restored and also marked as conflicted. 这种方式你知道是要删除该文件夹，但它已经被还原以向你显示更改的文档的上下文了。
{{% /报警 %}}

您可以通过选择 **任务 > 来解决项目冲突。使用我的** 或者通过删除所涉及的文件或文件夹。

## 7 使用分支

仓库可以包含一些开发线。 每个发展项目都提供来自其他发展项目的独立发展。 在简单的例子中，只有一条发展线称为主线(在颠覆中称为“trunk”)。 然后所有开发都发生在一条线内。

![](attachments/524294/688156.png)

有一个以上的发展线往往是方便的。 例如，一个用于修复当前部署的项目版本的 bug 的开发行和另一个用于开发新功能的开发行。 如果你在部署的版本中找到一个错误，你可以在相应的开发线中修复它，而不论开发新功能的开发线的状态。 更多关于分支的信息，请参阅 [版本控制](version-control)。

### 7.1 何时使用分支

#### 6.1.1 修补已部署应用

如果您想要将一些功能添加到已部署的应用程序中，或者您想要修复其中的一个bug。 你可以在不干扰其他发展的情况下这样做。

1. 确定部署应用程序的版本。 此信息在开发者门户。 或者，您可以在部署包 (mda) 归档的 **模型** 子文件夹中找到此版本。 例如， `"ModelVersion": "1.0.0.16"`
2. 选择 **项目 > 更多版本 > 管理分支线...** 并创建一个基于标签的分支，其名称为该版本号。

    ![](attachments/modeler-core/create-from-tag.png)

3. 添加功能或修复这个新创建的分支中的错误。
4. 测试情况是否如预期那样有效。
5. 创建一个更高版本号的部署存档 (增加补丁或次要版本)。

{{% alert type="info" %}}
我们建议您在需要时尽快将固定维修分支合并到主线。 如果合并过于复杂，无法自动进行，因为主行变化太大， 您将知道如何手动将修复应用到主行，因为您仍然想到的更改是新鲜的。

当然，并非所有维修修复都需要并入主线。 有时，它是在主线上完全重新设计或消除的东西的修复。 在这种情况下，合并是不必要的。
{{% /报警 %}}

#### 7.1.2 独立开发新功能

创立分支机构的另一个原因是在不影响其他发展的情况下发展一个大的新特点。 这使你可以自由地提供一个半实现的功能，甚至可能有错误， 其他人仍然可以在主线上进行承诺和更新。 不使用分支行， 您必须不断确保您的项目是免费的且不会破坏系统的其他部分。

首先，选择 **项目 > 更多版本 > 管理分支行...** 并从主行的版本创建分支。

![](attachments/modeler-core/2018-02-28_13-50-39.png)

现在在该分支上工作，直到完成功能并完成已完成的工作。

当你想要合并整个分支回到主行来整合该功能。 执行以下操作：

1. 打开主线。
2. 选择 **项目 > 更多版本 > 合并更改在这里**
3. 选择 **合并功能分支**。

    ![](attachments/modeler-core/2018-02-28_14-05-23.png)

4. 选择分支并点击 **合并**。
5. 解决任何冲突和错误。
6. 将新功能提交到正行。

如果你想要，你可以在合并后删除分支。

### 7.2 在桌面建模中与分支合作

#### 6.2.1 分支

除主线以外的发展线被称为分支线。 我们的建议是在 *主行* 中开发新功能，并使用 *分支行* 来修复已部署版本中的bug。 这是Modeler所提供的情景，但其他较复杂项目的情景也得到支持。

您可以从分支行管理器中创建分支行，您可以在 **项目 > 找到更多版本 > 管理分支行名。 。**.

![](attachments/modeler-core/2018-02-21_14-16-20.png)

#### 6.2.2 合并

如果你有多个开发线, 你有时想要端口从一个开发线到另一个开发线。 例如，你在生产版本的分支行中做出的修正也应适用于新的2。 您正在开发的版本在主行。 当然，你可以亲手这样做，但Modeler也可以通过将一个开发线的变化合并到另一个开发线来帮助你。

合并总是在您有工作副本打开时完成的。 合并将导致该工作副本中额外的本地更改。 最好先进行本地更改，然后再将额外的更改合并成一份工作副本。 否则， 未承诺的本地更改和合并引起的更改将被合并，如果您对合并不满意，很难解开它们。 如果您有未承诺的更改，Modeler将会警告您。

选择 **项目 > 更多版本 > 在这里合并**

选择适当的 *合并类型*, 例如 **端口修复**。

![](attachments/modeler-core/2018-02-21_14-19-47.png)

您可以合并单个版本，或从一个开发行到另一个开发行的一系列版本。 如果一个分支行代表一个大的新功能，你想要完全融入主线。 您可以合并分支的所有修订。

#### 6.2.3 逆向合并

还原更改对尚未进行的更改起作用。 已经进行的更改绝不能删除。 然而，你可以“逆向”应用更改并做出承诺。 此功能在模型中叫做“逆向合并”。

选择 **项目 > 更多版本... > 反向合并变化...**

![](attachments/modeler-core/revert-committed-changes.png)

在反向合并后，该项目将看起来像永远不会发生的变化。 如果您'反向合并'添加表单，表单将被本地删除。 就像当你正在进行正常合并时一样，冲突可能出现。 例如，如果后来提交更改添加的表格，反向合并将导致冲突。 在解决任何问题后，您可以将结果提交到仓库中。

## 8 版本化已部署到云端的项目

### 8.1 本地部署

开发时，您可以使用菜单项 **运行 > 本地运行** 在本地机器上部署和运行您的应用程序。 这允许您测试应用程序，因为它目前存储在您的本地机器上。

### 8.2 部署您的工作副本

当你部署到云端时，你可以选择使用存储在你本地机器上的应用版本， *工作副本* 并将其部署到默认环境。 如果您正在使用Mendix Cloud，或其他合作伙伴云（例如，SAP BTP）， 选择菜单项 **运行 > 运行** 来提交存储在您本地机器上的应用程序版本，并将其部署到默认环境。

### 8.3 选择具体的发展线和修订

还可以选择一个特定的开发线和修订线来部署到默认环境或创建一个包。

在这种情况下，Modeler将创建一个重新结算所选的修订版。 这意味着任何团队成员总是可以重新创建这个版本的部署包。 In other words, the Modeler does *not* rely on your local files for creating a versioned deployment package.

{{% alert type="warning" %}}
您只能创建一个已承诺更改的版本部署包。 如果你想要在一个版本控制的部署包中部署本地更改，请先提交它们。
{{% /报警 %}}

当创建软件包时，Modeler也会创建一个代表您项目的这个版本的标签。 如果您想要稍后修改此版本 独立于已经发生的其他开发，您可以创建一个基于此标签的分支。 标签的名称是您选择的版本号。

#### 8.3.1 将特定版本部署到Mendix 许可云节点

如果您正在使用 Mendix 云端，您可以选择 **Project > 部署到授权云端** 到 dpeloy 特定版本。

![](attachments/modeler-core/2018-02-21_17-05-05.png)

#### 8.3.2 从特定版本创建一个部署包

如果你正在使用不同的托管环境，你将使用菜单项 **项目 > 创建部署包...**

![](attachments/modeler-core/2018-02-28_13-44-04.png)

## 9 桌面模式外工作

Modeler自动处理某些文件管理。 如果您添加或删除自定义小部件，这些小部件也会自动添加或从版本控制中删除。 某些文件和目录（例如部署和发布目录）被自动忽略，这样它们就不会被用于版本控制。

我们建议您永远在Modeler中提交和更新，因为这种方式将有用的元数据添加到您的修订中。 Modeler可以从外部更新或合并中恢复，但最好不要依赖它。

### 9.1 种子SVN 和 Subclipse{#tortoisesvn-subclipse}

如果您正在对文件进行更高级的更改，如为您的项目添加Java 动作或资源， 您必须在您的电脑上安装TortoiseSVN并自己执行一些操作。 您可以在 [http://tortoisesvn.tigris.org/](http://tortoisesvn.tigris.org/) (选择1.7版本)免费下载。

另外，如果您正在使用 Eclipse 开发 Java 操作，我们建议您安装 Subclipse 以帮助您控制版本的 Java 文件。 您可以从 Eclipse Marketplace 或 [http://subclipse.tigris.org/](http://subclipse.tigris.org/) 下载Subclipse

### 9.2 添加文件和目录

如果您使用 Windows Explorer 添加文件或目录，或删除文件，Modeler 会自动从版本控制中添加或删除这些文件。

如果您正在复制一个已经在版本控制下的目录，请确保您使用 TortoiseSVN 导出功能。

### 9.3 删除文件和目录

如果您从您的项目中删除一个文件，Modeler也会自动从团队服务器中删除它。

如果您想要删除整个目录，您必须使用 TortoiseSVN 的删除命令。 您可以通过右键单击目录来执行此命令，并选择 'TortoiseSVN > Delete'。
